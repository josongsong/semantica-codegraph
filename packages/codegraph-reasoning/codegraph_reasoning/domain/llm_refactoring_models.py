"""
LLM-Guided Refactoring Domain Models (RFC-101 Phase 2)

Boundary-aware refactoring with LLM generation and multi-layer verification.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Optional

from .boundary_models import BoundaryCandidate, BoundarySpec


class RefactoringType(Enum):
    """Type of refactoring operation."""

    EXTRACT_FUNCTION = "extract_function"
    RENAME_SYMBOL = "rename_symbol"
    MOVE_CODE = "move_code"
    SPLIT_FUNCTION = "split_function"
    MERGE_FUNCTIONS = "merge_functions"
    OPTIMIZE_LOGIC = "optimize_logic"
    ADD_ERROR_HANDLING = "add_error_handling"
    REFACTOR_BOUNDARY = "refactor_boundary"  # NEW: Boundary-specific refactoring


class VerificationLevel(Enum):
    """Verification rigor level."""

    BASIC = "basic"  # Syntax + type checking
    STANDARD = "standard"  # + Effect preservation
    STRICT = "strict"  # + Test validation
    PARANOID = "paranoid"  # + Boundary integrity + Full regression


@dataclass
class RefactoringContext:
    """
    Context for LLM-guided refactoring.

    Includes boundary information for boundary-aware refactoring.
    """

    # Original code
    code: str
    file_path: str
    module_name: str = ""

    # Refactoring request
    refactoring_type: RefactoringType = RefactoringType.EXTRACT_FUNCTION
    instruction: str = ""  # Natural language instruction

    # Boundary context (NEW - Phase 2)
    boundary_spec: Optional[BoundarySpec] = None  # If refactoring affects boundary
    boundary_match: Optional[BoundaryCandidate] = None  # Matched boundary function

    # Additional context
    related_code: dict[str, str] = field(default_factory=dict)  # {file_path: code}
    test_files: list[str] = field(default_factory=list)  # Paths to test files

    # Configuration
    verification_level: VerificationLevel = VerificationLevel.STANDARD


@dataclass
class LLMPatch:
    """
    Patch generated by LLM.

    Includes rationale and confidence scoring.
    """

    # Patch content
    original_code: str
    patched_code: str
    description: str

    # LLM reasoning
    rationale: str = ""  # Why this refactoring
    confidence: float = 0.0  # 0.0-1.0
    alternative_approaches: list[str] = field(default_factory=list)

    # Diff metadata
    lines_added: int = 0
    lines_removed: int = 0
    files_affected: list[str] = field(default_factory=list)

    # Boundary impact (NEW - Phase 2)
    boundary_preserved: bool = True  # Does patch preserve boundary contract?
    boundary_changes: list[str] = field(default_factory=list)  # Boundary modifications
    breaking_change: bool = False  # Is this a breaking change?


@dataclass
class VerificationResult:
    """
    Multi-layer verification result.

    Combines syntax, type, effect, test, and boundary checks.
    """

    # Overall status
    success: bool
    verified_levels: list[str] = field(default_factory=list)  # ["syntax", "type", "effect"]

    # Layer 1: Syntax
    syntax_valid: bool = True
    syntax_error: Optional[str] = None

    # Layer 2: Type checking
    type_valid: bool = True
    type_errors: list[str] = field(default_factory=list)

    # Layer 3: Effect preservation
    effect_preserved: bool = True
    effect_violations: list[str] = field(default_factory=list)

    # Layer 4: Test validation
    tests_pass: Optional[bool] = None
    test_failures: list[str] = field(default_factory=list)

    # Layer 5: Boundary integrity (NEW - Phase 2)
    boundary_preserved: bool = True
    boundary_violations: list[str] = field(default_factory=list)
    contract_violations: list[str] = field(default_factory=list)

    # Layer 6: Intent preservation
    intent_preserved: bool = True
    intent_classification: Optional[str] = None  # "strict" | "weak" | "uncertain"

    # Performance metrics
    verification_time_ms: float = 0.0

    def __post_init__(self):
        """Validate verification result after initialization."""
        # Overall success requires all critical layers to pass
        if not self.syntax_valid:
            self.success = False
        if not self.type_valid:
            self.success = False
        if not self.boundary_preserved:
            self.success = False


@dataclass
class LLMRefactoringResult:
    """
    Final result of LLM-guided refactoring.

    Includes patch, verification, and approval status.
    """

    # Status
    success: bool
    phase: str  # "plan" | "generate" | "verify" | "apply"

    # Generated patch
    patch: Optional[LLMPatch] = None

    # Verification
    verification: Optional[VerificationResult] = None

    # Approval workflow
    requires_approval: bool = False
    approval_reason: Optional[str] = None
    auto_approved: bool = False

    # Error/Warning
    error: Optional[str] = None
    warning: Optional[str] = None

    # Performance
    total_time_ms: float = 0.0
    llm_time_ms: float = 0.0
    verification_time_ms: float = 0.0

    @property
    def verified(self) -> bool:
        """Whether patch has been verified."""
        return self.verification is not None and self.verification.success

    @property
    def safe_to_apply(self) -> bool:
        """Whether patch is safe to apply automatically."""
        return (
            self.success
            and self.verified
            and (self.auto_approved or not self.requires_approval)
            and (self.verification.boundary_preserved if self.verification else True)
        )


@dataclass
class BoundaryIntegrityCheck:
    """
    Boundary integrity verification.

    Ensures refactoring doesn't break service boundaries.
    """

    # Boundary information
    boundary_spec: BoundarySpec
    boundary_match: BoundaryCandidate

    # Integrity checks
    signature_preserved: bool = True  # Function signature unchanged
    contract_preserved: bool = True  # API contract maintained
    return_type_preserved: bool = True
    parameter_types_preserved: bool = True

    # HTTP-specific checks
    http_method_preserved: bool = True
    http_path_preserved: bool = True
    response_schema_preserved: bool = True

    # Breaking changes detected
    breaking_changes: list[str] = field(default_factory=list)

    # Warnings
    warnings: list[str] = field(default_factory=list)

    @property
    def safe(self) -> bool:
        """Whether boundary integrity is maintained."""
        return self.signature_preserved and self.contract_preserved and len(self.breaking_changes) == 0


@dataclass
class LLMGenerationConfig:
    """
    Configuration for LLM patch generation.

    Controls generation strategy and constraints.
    """

    # LLM parameters
    model: str = "gpt-4"
    temperature: float = 0.2  # Low temperature for deterministic refactoring
    max_tokens: int = 4000

    # Generation strategy
    use_examples: bool = True  # Include examples in prompt
    use_cot: bool = True  # Chain-of-thought reasoning
    num_alternatives: int = 3  # Generate N alternative patches

    # Constraints
    max_lines_changed: int = 100  # Maximum lines per patch
    preserve_style: bool = True  # Preserve code style
    preserve_comments: bool = True  # Keep existing comments

    # Boundary awareness (NEW - Phase 2)
    boundary_aware: bool = True  # Consider boundary constraints
    strict_boundary: bool = True  # Reject boundary-breaking changes

    # Safety settings
    require_tests: bool = True  # Require test validation
    require_type_check: bool = True
    allow_breaking: bool = False  # Allow breaking changes

    # Performance
    timeout_ms: int = 30000  # 30 seconds LLM timeout
    retry_on_error: bool = True
    max_retries: int = 3
