//! IR Document - the main output of IR generation
use crate::shared::models::{Node, Edge};
use serde::{Serialize, Deserialize};

#[cfg(feature = "cache")]
use rkyv::{Archive, Serialize as RkyvSerialize, Deserialize as RkyvDeserialize};

#[cfg(feature = "cache")]
use crate::features::cache::l1_adaptive_cache::EstimateSize;

#[derive(Debug, Clone, Default, PartialEq, Serialize, Deserialize)]
#[cfg_attr(feature = "cache", derive(Archive, RkyvSerialize, RkyvDeserialize))]
#[cfg_attr(feature = "cache", archive(check_bytes))]
pub struct IRDocument {
    pub file_path: String,
    pub nodes: Vec<Node>,
    pub edges: Vec<Edge>,
}

impl IRDocument {
    pub fn new(file_path: String) -> Self {
        Self {
            file_path,
            nodes: Vec::new(),
            edges: Vec::new(),
        }
    }

    /// Get all nodes (for QueryDSL)
    pub fn get_all_nodes(&self) -> Vec<Node> {
        self.nodes.clone()
    }

    /// Get all edges (for QueryDSL)
    pub fn get_all_edges(&self) -> Vec<Edge> {
        self.edges.clone()
    }

    /// Add node (for QueryDSL tests)
    pub fn add_node(&mut self, node: Node) {
        self.nodes.push(node);
    }

    /// Add edge (for QueryDSL tests)
    pub fn add_edge(&mut self, edge: Edge) {
        self.edges.push(edge);
    }
}

#[cfg(feature = "cache")]
impl EstimateSize for IRDocument {
    fn estimated_size_bytes(&self) -> usize {
        // Base struct size
        let base = std::mem::size_of::<Self>();

        // file_path string
        let file_path_size = self.file_path.capacity();

        // Nodes: each Node is ~500 bytes (conservative estimate)
        let nodes_size = self.nodes.len() * 512;

        // Edges: each Edge is ~100 bytes
        let edges_size = self.edges.len() * 128;

        base + file_path_size + nodes_size + edges_size
    }
}

#[cfg(all(test, feature = "cache"))]
mod tests {
    use super::*;
    use crate::shared::models::{NodeKind, EdgeKind, Span};

    #[test]
    fn test_ir_document_rkyv_roundtrip() {
        let mut ir_doc = IRDocument::new("test.py".to_string());

        ir_doc.add_node(Node::new(
            "node1".to_string(),
            NodeKind::Function,
            "test.foo".to_string(),
            "test.py".to_string(),
            Span::new(1, 0, 5, 0),
        ));

        // Serialize
        let bytes = rkyv::to_bytes::<_, 1024>(&ir_doc).unwrap();

        // Deserialize
        let archived = rkyv::check_archived_root::<IRDocument>(&bytes).unwrap();
        let restored: IRDocument = archived.deserialize(&mut rkyv::Infallible).unwrap();

        assert_eq!(ir_doc, restored);
        assert_eq!(ir_doc.nodes.len(), restored.nodes.len());
        assert_eq!(ir_doc.file_path, restored.file_path);
    }

    #[test]
    fn test_ir_document_estimate_size() {
        let mut ir_doc = IRDocument::new("test.py".to_string());

        // Empty document
        let size1 = ir_doc.estimated_size_bytes();
        assert!(size1 > 0);

        // Add 10 nodes
        for i in 0..10 {
            ir_doc.add_node(Node::new(
                format!("node{}", i),
                NodeKind::Function,
                format!("test.func{}", i),
                "test.py".to_string(),
                Span::new(i, 0, i+1, 0),
            ));
        }

        let size2 = ir_doc.estimated_size_bytes();
        assert!(size2 > size1);

        // Size should be roughly 10 * 512 bytes larger
        let diff = size2 - size1;
        assert!(diff >= 10 * 400 && diff <= 10 * 600,
                "Expected ~5KB diff, got {}", diff);
    }
}
