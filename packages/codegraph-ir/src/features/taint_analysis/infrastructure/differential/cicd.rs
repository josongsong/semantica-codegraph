/*
 * RFC-001: CI/CD Integration for Differential Taint Analysis
 *
 * Enables automated security regression detection in CI/CD pipelines.
 *
 * Features:
 * 1. GitHub Actions: PR comments, check runs, annotations
 * 2. GitLab CI: MR comments, pipeline status
 * 3. Generic: JSON/SARIF output for any CI system
 *
 * Performance:
 * - Target: < 5 seconds for report generation
 * - Async HTTP calls for non-blocking operation
 *
 * Security:
 * - No secrets logged
 * - Rate limiting respected
 * - Graceful degradation on API failures
 */

use std::collections::HashMap;
use std::fmt::Write as FmtWrite;

use super::error::{DifferentialError, DifferentialResult};
use super::result::{DiffStats, DifferentialTaintResult, Severity, Vulnerability};

/// Simple URL encoding for path components
/// Encodes characters that are not allowed in URLs
fn simple_url_encode(s: &str) -> String {
    let mut result = String::with_capacity(s.len() * 3);
    for c in s.chars() {
        match c {
            'a'..='z' | 'A'..='Z' | '0'..='9' | '-' | '_' | '.' | '~' => {
                result.push(c);
            }
            _ => {
                for b in c.to_string().as_bytes() {
                    write!(result, "%{:02X}", b).unwrap();
                }
            }
        }
    }
    result
}

// ============================================================================
// PR Comment Formatter
// ============================================================================

/// Formats differential analysis results for PR/MR comments
///
/// Supports multiple output formats:
/// - Markdown (GitHub/GitLab)
/// - Plain text (generic CI)
/// - JSON (machine-readable)
/// - SARIF (Static Analysis Results Interchange Format)
pub struct PRCommentFormatter;

impl PRCommentFormatter {
    /// Format result as GitHub-flavored Markdown
    ///
    /// # Example Output
    /// ```markdown
    /// ## üîí Security Regression Analysis
    ///
    /// ### üö® 1 New Vulnerability Detected
    ///
    /// | Severity | File | Source ‚Üí Sink | Description |
    /// |----------|------|---------------|-------------|
    /// | **HIGH** | src/db.py:5 | `user_input` ‚Üí `execute_sql` | Unsanitized input |
    ///
    /// ### ‚úÖ 1 Vulnerability Fixed
    /// ...
    /// ```
    pub fn format_markdown(result: &DifferentialTaintResult) -> String {
        let mut output = String::with_capacity(4096);

        // Header
        output.push_str("## üîí Security Regression Analysis\n\n");

        // Summary badge
        let badge = Self::create_status_badge(result);
        output.push_str(&badge);
        output.push_str("\n\n");

        // New vulnerabilities section
        if !result.new_vulnerabilities.is_empty() {
            Self::format_new_vulnerabilities(&mut output, &result.new_vulnerabilities);
        }

        // Fixed vulnerabilities section
        if !result.fixed_vulnerabilities.is_empty() {
            Self::format_fixed_vulnerabilities(&mut output, &result.fixed_vulnerabilities);
        }

        // Removed sanitizers warning
        if !result.removed_sanitizers.is_empty() {
            Self::format_removed_sanitizers(&mut output, result);
        }

        // Added sanitizers (positive)
        if !result.added_sanitizers.is_empty() {
            Self::format_added_sanitizers(&mut output, result);
        }

        // Partial fixes section
        if !result.partially_fixed.is_empty() {
            Self::format_partial_fixes(&mut output, result);
        }

        // Statistics footer
        Self::format_statistics(&mut output, &result.stats);

        // Footer with links
        output.push_str("\n---\n");
        output.push_str("*Generated by [Semantica Differential Taint Analysis](https://github.com/semantica/codegraph)*\n");

        output
    }

    /// Create status badge based on results
    fn create_status_badge(result: &DifferentialTaintResult) -> String {
        if result.has_high_severity_regression() {
            "![Security Status](https://img.shields.io/badge/security-CRITICAL-red) **Action Required**".to_string()
        } else if !result.new_vulnerabilities.is_empty() {
            format!(
                "![Security Status](https://img.shields.io/badge/security-{}_new_issues-orange) **Review Required**",
                result.new_vulnerabilities.len()
            )
        } else if !result.fixed_vulnerabilities.is_empty() {
            format!(
                "![Security Status](https://img.shields.io/badge/security-{}_fixed-green) **Improved**",
                result.fixed_vulnerabilities.len()
            )
        } else {
            "![Security Status](https://img.shields.io/badge/security-no_changes-lightgrey) **No Security Impact**".to_string()
        }
    }

    /// Format new vulnerabilities section
    fn format_new_vulnerabilities(output: &mut String, vulns: &[Vulnerability]) {
        let _ = writeln!(
            output,
            "### üö® {} New Vulnerabilit{} Detected\n",
            vulns.len(),
            if vulns.len() == 1 { "y" } else { "ies" }
        );

        // Table header
        output.push_str("| Severity | File | Source ‚Üí Sink | Description |\n");
        output.push_str("|:--------:|------|---------------|-------------|\n");

        for vuln in vulns {
            let severity_emoji = Self::severity_emoji(&vuln.severity);
            let _ = writeln!(
                output,
                "| {} **{}** | `{}:{}` | `{}` ‚Üí `{}` | {} |",
                severity_emoji,
                vuln.severity.as_str().to_uppercase(),
                vuln.file_path,
                vuln.source.line,
                vuln.source.name,
                vuln.sink.name,
                vuln.description
            );
        }
        output.push('\n');

        // Detailed breakdown for critical/high
        let critical_high: Vec<_> = vulns
            .iter()
            .filter(|v| matches!(v.severity, Severity::Critical | Severity::High))
            .collect();

        if !critical_high.is_empty() {
            output.push_str(
                "<details>\n<summary>üîç Detailed Analysis (Click to expand)</summary>\n\n",
            );
            for (i, vuln) in critical_high.iter().enumerate() {
                let _ = writeln!(
                    output,
                    "#### {}. {} ({})\n",
                    i + 1,
                    vuln.description,
                    vuln.severity.as_str()
                );
                let _ = writeln!(output, "**Taint Flow**:");
                let _ = writeln!(output, "```");
                let _ = writeln!(
                    output,
                    "Source: {} (line {})",
                    vuln.source.name, vuln.source.line
                );
                if let Some(ref path) = vuln.path_condition {
                    let _ = writeln!(output, "Path Condition: {}", path);
                }
                let _ = writeln!(output, "Sink: {} (line {})", vuln.sink.name, vuln.sink.line);
                let _ = writeln!(output, "```\n");

                if vuln.safe_in_base {
                    output.push_str("‚ö†Ô∏è **This was safe in the base version** - a regression was introduced.\n\n");
                }
            }
            output.push_str("</details>\n\n");
        }
    }

    /// Format fixed vulnerabilities section
    fn format_fixed_vulnerabilities(output: &mut String, vulns: &[Vulnerability]) {
        let _ = writeln!(
            output,
            "### ‚úÖ {} Vulnerabilit{} Fixed\n",
            vulns.len(),
            if vulns.len() == 1 { "y" } else { "ies" }
        );

        output.push_str("<details>\n<summary>View fixed issues</summary>\n\n");
        for vuln in vulns {
            let _ = writeln!(
                output,
                "- ~~**{}** in `{}:{}`: {} ‚Üí {}~~",
                vuln.severity.as_str(),
                vuln.file_path,
                vuln.source.line,
                vuln.source.name,
                vuln.sink.name
            );
        }
        output.push_str("\n</details>\n\n");
    }

    /// Format removed sanitizers warning
    fn format_removed_sanitizers(output: &mut String, result: &DifferentialTaintResult) {
        let _ = writeln!(
            output,
            "### ‚ö†Ô∏è {} Sanitizer{} Removed\n",
            result.removed_sanitizers.len(),
            if result.removed_sanitizers.len() == 1 {
                ""
            } else {
                "s"
            }
        );

        output.push_str("The following security controls were removed:\n\n");
        for san in &result.removed_sanitizers {
            let _ = writeln!(
                output,
                "- `{}` at `{}:{}`",
                san.function_name, san.file_path, san.line
            );
        }
        output.push('\n');
    }

    /// Format added sanitizers (positive feedback)
    fn format_added_sanitizers(output: &mut String, result: &DifferentialTaintResult) {
        let _ = writeln!(
            output,
            "### üõ°Ô∏è {} Sanitizer{} Added\n",
            result.added_sanitizers.len(),
            if result.added_sanitizers.len() == 1 {
                ""
            } else {
                "s"
            }
        );

        output.push_str("New security controls added:\n\n");
        for san in &result.added_sanitizers {
            let _ = writeln!(
                output,
                "- `{}` at `{}:{}`",
                san.function_name, san.file_path, san.line
            );
        }
        output.push('\n');
    }

    /// Format partial fixes section
    fn format_partial_fixes(output: &mut String, result: &DifferentialTaintResult) {
        let _ = writeln!(
            output,
            "### ‚è≥ {} Partial Fix{}\n",
            result.partially_fixed.len(),
            if result.partially_fixed.len() == 1 {
                ""
            } else {
                "es"
            }
        );

        output.push_str("These vulnerabilities are partially addressed but still have remaining attack paths:\n\n");
        for fix in &result.partially_fixed {
            let _ = writeln!(
                output,
                "- **{}**: {}/{} paths fixed ({}% coverage)",
                fix.vulnerability_id,
                fix.fixed_paths,
                fix.total_paths,
                (fix.fixed_paths * 100) / fix.total_paths.max(1)
            );
        }
        output.push('\n');
    }

    /// Format statistics footer
    fn format_statistics(output: &mut String, stats: &DiffStats) {
        output.push_str("### üìä Analysis Statistics\n\n");
        output.push_str("| Metric | Value |\n");
        output.push_str("|--------|-------|\n");
        let _ = writeln!(
            output,
            "| Base vulnerabilities | {} |",
            stats.base_vulnerabilities
        );
        let _ = writeln!(
            output,
            "| Modified vulnerabilities | {} |",
            stats.modified_vulnerabilities
        );
        let _ = writeln!(output, "| Files analyzed | {} |", stats.files_analyzed);
        let _ = writeln!(output, "| Analysis time | {}ms |", stats.analysis_time_ms);
        output.push('\n');
    }

    /// Get emoji for severity level
    fn severity_emoji(severity: &Severity) -> &'static str {
        match severity {
            Severity::Critical => "üî¥",
            Severity::High => "üü†",
            Severity::Medium => "üü°",
            Severity::Low => "üü¢",
            Severity::Info => "üîµ",
        }
    }

    /// Format result as plain text (for logs/emails)
    pub fn format_plain_text(result: &DifferentialTaintResult) -> String {
        let mut output = String::with_capacity(2048);

        output.push_str("=== Security Regression Analysis ===\n\n");

        if result.has_high_severity_regression() {
            output.push_str("STATUS: CRITICAL - Action Required\n\n");
        } else if !result.new_vulnerabilities.is_empty() {
            output.push_str("STATUS: WARNING - Review Required\n\n");
        } else {
            output.push_str("STATUS: OK - No Security Regressions\n\n");
        }

        output.push_str(&result.summary());
        output.push_str("\n\n");

        if !result.new_vulnerabilities.is_empty() {
            output.push_str("NEW VULNERABILITIES:\n");
            for (i, vuln) in result.new_vulnerabilities.iter().enumerate() {
                let _ = writeln!(
                    output,
                    "  {}. [{}] {} - {} -> {} ({}:{})",
                    i + 1,
                    vuln.severity.as_str().to_uppercase(),
                    vuln.description,
                    vuln.source.name,
                    vuln.sink.name,
                    vuln.file_path,
                    vuln.source.line
                );
            }
            output.push('\n');
        }

        if !result.fixed_vulnerabilities.is_empty() {
            output.push_str("FIXED VULNERABILITIES:\n");
            for (i, vuln) in result.fixed_vulnerabilities.iter().enumerate() {
                let _ = writeln!(
                    output,
                    "  {}. [{}] {} ({}:{})",
                    i + 1,
                    vuln.severity.as_str(),
                    vuln.description,
                    vuln.file_path,
                    vuln.source.line
                );
            }
        }

        output
    }

    /// Format result as JSON
    pub fn format_json(result: &DifferentialTaintResult) -> String {
        serde_json::to_string_pretty(result).unwrap_or_else(|_| "{}".to_string())
    }

    /// Format result as SARIF (Static Analysis Results Interchange Format)
    ///
    /// SARIF is the standard format for static analysis tools, supported by:
    /// - GitHub Code Scanning
    /// - Azure DevOps
    /// - Visual Studio
    pub fn format_sarif(result: &DifferentialTaintResult, tool_version: &str) -> String {
        let sarif = SarifReport::from_differential_result(result, tool_version);
        serde_json::to_string_pretty(&sarif).unwrap_or_else(|_| "{}".to_string())
    }
}

// ============================================================================
// SARIF Report Structure
// ============================================================================

/// SARIF 2.1.0 compliant report structure
#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SarifReport {
    #[serde(rename = "$schema")]
    pub schema: String,
    pub version: String,
    pub runs: Vec<SarifRun>,
}

#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SarifRun {
    pub tool: SarifTool,
    pub results: Vec<SarifResult>,
    pub invocations: Vec<SarifInvocation>,
}

#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SarifTool {
    pub driver: SarifDriver,
}

#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SarifDriver {
    pub name: String,
    pub version: String,
    pub information_uri: String,
    pub rules: Vec<SarifRule>,
}

#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SarifRule {
    pub id: String,
    pub name: String,
    pub short_description: SarifMessage,
    pub full_description: SarifMessage,
    pub default_configuration: SarifRuleConfig,
}

#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SarifRuleConfig {
    pub level: String,
}

#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SarifMessage {
    pub text: String,
}

#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SarifResult {
    pub rule_id: String,
    pub level: String,
    pub message: SarifMessage,
    pub locations: Vec<SarifLocation>,
    pub related_locations: Vec<SarifLocation>,
}

#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SarifLocation {
    pub physical_location: SarifPhysicalLocation,
}

#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SarifPhysicalLocation {
    pub artifact_location: SarifArtifactLocation,
    pub region: SarifRegion,
}

#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SarifArtifactLocation {
    pub uri: String,
}

#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SarifRegion {
    pub start_line: u32,
    pub start_column: Option<u32>,
    pub end_line: Option<u32>,
    pub end_column: Option<u32>,
}

#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SarifInvocation {
    pub execution_successful: bool,
    pub exit_code: i32,
}

impl SarifReport {
    /// Create SARIF report from differential analysis result
    pub fn from_differential_result(result: &DifferentialTaintResult, version: &str) -> Self {
        let rules = vec![
            SarifRule {
                id: "TAINT-001".to_string(),
                name: "TaintFlowRegression".to_string(),
                short_description: SarifMessage {
                    text: "New taint flow detected (security regression)".to_string(),
                },
                full_description: SarifMessage {
                    text: "A new path from untrusted source to sensitive sink was introduced"
                        .to_string(),
                },
                default_configuration: SarifRuleConfig {
                    level: "error".to_string(),
                },
            },
            SarifRule {
                id: "TAINT-002".to_string(),
                name: "SanitizerRemoved".to_string(),
                short_description: SarifMessage {
                    text: "Security sanitizer was removed".to_string(),
                },
                full_description: SarifMessage {
                    text: "A sanitization function was removed, potentially exposing taint flows"
                        .to_string(),
                },
                default_configuration: SarifRuleConfig {
                    level: "warning".to_string(),
                },
            },
        ];

        let mut sarif_results = Vec::new();

        // Convert vulnerabilities to SARIF results
        for vuln in &result.new_vulnerabilities {
            sarif_results.push(SarifResult {
                rule_id: "TAINT-001".to_string(),
                level: Self::severity_to_sarif_level(&vuln.severity),
                message: SarifMessage {
                    text: format!(
                        "{}: {} ‚Üí {}",
                        vuln.description, vuln.source.name, vuln.sink.name
                    ),
                },
                locations: vec![SarifLocation {
                    physical_location: SarifPhysicalLocation {
                        artifact_location: SarifArtifactLocation {
                            uri: vuln.file_path.clone(),
                        },
                        region: SarifRegion {
                            start_line: vuln.source.line,
                            start_column: None,
                            end_line: None,
                            end_column: None,
                        },
                    },
                }],
                related_locations: vec![SarifLocation {
                    physical_location: SarifPhysicalLocation {
                        artifact_location: SarifArtifactLocation {
                            uri: vuln.file_path.clone(),
                        },
                        region: SarifRegion {
                            start_line: vuln.sink.line,
                            start_column: None,
                            end_line: None,
                            end_column: None,
                        },
                    },
                }],
            });
        }

        // Convert removed sanitizers to SARIF results
        for san in &result.removed_sanitizers {
            sarif_results.push(SarifResult {
                rule_id: "TAINT-002".to_string(),
                level: "warning".to_string(),
                message: SarifMessage {
                    text: format!("Sanitizer '{}' was removed", san.function_name),
                },
                locations: vec![SarifLocation {
                    physical_location: SarifPhysicalLocation {
                        artifact_location: SarifArtifactLocation {
                            uri: san.file_path.clone(),
                        },
                        region: SarifRegion {
                            start_line: san.line as u32,
                            start_column: None,
                            end_line: None,
                            end_column: None,
                        },
                    },
                }],
                related_locations: vec![],
            });
        }

        SarifReport {
            schema: "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json".to_string(),
            version: "2.1.0".to_string(),
            runs: vec![SarifRun {
                tool: SarifTool {
                    driver: SarifDriver {
                        name: "Semantica Differential Taint Analysis".to_string(),
                        version: version.to_string(),
                        information_uri: "https://github.com/semantica/codegraph".to_string(),
                        rules,
                    },
                },
                results: sarif_results,
                invocations: vec![SarifInvocation {
                    execution_successful: true,
                    exit_code: 0,
                }],
            }],
        }
    }

    fn severity_to_sarif_level(severity: &Severity) -> String {
        match severity {
            Severity::Critical | Severity::High => "error".to_string(),
            Severity::Medium => "warning".to_string(),
            Severity::Low | Severity::Info => "note".to_string(),
        }
    }
}

// ============================================================================
// GitHub Actions Reporter
// ============================================================================

/// GitHub Actions integration for differential taint analysis
///
/// Supports:
/// - PR comments via Issues API
/// - Check runs with annotations
/// - Workflow commands (::error::, ::warning::)
/// - SARIF upload for Code Scanning
pub struct GitHubActionsReporter {
    /// GitHub token (PAT or GITHUB_TOKEN)
    token: String,

    /// Repository owner
    owner: String,

    /// Repository name
    repo: String,

    /// API base URL (for GitHub Enterprise)
    api_base: String,
}

impl GitHubActionsReporter {
    /// Create new reporter with GitHub token
    pub fn new(
        token: impl Into<String>,
        owner: impl Into<String>,
        repo: impl Into<String>,
    ) -> Self {
        Self {
            token: token.into(),
            owner: owner.into(),
            repo: repo.into(),
            api_base: "https://api.github.com".to_string(),
        }
    }

    /// Set custom API base for GitHub Enterprise
    pub fn with_api_base(mut self, base: impl Into<String>) -> Self {
        self.api_base = base.into();
        self
    }

    /// Post PR comment with analysis results
    ///
    /// # Arguments
    /// * `pr_number` - Pull request number
    /// * `result` - Differential analysis result
    ///
    /// # Returns
    /// Comment ID on success
    pub async fn post_pr_comment(
        &self,
        pr_number: u64,
        result: &DifferentialTaintResult,
    ) -> DifferentialResult<u64> {
        let comment_body = PRCommentFormatter::format_markdown(result);

        let url = format!(
            "{}/repos/{}/{}/issues/{}/comments",
            self.api_base, self.owner, self.repo, pr_number
        );

        // Build request body
        let body = serde_json::json!({
            "body": comment_body
        });

        // In real implementation, use reqwest or similar
        // For now, return placeholder with the URL and body info
        #[cfg(feature = "http")]
        {
            let client = reqwest::Client::new();
            let response = client
                .post(&url)
                .header("Authorization", format!("token {}", self.token))
                .header("Accept", "application/vnd.github.v3+json")
                .header("User-Agent", "semantica-differential-taint")
                .json(&body)
                .send()
                .await
                .map_err(|e| DifferentialError::git_error(format!("HTTP error: {}", e)))?;

            if !response.status().is_success() {
                return Err(DifferentialError::git_error(format!(
                    "GitHub API error: {}",
                    response.status()
                )));
            }

            let json: serde_json::Value = response
                .json()
                .await
                .map_err(|e| DifferentialError::git_error(format!("JSON parse error: {}", e)))?;

            Ok(json["id"].as_u64().unwrap_or(0))
        }

        #[cfg(not(feature = "http"))]
        {
            // Placeholder for testing without HTTP
            eprintln!("[GitHubActionsReporter] Would POST to: {}", url);
            eprintln!(
                "[GitHubActionsReporter] Body length: {} bytes",
                comment_body.len()
            );
            Ok(0)
        }
    }

    /// Create check run with detailed annotations
    ///
    /// # Arguments
    /// * `commit_sha` - Commit SHA to annotate
    /// * `result` - Differential analysis result
    ///
    /// # Returns
    /// Check run ID on success
    pub async fn create_check_run(
        &self,
        commit_sha: &str,
        result: &DifferentialTaintResult,
    ) -> DifferentialResult<u64> {
        let conclusion = Self::determine_conclusion(result);
        let annotations = Self::build_annotations(result);

        let summary = format!(
            "## Security Analysis Results\n\n{}\n\n{}",
            result.summary(),
            if result.has_high_severity_regression() {
                "‚ö†Ô∏è **High/Critical severity issues require immediate attention**"
            } else {
                "‚úÖ No critical security issues found"
            }
        );

        let body = serde_json::json!({
            "name": "Differential Taint Analysis",
            "head_sha": commit_sha,
            "status": "completed",
            "conclusion": conclusion,
            "output": {
                "title": Self::check_run_title(result),
                "summary": summary,
                "annotations": annotations
            }
        });

        let url = format!(
            "{}/repos/{}/{}/check-runs",
            self.api_base, self.owner, self.repo
        );

        #[cfg(feature = "http")]
        {
            let client = reqwest::Client::new();
            let response = client
                .post(&url)
                .header("Authorization", format!("token {}", self.token))
                .header("Accept", "application/vnd.github.v3+json")
                .header("User-Agent", "semantica-differential-taint")
                .json(&body)
                .send()
                .await
                .map_err(|e| DifferentialError::git_error(format!("HTTP error: {}", e)))?;

            if !response.status().is_success() {
                return Err(DifferentialError::git_error(format!(
                    "GitHub API error: {}",
                    response.status()
                )));
            }

            let json: serde_json::Value = response
                .json()
                .await
                .map_err(|e| DifferentialError::git_error(format!("JSON parse error: {}", e)))?;

            Ok(json["id"].as_u64().unwrap_or(0))
        }

        #[cfg(not(feature = "http"))]
        {
            eprintln!("[GitHubActionsReporter] Would POST check run to: {}", url);
            eprintln!("[GitHubActionsReporter] Conclusion: {}", conclusion);
            eprintln!("[GitHubActionsReporter] Annotations: {}", annotations.len());
            Ok(0)
        }
    }

    /// Generate GitHub Actions workflow commands
    ///
    /// These are printed to stdout and parsed by the GitHub Actions runner:
    /// - `::error file=app.js,line=1::Error message`
    /// - `::warning file=app.js,line=1::Warning message`
    pub fn generate_workflow_commands(result: &DifferentialTaintResult) -> String {
        let mut output = String::new();

        for vuln in &result.new_vulnerabilities {
            let level = match vuln.severity {
                Severity::Critical | Severity::High => "error",
                Severity::Medium => "warning",
                _ => "notice",
            };

            let _ = writeln!(
                output,
                "::{} file={},line={}::{}",
                level,
                vuln.file_path,
                vuln.source.line,
                vuln.description.replace('\n', "%0A")
            );
        }

        for san in &result.removed_sanitizers {
            let _ = writeln!(
                output,
                "::warning file={},line={}::Sanitizer '{}' was removed",
                san.file_path, san.line, san.function_name
            );
        }

        output
    }

    /// Determine check run conclusion based on results
    fn determine_conclusion(result: &DifferentialTaintResult) -> &'static str {
        if result.has_high_severity_regression() {
            "failure"
        } else if !result.new_vulnerabilities.is_empty() {
            "neutral" // Warning, doesn't fail the build
        } else {
            "success"
        }
    }

    /// Generate check run title
    fn check_run_title(result: &DifferentialTaintResult) -> String {
        if result.has_high_severity_regression() {
            format!(
                "üö® {} Critical/High Security Regressions",
                result
                    .new_vulnerabilities
                    .iter()
                    .filter(|v| matches!(v.severity, Severity::Critical | Severity::High))
                    .count()
            )
        } else if !result.new_vulnerabilities.is_empty() {
            format!(
                "‚ö†Ô∏è {} Security Issues Found",
                result.new_vulnerabilities.len()
            )
        } else if !result.fixed_vulnerabilities.is_empty() {
            format!(
                "‚úÖ {} Security Issues Fixed",
                result.fixed_vulnerabilities.len()
            )
        } else {
            "‚úÖ No Security Regressions".to_string()
        }
    }

    /// Build annotations for check run
    fn build_annotations(result: &DifferentialTaintResult) -> Vec<serde_json::Value> {
        let mut annotations = Vec::new();

        for vuln in &result.new_vulnerabilities {
            annotations.push(serde_json::json!({
                "path": vuln.file_path,
                "start_line": vuln.source.line,
                "end_line": vuln.source.line,
                "annotation_level": match vuln.severity {
                    Severity::Critical | Severity::High => "failure",
                    Severity::Medium => "warning",
                    _ => "notice"
                },
                "title": format!("[{}] {}", vuln.category.as_str(), vuln.description),
                "message": format!(
                    "Taint flow: {} ‚Üí {}\n{}",
                    vuln.source.name,
                    vuln.sink.name,
                    if vuln.safe_in_base { "‚ö†Ô∏è This was safe in the base version" } else { "" }
                )
            }));
        }

        // Limit to 50 annotations (GitHub API limit)
        annotations.truncate(50);
        annotations
    }
}

// ============================================================================
// GitLab CI Reporter
// ============================================================================

/// GitLab CI integration for differential taint analysis
pub struct GitLabCIReporter {
    /// GitLab API token
    token: String,

    /// Project ID or path
    project: String,

    /// API base URL
    api_base: String,
}

impl GitLabCIReporter {
    /// Create new reporter
    pub fn new(token: impl Into<String>, project: impl Into<String>) -> Self {
        Self {
            token: token.into(),
            project: project.into(),
            api_base: "https://gitlab.com/api/v4".to_string(),
        }
    }

    /// Set custom API base for self-hosted GitLab
    pub fn with_api_base(mut self, base: impl Into<String>) -> Self {
        self.api_base = base.into();
        self
    }

    /// Post MR comment
    pub async fn post_mr_comment(
        &self,
        mr_iid: u64,
        result: &DifferentialTaintResult,
    ) -> DifferentialResult<u64> {
        let comment_body = PRCommentFormatter::format_markdown(result);

        let url = format!(
            "{}/projects/{}/merge_requests/{}/notes",
            self.api_base,
            simple_url_encode(&self.project),
            mr_iid
        );

        #[cfg(not(feature = "http"))]
        {
            eprintln!("[GitLabCIReporter] Would POST to: {}", url);
            eprintln!(
                "[GitLabCIReporter] Body length: {} bytes",
                comment_body.len()
            );
            Ok(0)
        }

        #[cfg(feature = "http")]
        {
            let client = reqwest::Client::new();
            let response = client
                .post(&url)
                .header("PRIVATE-TOKEN", &self.token)
                .form(&[("body", comment_body)])
                .send()
                .await
                .map_err(|e| DifferentialError::git_error(format!("HTTP error: {}", e)))?;

            if !response.status().is_success() {
                return Err(DifferentialError::git_error(format!(
                    "GitLab API error: {}",
                    response.status()
                )));
            }

            let json: serde_json::Value = response
                .json()
                .await
                .map_err(|e| DifferentialError::git_error(format!("JSON parse error: {}", e)))?;

            Ok(json["id"].as_u64().unwrap_or(0))
        }
    }

    /// Generate GitLab CI report artifact (CodeQuality format)
    pub fn generate_code_quality_report(result: &DifferentialTaintResult) -> String {
        let mut issues = Vec::new();

        for vuln in &result.new_vulnerabilities {
            issues.push(serde_json::json!({
                "type": "issue",
                "check_name": "differential-taint",
                "description": vuln.description,
                "content": {
                    "body": format!("Taint flow: {} ‚Üí {}", vuln.source.name, vuln.sink.name)
                },
                "categories": ["Security"],
                "severity": match vuln.severity {
                    Severity::Critical => "blocker",
                    Severity::High => "critical",
                    Severity::Medium => "major",
                    Severity::Low => "minor",
                    Severity::Info => "info"
                },
                "location": {
                    "path": vuln.file_path,
                    "lines": {
                        "begin": vuln.source.line
                    }
                },
                "fingerprint": format!("taint-{}-{}-{}", vuln.file_path, vuln.source.name, vuln.sink.name)
            }));
        }

        serde_json::to_string_pretty(&issues).unwrap_or_else(|_| "[]".to_string())
    }
}

// ============================================================================
// CI Exit Code Helper
// ============================================================================

/// Determine appropriate exit code for CI pipelines
pub struct CIExitCode;

impl CIExitCode {
    /// Get exit code based on analysis result
    ///
    /// Exit codes:
    /// - 0: Success (no issues or only low/info)
    /// - 1: Failure (high/critical issues)
    /// - 2: Warning (medium issues, configurable fail)
    pub fn from_result(result: &DifferentialTaintResult, fail_on_medium: bool) -> i32 {
        if result.has_high_severity_regression() {
            1 // Failure
        } else if fail_on_medium
            && result
                .new_vulnerabilities
                .iter()
                .any(|v| matches!(v.severity, Severity::Medium))
        {
            2 // Warning (treated as failure if configured)
        } else {
            0 // Success
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::features::taint_analysis::infrastructure::differential::result::{
        TaintSink, TaintSource, VulnerabilityCategory,
    };

    fn create_test_result() -> DifferentialTaintResult {
        let mut result = DifferentialTaintResult::new();

        result.new_vulnerabilities.push(Vulnerability {
            id: "vuln-001".to_string(),
            severity: Severity::High,
            category: VulnerabilityCategory::TaintFlowIntroduced,
            source: TaintSource {
                name: "user_input".to_string(),
                line: 5,
                column: None,
                file_path: None,
            },
            sink: TaintSink {
                name: "execute_sql".to_string(),
                line: 10,
                column: None,
                file_path: None,
            },
            file_path: "src/db.py".to_string(),
            description: "SQL Injection vulnerability".to_string(),
            safe_in_base: true,
            path_condition: None,
            confidence: 0.95,
        });

        result.fixed_vulnerabilities.push(Vulnerability {
            id: "vuln-002".to_string(),
            severity: Severity::Medium,
            category: VulnerabilityCategory::TaintFlowIntroduced,
            source: TaintSource {
                name: "input".to_string(),
                line: 15,
                column: None,
                file_path: None,
            },
            sink: TaintSink {
                name: "render".to_string(),
                line: 20,
                column: None,
                file_path: None,
            },
            file_path: "src/view.py".to_string(),
            description: "XSS vulnerability".to_string(),
            safe_in_base: false,
            path_condition: None,
            confidence: 0.90,
        });

        result.stats.base_vulnerabilities = 2;
        result.stats.modified_vulnerabilities = 1;
        result.stats.files_analyzed = 5;
        result.stats.analysis_time_ms = 150;

        result
    }

    #[test]
    fn test_markdown_format_with_vulnerabilities() {
        let result = create_test_result();
        let markdown = PRCommentFormatter::format_markdown(&result);

        assert!(markdown.contains("Security Regression Analysis"));
        assert!(markdown.contains("1 New Vulnerability Detected"));
        assert!(markdown.contains("SQL Injection"));
        assert!(markdown.contains("user_input"));
        assert!(markdown.contains("execute_sql"));
        assert!(markdown.contains("src/db.py"));
        assert!(markdown.contains("1 Vulnerability Fixed"));
    }

    #[test]
    fn test_markdown_format_no_issues() {
        let result = DifferentialTaintResult::new();
        let markdown = PRCommentFormatter::format_markdown(&result);

        assert!(markdown.contains("no_changes"));
        assert!(!markdown.contains("New Vulnerability"));
    }

    #[test]
    fn test_plain_text_format() {
        let result = create_test_result();
        let text = PRCommentFormatter::format_plain_text(&result);

        assert!(text.contains("Security Regression Analysis"));
        assert!(text.contains("NEW VULNERABILITIES"));
        assert!(text.contains("[HIGH]"));
        assert!(text.contains("SQL Injection"));
    }

    #[test]
    fn test_sarif_format() {
        let result = create_test_result();
        let sarif = PRCommentFormatter::format_sarif(&result, "1.0.0");

        assert!(sarif.contains("sarif-schema-2.1.0"));
        assert!(sarif.contains("Semantica Differential Taint Analysis"));
        assert!(sarif.contains("TAINT-001"));
        assert!(sarif.contains("src/db.py"));
    }

    #[test]
    fn test_workflow_commands() {
        let result = create_test_result();
        let commands = GitHubActionsReporter::generate_workflow_commands(&result);

        assert!(commands.contains("::error file=src/db.py,line=5::"));
        assert!(commands.contains("SQL Injection"));
    }

    #[test]
    fn test_ci_exit_code_high_severity() {
        let result = create_test_result();
        let exit_code = CIExitCode::from_result(&result, false);

        assert_eq!(exit_code, 1); // Failure due to high severity
    }

    #[test]
    fn test_ci_exit_code_no_issues() {
        let result = DifferentialTaintResult::new();
        let exit_code = CIExitCode::from_result(&result, false);

        assert_eq!(exit_code, 0); // Success
    }

    #[test]
    fn test_gitlab_code_quality_report() {
        let result = create_test_result();
        let report = GitLabCIReporter::generate_code_quality_report(&result);

        assert!(report.contains("differential-taint"));
        assert!(report.contains("SQL Injection"));
        assert!(report.contains("src/db.py"));
        assert!(report.contains("critical"));
    }

    #[test]
    fn test_github_reporter_creation() {
        let reporter = GitHubActionsReporter::new("token", "owner", "repo");
        assert_eq!(reporter.token, "token");
        assert_eq!(reporter.owner, "owner");
        assert_eq!(reporter.repo, "repo");
    }

    #[test]
    fn test_gitlab_reporter_creation() {
        let reporter = GitLabCIReporter::new("token", "group/project");
        assert_eq!(reporter.token, "token");
        assert_eq!(reporter.project, "group/project");
    }
}
