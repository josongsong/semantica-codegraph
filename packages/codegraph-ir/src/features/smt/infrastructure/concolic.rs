//! Concolic Testing Engine (KLEE-style)
//!
//! Academic References:
//! - Sen, K., Marinov, D., Agha, G. (2005). "CUTE: A Concolic Unit Testing Engine"
//! - Cadar, C., Dunbar, D., Engler, D. (2008). "KLEE: Unassisted and Automatic
//!   Generation of High-Coverage Tests for Complex Systems Programs"
//! - Godefroid, P., Klarlund, N., Sen, K. (2005). "DART: Directed Automated
//!   Random Testing"
//!
//! ## Concolic Testing Overview
//!
//! Concolic = **Conc**rete + Symb**olic**
//!
//! Key insight: Execute program with concrete inputs while maintaining
//! symbolic constraints. At branches, negate path conditions to generate
//! new test inputs that explore different paths.
//!
//! ```text
//! Algorithm:
//! 1. Start with random/default inputs
//! 2. Execute concretely, collecting path conditions
//! 3. Negate one branch condition
//! 4. Solve for new inputs
//! 5. Repeat until coverage goal met or timeout
//! ```
//!
//! ## Example
//!
//! ```python
//! def foo(x, y):
//!     if x > 0:          # Branch 1
//!         if y == 10:    # Branch 2
//!             error()    # Target
//! ```
//!
//! Execution trace:
//! - Input: x=5, y=7
//! - Path: [x>0, y≠10]
//! - Negate y≠10 → y=10
//! - New input: x=5, y=10 → reaches error()

use crate::features::heap_analysis::symbolic_memory::{
    Address, CompareOp, PathCondition, SymbolicExpr, SymbolicMemory, SymbolicValue,
};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet, VecDeque};

// ═══════════════════════════════════════════════════════════════════════════
// Core Types
// ═══════════════════════════════════════════════════════════════════════════

/// Concolic execution state
#[derive(Debug, Clone)]
pub struct ConcolicState {
    /// Concrete values for inputs
    pub concrete_inputs: HashMap<String, ConcreteValue>,
    /// Symbolic expressions for inputs
    pub symbolic_inputs: HashMap<String, SymbolicExpr>,
    /// Path condition (conjunction of branch conditions)
    pub path_condition: Vec<BranchCondition>,
    /// Memory state
    pub memory: SymbolicMemory,
    /// Execution depth
    pub depth: usize,
    /// State ID (for exploration)
    pub id: u64,
}

/// Concrete value for execution
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ConcreteValue {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
    Null,
}

impl ConcreteValue {
    pub fn as_int(&self) -> Option<i64> {
        match self {
            Self::Int(i) => Some(*i),
            Self::Bool(b) => Some(if *b { 1 } else { 0 }),
            _ => None,
        }
    }

    pub fn as_bool(&self) -> Option<bool> {
        match self {
            Self::Bool(b) => Some(*b),
            Self::Int(i) => Some(*i != 0),
            _ => None,
        }
    }
}

/// Branch condition from execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BranchCondition {
    /// Location of branch (file:line)
    pub location: String,
    /// Symbolic condition
    pub condition: PathCondition,
    /// Which branch was taken (true/false)
    pub taken: bool,
    /// Depth at which this branch was encountered
    pub depth: usize,
}

impl BranchCondition {
    /// Get the actual constraint based on which branch was taken
    pub fn as_constraint(&self) -> PathCondition {
        if self.taken {
            self.condition.clone()
        } else {
            self.condition.clone().not()
        }
    }

    /// Negate this branch (for exploration)
    pub fn negate(&self) -> Self {
        Self {
            location: self.location.clone(),
            condition: self.condition.clone(),
            taken: !self.taken,
            depth: self.depth,
        }
    }
}

/// Test input generated by concolic testing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestInput {
    /// Input values
    pub values: HashMap<String, ConcreteValue>,
    /// Path that led to this input (for debugging)
    pub path_description: String,
    /// Expected behavior
    pub expected: TestExpectation,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TestExpectation {
    /// Normal execution
    Normal,
    /// Should trigger error/exception
    Error(String),
    /// Should reach specific location
    ReachLocation(String),
}

/// Concolic exploration result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExplorationResult {
    /// Generated test inputs
    pub test_inputs: Vec<TestInput>,
    /// Paths explored
    pub paths_explored: usize,
    /// Paths pruned (infeasible)
    pub paths_pruned: usize,
    /// Coverage achieved (branches)
    pub branch_coverage: f64,
    /// Errors found
    pub errors_found: Vec<ErrorReport>,
    /// Statistics
    pub stats: ExplorationStats,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ExplorationStats {
    pub paths_explored: usize,
    pub paths_pruned: usize,
    pub solver_calls: usize,
    pub solver_sat: usize,
    pub solver_unsat: usize,
    pub solver_timeout: usize,
    pub max_depth_reached: usize,
    pub total_time_ms: u64,
}

/// Error found during exploration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorReport {
    pub kind: ErrorKind,
    pub location: String,
    pub message: String,
    pub input: HashMap<String, ConcreteValue>,
    pub path: Vec<String>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ErrorKind {
    NullDereference,
    BufferOverflow,
    UseAfterFree,
    DivisionByZero,
    AssertionFailure,
    Custom,
}

// ═══════════════════════════════════════════════════════════════════════════
// Concolic Engine
// ═══════════════════════════════════════════════════════════════════════════

/// Configuration for concolic testing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConcolicConfig {
    /// Maximum exploration depth
    pub max_depth: usize,
    /// Maximum number of paths to explore
    pub max_paths: usize,
    /// Solver timeout (ms)
    pub solver_timeout_ms: u32,
    /// Search strategy
    pub strategy: SearchStrategy,
    /// Enable branch coverage tracking
    pub track_coverage: bool,
}

impl Default for ConcolicConfig {
    fn default() -> Self {
        Self {
            max_depth: 100,
            max_paths: 1000,
            solver_timeout_ms: 5000,
            strategy: SearchStrategy::DFS,
            track_coverage: true,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum SearchStrategy {
    /// Depth-first search
    DFS,
    /// Breadth-first search
    BFS,
    /// Random path selection
    Random,
    /// Coverage-guided (prioritize uncovered branches)
    CoverageGuided,
}

/// Concolic testing engine
pub struct ConcolicEngine {
    config: ConcolicConfig,
    /// Worklist of states to explore
    worklist: VecDeque<ConcolicState>,
    /// Covered branches (location → {true, false})
    covered_branches: HashMap<String, HashSet<bool>>,
    /// All branches discovered
    all_branches: HashSet<String>,
    /// Generated test inputs
    test_inputs: Vec<TestInput>,
    /// Errors found
    errors: Vec<ErrorReport>,
    /// Statistics
    stats: ExplorationStats,
    /// Next state ID
    next_state_id: u64,
}

impl ConcolicEngine {
    pub fn new(config: ConcolicConfig) -> Self {
        Self {
            config,
            worklist: VecDeque::new(),
            covered_branches: HashMap::new(),
            all_branches: HashSet::new(),
            test_inputs: Vec::new(),
            errors: Vec::new(),
            stats: ExplorationStats::default(),
            next_state_id: 0,
        }
    }

    /// Create initial state with given inputs
    pub fn create_initial_state(
        &mut self,
        inputs: HashMap<String, ConcreteValue>,
    ) -> ConcolicState {
        let id = self.next_state_id;
        self.next_state_id += 1;

        let mut memory = SymbolicMemory::new();
        let mut symbolic_inputs = HashMap::new();

        // Create symbolic versions of inputs
        for (name, _value) in &inputs {
            symbolic_inputs.insert(name.clone(), SymbolicExpr::symbol(name.clone()));
            memory.make_symbolic(name.clone(), SymbolicExpr::concrete(8));
        }

        ConcolicState {
            concrete_inputs: inputs,
            symbolic_inputs,
            path_condition: Vec::new(),
            memory,
            depth: 0,
            id,
        }
    }

    /// Record a branch condition during execution
    pub fn record_branch(
        &mut self,
        state: &mut ConcolicState,
        location: &str,
        condition: PathCondition,
        concrete_result: bool,
    ) {
        // Record branch for coverage
        self.all_branches.insert(location.to_string());
        self.covered_branches
            .entry(location.to_string())
            .or_default()
            .insert(concrete_result);

        // Add to path condition
        let branch = BranchCondition {
            location: location.to_string(),
            condition,
            taken: concrete_result,
            depth: state.depth,
        };
        state.path_condition.push(branch);
        state.depth += 1;
    }

    /// Generate new states by negating branches
    pub fn generate_new_states(&mut self, state: &ConcolicState) {
        if state.depth >= self.config.max_depth {
            return;
        }

        // Try negating each branch from deepest to shallowest
        for i in (0..state.path_condition.len()).rev() {
            let branch = &state.path_condition[i];

            // Skip if both branches already covered
            if let Some(covered) = self.covered_branches.get(&branch.location) {
                if covered.len() >= 2 {
                    continue; // Both true and false already covered
                }
            }

            // Create path condition with negated branch
            let mut new_path: Vec<PathCondition> = state.path_condition[..i]
                .iter()
                .map(|b| b.as_constraint())
                .collect();
            new_path.push(branch.negate().as_constraint());

            // Check feasibility (placeholder - would call SMT solver)
            if self.is_path_feasible(&new_path) {
                // Generate new inputs
                if let Some(new_inputs) = self.solve_for_inputs(&new_path, &state.symbolic_inputs) {
                    let new_state = self.create_state_from_inputs(new_inputs, &new_path);
                    self.add_to_worklist(new_state);

                    // Record test input
                    self.test_inputs.push(TestInput {
                        values: state.concrete_inputs.clone(),
                        path_description: format!(
                            "Negate branch at {} (depth {})",
                            branch.location, i
                        ),
                        expected: TestExpectation::Normal,
                    });
                }
            } else {
                self.stats.paths_pruned += 1;
            }
        }
    }

    /// Check if path is feasible (calls solver)
    fn is_path_feasible(&mut self, _path: &[PathCondition]) -> bool {
        self.stats.solver_calls += 1;
        // Placeholder - would integrate with Z3Backend
        // For now, assume all paths are feasible
        self.stats.solver_sat += 1;
        true
    }

    /// Solve for inputs satisfying path condition
    fn solve_for_inputs(
        &mut self,
        _path: &[PathCondition],
        symbolic_inputs: &HashMap<String, SymbolicExpr>,
    ) -> Option<HashMap<String, ConcreteValue>> {
        // Placeholder - would integrate with Z3Backend to get model
        // For now, return default values
        let mut inputs = HashMap::new();
        for name in symbolic_inputs.keys() {
            inputs.insert(name.clone(), ConcreteValue::Int(0));
        }
        Some(inputs)
    }

    /// Create state from solved inputs
    fn create_state_from_inputs(
        &mut self,
        inputs: HashMap<String, ConcreteValue>,
        _path: &[PathCondition],
    ) -> ConcolicState {
        self.create_initial_state(inputs)
    }

    /// Add state to worklist based on strategy
    fn add_to_worklist(&mut self, state: ConcolicState) {
        match self.config.strategy {
            SearchStrategy::DFS => self.worklist.push_front(state),
            SearchStrategy::BFS => self.worklist.push_back(state),
            SearchStrategy::Random => {
                // Random insertion point
                let pos = if self.worklist.is_empty() {
                    0
                } else {
                    rand_simple() % self.worklist.len()
                };
                self.worklist.insert(pos, state);
            }
            SearchStrategy::CoverageGuided => {
                // Prioritize states that might cover new branches
                self.worklist.push_front(state);
            }
        }
    }

    /// Get next state to explore
    pub fn get_next_state(&mut self) -> Option<ConcolicState> {
        if self.stats.paths_explored >= self.config.max_paths {
            return None;
        }
        self.worklist.pop_front()
    }

    /// Report an error found during execution
    pub fn report_error(
        &mut self,
        state: &ConcolicState,
        kind: ErrorKind,
        location: &str,
        message: &str,
    ) {
        let path: Vec<String> = state
            .path_condition
            .iter()
            .map(|b| {
                format!(
                    "{}: {} = {}",
                    b.location,
                    format_condition(&b.condition),
                    b.taken
                )
            })
            .collect();

        self.errors.push(ErrorReport {
            kind,
            location: location.to_string(),
            message: message.to_string(),
            input: state.concrete_inputs.clone(),
            path,
        });

        // Generate test for this error
        self.test_inputs.push(TestInput {
            values: state.concrete_inputs.clone(),
            path_description: format!("Triggers {} at {}", format_error_kind(kind), location),
            expected: TestExpectation::Error(message.to_string()),
        });
    }

    /// Mark exploration of state as complete
    pub fn complete_exploration(&mut self, state: &ConcolicState) {
        self.stats.paths_explored += 1;
        self.stats.max_depth_reached = self.stats.max_depth_reached.max(state.depth);

        // Generate new states from this path
        self.generate_new_states(state);
    }

    /// Get exploration result
    pub fn get_result(&self) -> ExplorationResult {
        let total_branches = self.all_branches.len();
        let covered_both = self
            .covered_branches
            .values()
            .filter(|set| set.len() >= 2)
            .count();

        let branch_coverage = if total_branches > 0 {
            (covered_both as f64) / (total_branches as f64)
        } else {
            1.0
        };

        ExplorationResult {
            test_inputs: self.test_inputs.clone(),
            paths_explored: self.stats.paths_explored,
            paths_pruned: self.stats.paths_pruned,
            branch_coverage,
            errors_found: self.errors.clone(),
            stats: self.stats.clone(),
        }
    }

    /// Calculate current coverage
    pub fn get_coverage(&self) -> f64 {
        if self.all_branches.is_empty() {
            return 1.0;
        }

        let covered: usize = self.covered_branches.values().map(|set| set.len()).sum();
        let total = self.all_branches.len() * 2; // true + false for each branch

        (covered as f64) / (total as f64)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Helper Functions
// ═══════════════════════════════════════════════════════════════════════════

fn format_condition(cond: &PathCondition) -> String {
    match cond {
        PathCondition::True => "true".to_string(),
        PathCondition::False => "false".to_string(),
        PathCondition::Compare { lhs, op, rhs } => {
            format!("{:?} {:?} {:?}", lhs, op, rhs)
        }
        PathCondition::And(conds) => {
            let parts: Vec<_> = conds.iter().map(format_condition).collect();
            format!("({})", parts.join(" && "))
        }
        PathCondition::Or(conds) => {
            let parts: Vec<_> = conds.iter().map(format_condition).collect();
            format!("({})", parts.join(" || "))
        }
        PathCondition::Not(inner) => {
            format!("!{}", format_condition(inner))
        }
    }
}

fn format_error_kind(kind: ErrorKind) -> &'static str {
    match kind {
        ErrorKind::NullDereference => "NullDereference",
        ErrorKind::BufferOverflow => "BufferOverflow",
        ErrorKind::UseAfterFree => "UseAfterFree",
        ErrorKind::DivisionByZero => "DivisionByZero",
        ErrorKind::AssertionFailure => "AssertionFailure",
        ErrorKind::Custom => "Custom",
    }
}

/// Simple pseudo-random number (not cryptographically secure)
fn rand_simple() -> usize {
    use std::time::{SystemTime, UNIX_EPOCH};
    let nanos = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .subsec_nanos() as usize;
    nanos.wrapping_mul(1103515245).wrapping_add(12345)
}

// ═══════════════════════════════════════════════════════════════════════════
// Tests
// ═══════════════════════════════════════════════════════════════════════════

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_concolic_engine_creation() {
        let engine = ConcolicEngine::new(ConcolicConfig::default());
        assert_eq!(engine.stats.paths_explored, 0);
    }

    #[test]
    fn test_initial_state_creation() {
        let mut engine = ConcolicEngine::new(ConcolicConfig::default());
        let mut inputs = HashMap::new();
        inputs.insert("x".to_string(), ConcreteValue::Int(5));
        inputs.insert("y".to_string(), ConcreteValue::Int(10));

        let state = engine.create_initial_state(inputs);
        assert_eq!(state.concrete_inputs.len(), 2);
        assert_eq!(state.symbolic_inputs.len(), 2);
        assert_eq!(state.depth, 0);
    }

    #[test]
    fn test_branch_recording() {
        let mut engine = ConcolicEngine::new(ConcolicConfig::default());
        let mut inputs = HashMap::new();
        inputs.insert("x".to_string(), ConcreteValue::Int(5));

        let mut state = engine.create_initial_state(inputs);

        let condition = PathCondition::Compare {
            lhs: SymbolicExpr::symbol("x"),
            op: CompareOp::Gt,
            rhs: SymbolicExpr::concrete(0),
        };

        engine.record_branch(&mut state, "test:10", condition, true);

        assert_eq!(state.path_condition.len(), 1);
        assert_eq!(state.depth, 1);
        assert!(engine.all_branches.contains("test:10"));
    }

    #[test]
    fn test_coverage_tracking() {
        let mut engine = ConcolicEngine::new(ConcolicConfig::default());
        let mut inputs = HashMap::new();
        inputs.insert("x".to_string(), ConcreteValue::Int(5));

        let mut state = engine.create_initial_state(inputs.clone());

        let condition = PathCondition::Compare {
            lhs: SymbolicExpr::symbol("x"),
            op: CompareOp::Gt,
            rhs: SymbolicExpr::concrete(0),
        };

        // Record true branch
        engine.record_branch(&mut state, "test:10", condition.clone(), true);

        // Create new state and record false branch
        let mut state2 = engine.create_initial_state(inputs);
        engine.record_branch(&mut state2, "test:10", condition, false);

        // Both branches should be covered
        let covered = engine.covered_branches.get("test:10").unwrap();
        assert!(covered.contains(&true));
        assert!(covered.contains(&false));
    }

    #[test]
    fn test_error_reporting() {
        let mut engine = ConcolicEngine::new(ConcolicConfig::default());
        let mut inputs = HashMap::new();
        inputs.insert("x".to_string(), ConcreteValue::Int(0));

        let state = engine.create_initial_state(inputs);

        engine.report_error(
            &state,
            ErrorKind::DivisionByZero,
            "test:15",
            "Division by zero",
        );

        assert_eq!(engine.errors.len(), 1);
        assert_eq!(engine.errors[0].kind, ErrorKind::DivisionByZero);
    }

    #[test]
    fn test_search_strategies() {
        // DFS
        let mut engine = ConcolicEngine::new(ConcolicConfig {
            strategy: SearchStrategy::DFS,
            ..Default::default()
        });

        let s1 = engine.create_initial_state(HashMap::new());
        let s2 = engine.create_initial_state(HashMap::new());
        let s3 = engine.create_initial_state(HashMap::new());

        engine.add_to_worklist(s1);
        engine.add_to_worklist(s2);
        engine.add_to_worklist(s3);

        // DFS: Last added should be first out
        let first = engine.get_next_state().unwrap();
        assert_eq!(first.id, 2); // s3 was added last
    }

    #[test]
    fn test_branch_negation() {
        let branch = BranchCondition {
            location: "test:10".to_string(),
            condition: PathCondition::Compare {
                lhs: SymbolicExpr::symbol("x"),
                op: CompareOp::Gt,
                rhs: SymbolicExpr::concrete(0),
            },
            taken: true,
            depth: 0,
        };

        let negated = branch.negate();
        assert!(!negated.taken);
        assert_eq!(negated.location, branch.location);
    }

    #[test]
    fn test_exploration_result() {
        let mut engine = ConcolicEngine::new(ConcolicConfig::default());
        let inputs = HashMap::new();
        let state = engine.create_initial_state(inputs);

        engine.complete_exploration(&state);

        let result = engine.get_result();
        assert_eq!(result.paths_explored, 1);
    }

    #[test]
    fn test_concrete_value_conversions() {
        assert_eq!(ConcreteValue::Int(42).as_int(), Some(42));
        assert_eq!(ConcreteValue::Bool(true).as_int(), Some(1));
        assert_eq!(ConcreteValue::Bool(false).as_int(), Some(0));

        assert_eq!(ConcreteValue::Bool(true).as_bool(), Some(true));
        assert_eq!(ConcreteValue::Int(0).as_bool(), Some(false));
        assert_eq!(ConcreteValue::Int(1).as_bool(), Some(true));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Edge Cases (L11 SOTA Coverage)
    // ═══════════════════════════════════════════════════════════════════════

    #[test]
    fn test_edge_empty_inputs() {
        let config = ConcolicConfig::default();
        let mut engine = ConcolicEngine::new(config);

        // Create state with no inputs
        let state = engine.create_initial_state(HashMap::new());

        assert!(state.concrete_inputs.is_empty());
        assert!(state.path_condition.is_empty());
    }

    #[test]
    fn test_edge_max_depth_limit() {
        let mut config = ConcolicConfig::default();
        config.max_depth = 5;
        let mut engine = ConcolicEngine::new(config);

        let mut state = engine.create_initial_state(HashMap::new());

        // Record branches with proper PathCondition
        for i in 0..10 {
            let cond = PathCondition::Compare {
                lhs: crate::features::heap_analysis::SymbolicExpr::symbol(format!("x_{}", i)),
                op: crate::features::heap_analysis::CompareOp::Gt,
                rhs: crate::features::heap_analysis::SymbolicExpr::concrete(0),
            };
            engine.record_branch(&mut state, &format!("loc:{}", i), cond, true);
        }

        // Depth should be tracked
        assert!(state.depth <= 10);
    }

    #[test]
    fn test_edge_error_without_inputs() {
        let config = ConcolicConfig::default();
        let mut engine = ConcolicEngine::new(config);

        let state = engine.create_initial_state(HashMap::new());

        // Report error on empty state
        engine.report_error(&state, ErrorKind::BufferOverflow, "loc:1", "test error");

        let result = engine.get_result();
        assert_eq!(result.errors_found.len(), 1);
        assert!(result.errors_found[0].input.is_empty());
    }

    #[test]
    fn test_edge_negate_empty_path() {
        let config = ConcolicConfig::default();
        let mut engine = ConcolicEngine::new(config);

        let state = engine.create_initial_state(HashMap::new());

        // Generate states from empty path should not panic
        engine.generate_new_states(&state);

        // No assertion needed - just verifying no panic
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Extreme Cases (Stress Tests)
    // ═══════════════════════════════════════════════════════════════════════

    #[test]
    fn test_extreme_many_inputs() {
        let config = ConcolicConfig::default();
        let mut engine = ConcolicEngine::new(config);

        // Create state with 100 symbolic inputs
        let inputs: HashMap<String, ConcreteValue> = (0..100)
            .map(|i| (format!("input_{}", i), ConcreteValue::Int(i)))
            .collect();

        let state = engine.create_initial_state(inputs);
        assert_eq!(state.concrete_inputs.len(), 100);
    }

    #[test]
    fn test_extreme_deep_path_exploration() {
        let config = ConcolicConfig::default();
        let mut engine = ConcolicEngine::new(config);

        let mut state = engine.create_initial_state(HashMap::new());

        // Deep path with many branches
        for i in 0..100 {
            let cond = PathCondition::Compare {
                lhs: crate::features::heap_analysis::SymbolicExpr::symbol("x"),
                op: crate::features::heap_analysis::CompareOp::Gt,
                rhs: crate::features::heap_analysis::SymbolicExpr::concrete(i),
            };
            engine.record_branch(&mut state, &format!("loc:{}", i), cond, i % 2 == 0);
        }

        assert_eq!(state.path_condition.len(), 100);
    }

    #[test]
    fn test_extreme_many_errors() {
        let config = ConcolicConfig::default();
        let mut engine = ConcolicEngine::new(config);

        let state = engine.create_initial_state(HashMap::new());

        // Report many errors
        for i in 0..50 {
            engine.report_error(
                &state,
                ErrorKind::NullDereference,
                &format!("loc:{}", i),
                &format!("error {}", i),
            );
        }

        let result = engine.get_result();
        assert_eq!(result.errors_found.len(), 50);
    }

    #[test]
    fn test_extreme_all_search_strategies() {
        use SearchStrategy::*;

        let strategies = vec![DFS, BFS, Random, CoverageGuided];

        for strategy in strategies {
            let mut config = ConcolicConfig::default();
            config.strategy = strategy;

            let mut engine = ConcolicEngine::new(config);
            let mut state = engine.create_initial_state(HashMap::new());

            let cond = PathCondition::True;
            engine.record_branch(&mut state, "loc:1", cond, true);
            engine.complete_exploration(&state);

            // All strategies should complete without error
            let result = engine.get_result();
            assert_eq!(result.paths_explored, 1);
        }
    }
}
