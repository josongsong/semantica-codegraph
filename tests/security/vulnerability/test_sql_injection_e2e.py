"""
E2E 테스트: SQL Injection Detection (통합 버전)

실제 Python 코드 → IR → PDG → Taint Analysis → Vulnerability Report

기존 시스템 활용:
- TaintSlicer (PDG 기반)
- taint_rules (검증된 규칙)

새로운 가치:
- Vulnerability model (CWE, Severity, Evidence)
- QueryEngine (orchestration)
- ReportGenerator (3 formats)
"""

from pathlib import Path

import pytest

from src.contexts.code_foundation.infrastructure.ir.models.document import IRDocument
from src.contexts.security_analysis.application.report_generator import (
    SecurityReportGenerator,
)
from src.contexts.security_analysis.domain.services.query_engine import (
    QueryConfig,
    QueryEngine,
)
from src.contexts.security_analysis.infrastructure.queries.injection.sql_injection_integrated import (
    SQLInjectionQuery,
)

# Test code samples
VULNERABLE_CODE_1 = '''
import sqlite3

def get_user(user_id):
    """Vulnerable: String interpolation"""
    conn = sqlite3.connect('db.sqlite')
    cursor = conn.cursor()
    
    # VULNERABLE!
    query = f"SELECT * FROM users WHERE id={user_id}"
    cursor.execute(query)
    
    return cursor.fetchone()
'''

VULNERABLE_CODE_2 = '''
from django.db import connection

def search_products(search_term):
    """Vulnerable: String concatenation"""
    with connection.cursor() as cursor:
        # VULNERABLE!
        sql = "SELECT * FROM products WHERE name LIKE '%" + search_term + "%'"
        cursor.execute(sql)
        return cursor.fetchall()
'''

SAFE_CODE_1 = '''
import sqlite3

def get_user_safe(user_id):
    """Safe: Parameterized query"""
    conn = sqlite3.connect('db.sqlite')
    cursor = conn.cursor()
    
    # SAFE!
    cursor.execute("SELECT * FROM users WHERE id=?", [user_id])
    
    return cursor.fetchone()
'''

SAFE_CODE_2 = '''
from django.db import models

class User(models.Model):
    name = models.CharField(max_length=100)

def get_user_orm(user_id):
    """Safe: ORM"""
    # SAFE!
    return User.objects.filter(id=user_id).first()
'''


class TestSQLInjectionE2E:
    """E2E 테스트: SQL Injection 탐지"""

    @pytest.fixture
    def sql_query(self):
        """SQLInjectionQuery fixture"""
        return SQLInjectionQuery()

    @pytest.fixture
    def query_engine(self):
        """QueryEngine fixture"""
        return QueryEngine()

    @pytest.fixture
    def report_generator(self):
        """ReportGenerator fixture"""
        return SecurityReportGenerator()

    def test_query_initialization(self, sql_query):
        """Test: SQL Injection Query 초기화"""
        assert sql_query.CWE_ID.value == "CWE-89"
        assert sql_query.SEVERITY.value == "critical"
        assert len(sql_query.sql_sources) > 0  # 기존 PYTHON_CORE_SOURCES
        assert len(sql_query.sql_sinks) > 0  # 기존 PYTHON_CORE_SINKS
        assert len(sql_query.sql_sanitizers) > 0  # 기존 PYTHON_CORE_SANITIZERS

    @pytest.mark.skip("IR document 생성 필요")
    def test_detect_vulnerable_code_1(self, sql_query):
        """
        Test: Vulnerable Code 탐지 (f-string interpolation)

        Expected:
        - 1개의 SQL Injection 취약점 발견
        - Source: user_id (parameter)
        - Sink: cursor.execute()
        """
        # TODO: IR document 생성
        # 1. Parse VULNERABLE_CODE_1
        # 2. Generate IR
        # 3. Build PDG
        # 4. Run TaintSlicer

        ir_doc = self._create_ir_document(VULNERABLE_CODE_1, "vulnerable_1.py")

        # Run analysis
        vulnerabilities = sql_query.analyze(ir_doc)

        # Assertions
        assert len(vulnerabilities) == 1

        vuln = vulnerabilities[0]
        assert vuln.cwe.value == "CWE-89"
        assert vuln.severity.value == "critical"
        assert "user_id" in vuln.description or "user_id" in str(vuln.taint_path)
        assert len(vuln.taint_path) >= 2  # Source → Sink
        assert vuln.confidence > 0.7

    @pytest.mark.skip("IR document 생성 필요")
    def test_detect_vulnerable_code_2(self, sql_query):
        """
        Test: Vulnerable Code 탐지 (string concatenation)

        Expected:
        - 1개의 SQL Injection 취약점 발견
        - Source: search_term (parameter)
        - Sink: cursor.execute()
        """
        ir_doc = self._create_ir_document(VULNERABLE_CODE_2, "vulnerable_2.py")

        vulnerabilities = sql_query.analyze(ir_doc)

        assert len(vulnerabilities) == 1

        vuln = vulnerabilities[0]
        assert vuln.cwe.value == "CWE-89"
        assert "search_term" in vuln.description or "search_term" in str(vuln.taint_path)

    @pytest.mark.skip("IR document 생성 필요")
    def test_safe_code_1(self, sql_query):
        """
        Test: Safe Code (parameterized query)

        Expected:
        - 취약점 없음 (또는 is_sanitized=True)
        """
        ir_doc = self._create_ir_document(SAFE_CODE_1, "safe_1.py")

        vulnerabilities = sql_query.analyze(ir_doc)

        # Sanitizer 탐지로 인해 취약점 없거나, sanitized로 표시됨
        assert len(vulnerabilities) == 0 or all(v.confidence < 0.5 for v in vulnerabilities)

    @pytest.mark.skip("IR document 생성 필요")
    def test_safe_code_2(self, sql_query):
        """
        Test: Safe Code (ORM)

        Expected:
        - 취약점 없음
        """
        ir_doc = self._create_ir_document(SAFE_CODE_2, "safe_2.py")

        vulnerabilities = sql_query.analyze(ir_doc)

        assert len(vulnerabilities) == 0

    @pytest.mark.skip("통합 테스트 준비 필요")
    def test_query_engine_integration(self, query_engine):
        """
        Test: QueryEngine으로 실행

        Expected:
        - SQLInjectionQuery 자동 등록
        - 여러 파일 동시 분석
        - 결과 집계
        """
        # TODO: Multiple IR documents
        ir_docs = []

        config = QueryConfig(
            severity_threshold="medium",
            max_findings=100,
        )

        result = query_engine.run(ir_docs, config)

        assert result.total_scanned > 0
        assert result.total_findings >= 0

    @pytest.mark.skip("Report 생성 테스트 준비 필요")
    def test_report_generation(self, report_generator):
        """
        Test: Report 생성 (Text, JSON, Markdown)

        Expected:
        - 3가지 형식 모두 생성
        - 취약점 상세 정보 포함
        - Summary 포함
        """
        # TODO: Create ScanResult with vulnerabilities
        from src.contexts.security_analysis.domain.models.vulnerability import ScanResult

        scan_result = ScanResult(
            vulnerabilities=[],
            total_scanned=1,
            total_findings=0,
        )

        # Text report
        text_report = report_generator.generate_text(scan_result)
        assert len(text_report) > 0

        # JSON report
        json_report = report_generator.generate_json(scan_result)
        assert "vulnerabilities" in json_report

        # Markdown report
        md_report = report_generator.generate_markdown(scan_result)
        assert "##" in md_report  # Markdown headers

    # =========================================================================
    # Helper methods
    # =========================================================================

    def _create_ir_document(self, code: str, filename: str) -> IRDocument:
        """
        Create IR document from code

        TODO: Week 3-4에서 실제 구현
        - Parse code (tree-sitter)
        - Generate IR
        - Build PDG
        - Build CFG

        Args:
            code: Python code string
            filename: File name

        Returns:
            IRDocument with PDG
        """
        # Placeholder
        return IRDocument(
            repo_id="test",
            snapshot_id="test",
            schema_version="2.1",
        )


class TestPerformance:
    """Performance 측정 테스트"""

    @pytest.mark.skip("Performance 벤치마크 준비 필요")
    def test_large_codebase_performance(self):
        """
        Test: 대규모 코드베이스 성능

        Target:
        - 1000+ files: < 10 minutes
        - 100 files: < 1 minute

        Optimizations:
        - FunctionSummaryCache (5-10x speedup)
        - ImprovedSanitizerDetector (FP -30%)
        - PathSensitiveTaintAnalyzer (Meet-Over-Paths)
        """
        pass

    @pytest.mark.skip("메모리 프로파일링 필요")
    def test_memory_usage(self):
        """
        Test: 메모리 사용량

        Target:
        - < 1GB for 1000 files
        - No memory leak
        """
        pass


# =========================================================================
# Integration Test Suite
# =========================================================================


@pytest.mark.integration
class TestFullPipeline:
    """전체 파이프라인 통합 테스트"""

    @pytest.mark.skip("전체 파이프라인 통합 필요")
    def test_end_to_end_pipeline(self):
        """
        Test: 전체 파이프라인

        Flow:
        1. Python code → IR document
        2. IR → PDG (기존 PDGBuilder)
        3. PDG → TaintSlicer (기존)
        4. TaintSliceResult → Vulnerability (새로운)
        5. Vulnerability → Report (새로운)

        Expected:
        - 모든 단계 정상 동작
        - 결과 정확성
        """
        # TODO: Implement full pipeline
        pass
