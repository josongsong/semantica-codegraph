"""
E2E Test: SQL Injection Detection V2 (SOTA Version)

실행 가능한 테스트!

Changes from v1:
- ✅ TaintAnalyzerAdapter 사용
- ✅ 올바른 인터페이스
- ✅ 실제 실행 가능
"""

import pytest

from src.contexts.code_foundation.infrastructure.analyzers.taint_rules.base import (
    VulnerabilityType,
)
from src.contexts.code_foundation.infrastructure.analyzers.taint_rules.sanitizers.python_core import (
    PYTHON_CORE_SANITIZERS,
)
from src.contexts.code_foundation.infrastructure.analyzers.taint_rules.sinks.python_core import (
    PYTHON_CORE_SINKS,
)
from src.contexts.code_foundation.infrastructure.analyzers.taint_rules.sources.python_core import (
    PYTHON_CORE_SOURCES,
)
from src.contexts.security_analysis.infrastructure.adapters.taint_analyzer_adapter import (
    TaintAnalyzerAdapter,
)
from src.contexts.security_analysis.infrastructure.queries.injection.sql_injection_v2 import (
    SQLInjectionQueryV2,
)


class TestSQLInjectionV2:
    """SQL Injection Query V2 테스트"""

    def test_initialization(self):
        """Test: 초기화"""
        query = SQLInjectionQueryV2()

        assert query.CWE_ID.value == "CWE-89"
        assert query.SEVERITY.value == "critical"
        assert len(query.sql_sources) > 0
        assert len(query.sql_sinks) > 0
        assert len(query.sql_sanitizers) > 0
        assert query.adapter is not None

    def test_adapter_initialization(self):
        """Test: TaintAnalyzerAdapter 초기화"""
        # Filter SQL sinks
        sql_sinks = [s for s in PYTHON_CORE_SINKS if s.vuln_type == VulnerabilityType.SQL_INJECTION]

        sql_sanitizers = [s for s in PYTHON_CORE_SANITIZERS if VulnerabilityType.SQL_INJECTION in s.sanitizes]

        adapter = TaintAnalyzerAdapter(
            source_rules=PYTHON_CORE_SOURCES,
            sink_rules=sql_sinks,
            sanitizer_rules=sql_sanitizers,
        )

        # Check conversions
        assert len(adapter.taint_analyzer.sources) > 0
        assert len(adapter.taint_analyzer.sinks) > 0
        assert len(adapter.taint_analyzer.sanitizers) > 0

        # Check types
        from src.contexts.code_foundation.infrastructure.analyzers.taint_analyzer import (
            TaintSink,
            TaintSource,
        )

        for source in adapter.taint_analyzer.sources.values():
            assert isinstance(source, TaintSource)

        for sink in adapter.taint_analyzer.sinks.values():
            assert isinstance(sink, TaintSink)

    @pytest.mark.skip("IR document 생성 필요")
    def test_analyze_with_ir_document(self):
        """Test: IRDocument 분석"""
        query = SQLInjectionQueryV2()

        # TODO: Create test IR document
        # ir_doc = create_test_ir_document()

        # vulnerabilities = query.analyze(ir_doc)
        # assert isinstance(vulnerabilities, list)

    def test_confidence_calculation(self):
        """Test: Confidence 계산"""
        query = SQLInjectionQueryV2()

        from src.contexts.code_foundation.infrastructure.analyzers.taint_analyzer import (
            TaintPath,
        )

        # Short path (high confidence)
        short_path = TaintPath(
            source="request.get",
            sink="execute",
            path=["request.get", "execute"],
            is_sanitized=False,
        )

        confidence = query._calculate_confidence(short_path)
        assert confidence >= 0.8

        # Long path (lower confidence)
        long_path = TaintPath(
            source="request.get",
            sink="execute",
            path=["request.get", "func1", "func2", "func3", "func4", "execute"],
            is_sanitized=False,
        )

        confidence = query._calculate_confidence(long_path)
        assert confidence < 0.8

    def test_fp_risk_assessment(self):
        """Test: False Positive Risk 평가"""
        query = SQLInjectionQueryV2()

        from src.contexts.code_foundation.infrastructure.analyzers.taint_analyzer import (
            TaintPath,
        )

        # Short path (low FP risk)
        short_path = TaintPath(
            source="request.get",
            sink="execute",
            path=["request.get", "execute"],
            is_sanitized=False,
        )

        risk = query._assess_fp_risk(short_path)
        assert risk == "low"

        # Long path (high FP risk)
        long_path = TaintPath(
            source="request.get",
            sink="execute",
            path=["request.get"] + [f"func{i}" for i in range(10)] + ["execute"],
            is_sanitized=False,
        )

        risk = query._assess_fp_risk(long_path)
        assert risk == "high"


class TestTaintAnalyzerAdapter:
    """TaintAnalyzerAdapter 단위 테스트"""

    def test_source_conversion(self):
        """Test: SourceRule → TaintSource 변환"""
        adapter = TaintAnalyzerAdapter(
            source_rules=PYTHON_CORE_SOURCES[:5],  # First 5
            sink_rules=[],
            sanitizer_rules=[],
        )

        assert len(adapter.taint_analyzer.sources) == 5

        # Check type
        from src.contexts.code_foundation.infrastructure.analyzers.taint_analyzer import (
            TaintSource,
        )

        for source in adapter.taint_analyzer.sources.values():
            assert isinstance(source, TaintSource)
            assert source.function_name
            assert source.description

    def test_sink_conversion(self):
        """Test: SinkRule → TaintSink 변환"""
        sql_sinks = [s for s in PYTHON_CORE_SINKS if s.vuln_type == VulnerabilityType.SQL_INJECTION]

        adapter = TaintAnalyzerAdapter(
            source_rules=[],
            sink_rules=sql_sinks,
            sanitizer_rules=[],
        )

        assert len(adapter.taint_analyzer.sinks) > 0

        # Check type
        from src.contexts.code_foundation.infrastructure.analyzers.taint_analyzer import (
            TaintSink,
        )

        for sink in adapter.taint_analyzer.sinks.values():
            assert isinstance(sink, TaintSink)
            assert sink.function_name
            assert sink.description
            assert sink.severity in ["high", "medium", "low", "critical"]

    def test_sanitizer_conversion(self):
        """Test: SanitizerRule → set[str] 변환"""
        sql_sanitizers = [s for s in PYTHON_CORE_SANITIZERS if VulnerabilityType.SQL_INJECTION in s.sanitizes]

        adapter = TaintAnalyzerAdapter(
            source_rules=[],
            sink_rules=[],
            sanitizer_rules=sql_sanitizers,
        )

        assert len(adapter.taint_analyzer.sanitizers) > 0

        # Check type
        assert isinstance(adapter.taint_analyzer.sanitizers, set)

        for sanitizer in adapter.taint_analyzer.sanitizers:
            assert isinstance(sanitizer, str)

    @pytest.mark.skip("IR document 생성 필요")
    def test_graph_extraction(self):
        """Test: IRDocument → call_graph, node_map 변환"""
        # TODO: Create test IR document with nodes and edges
        pass


class TestIntegration:
    """통합 테스트"""

    def test_end_to_end_flow(self):
        """Test: 전체 플로우 (without IR)"""
        # 1. Create query
        query = SQLInjectionQueryV2()

        # 2. Check initialization
        assert query.adapter is not None
        assert query.adapter.taint_analyzer is not None

        # 3. Check taint rules loaded
        assert len(query.sql_sources) > 0
        assert len(query.sql_sinks) > 0

        # 4. Verify SQL sinks are correct
        for sink in query.sql_sinks:
            assert sink.vuln_type == VulnerabilityType.SQL_INJECTION
