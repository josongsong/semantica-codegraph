SOTA-Level Coding Agent Architecture v3.0

목표: Graph 기반 CodeGraph Engine + Multi-Index Retrieval + Self-Reflection + Decision Memory를 결합한 SOTA급 코딩 에이전트
차별화 축: 깊은 정적 분석, 구조화된 Self-Reflection, 조직 단위 학습, Explainable Reasoning

1. 상위 구조 개요
1-1. 전체 모듈 맵
[User Query / Intent]
        │
        ▼
[1. CodeGraph Engine]        (AST → IR → CFG/DFG → Graph → Chunk → RepoMap → Index)
        │
        ▼
[2. Retrieval & Context]     (Intent Router → Multi-Index Fusion → Advanced Context Builder)
        │
        ▼
[3. Agent Orchestration]     (Planner → Tool Router → Executor → Reflection Pipeline → Human Gate)
        │
        ▼
[4. Quality & Intelligence]  (Diagnostics/LSP, Arch Rules, Proactive Scanner, Decision Memory, Explainable Engine)
        │
        ▼
[5. Cross-Cutting Systems]   (Incremental Execution, Context Orchestration, Evaluation/Policy, Global Knowledge/Evidence Store)

1-2. 구현 Phase 로드맵 (요약)

Phase 1: CodeGraph 최소 엔진 + Lexical/Vector Index + 기본 Tool Layer

Phase 2: Planner/Orchestration + 기본 Reflection + Diagnostics + Eval 파이프라인

Phase 3: CFG/DFG, RepoMap, Incremental Execution, Architecture Rule, Advanced Context

Phase 4: Proactive Scanner, Decision Memory, Explainable Engine, Global Knowledge 통합

Phase 5: 언어 확장, Multi-repo, 팀/엔터프라이즈 기능

2. Module 1. CodeGraph Engine (Core Pipeline)
2-1. Parsing & AST

Tree-sitter Registry

Tier-1: python / typescript / go / java (Full: IR+CFG+DFG)

Tier-2: rust / c / cpp / kotlin (IR 중심)

Tier-3: ruby / php / shell / lua (AST-only)

Normalized AST

언어별 AST → 공통 NormalizedNode(kind, children, span, attrs)

AST Traversal API

walk(node), find_by_type(types), ancestors(node)

Position Mapper

byte offset ↔ line/col, UTF-8/16 변환, OffsetIndex 캐시

2-2. IR (Intermediate Representation)

IRNode

kind: FILE / CLASS / FUNCTION / VARIABLE / IMPORT

필드: fqn, signature, span, children, modifiers

IRType

builtin/local/generic/inferred, union/intersection, optional

IRSignature

param_types, return_type, decorator_hash, generic_params

Basic Edges

IMPORTS, CONTAINS, CALLS, INSTANTIATES, REFERENCES

2-3. Control/Data Flow

Basic Blocks & CFG

edge: SEQ / BRANCH_TRUE / BRANCH_FALSE / LOOP_BACK / EXCEPTION / RETURN

DFG

READS, WRITES, reaching definitions, liveness

SSA/Taint Hooks

SSA 버전 suffix, source/sink/propagate 훅으로 확장 가능

2-4. Graph Construction

GraphNode

Symbol / Type / Signature / CFG/DFG 노드 통합 view

GraphEdge

CONTAINS, CALLS, IMPORTS, INHERITS, IMPLEMENTS, READS, WRITES,
TYPE_OF, RETURNS, PARAM_OF, OVERRIDES, DECORATES

Normalizer / Neighbor Map

FQN 기준 dedupe, partial merge

neighbors(node, edge_type, direction) API

2-5. Chunk Layer

6단 Chunk 계층

REPO → MODULE → FILE → CLASS → FUNCTION → BLOCK

Stable Chunk ID

repo::module::file::class::func::block_n

Chunk ↔ Graph/IR 매핑

chunk.graph_nodes[], graph_node.chunk_id

Incremental Chunking / Span Drift / Rename Detection

변경 파일 diff → 영향 span → 해당 chunk만 재생성

signature+content 기반 rename 감지

2-6. RepoMap Layer

RepoMapNode 트리

name, kind, path, summary, importance_score

Ranking

PageRank + recency + edit_frequency + test_coverage → HybridRank

Summary / Tree API

LLM 기반 요약, get_subtree(path), get_hotspots(), get_context_window(node)

2-7. Multi-Index Layer

Lexical: Zoekt/Meilisearch (키워드/regex/파일 필터)

Vector: Qdrant + Code Embeddings (cosine)

Symbol Index: FQN 중심 B-Tree/키-값 조회

Fuzzy Index: 편집거리 ≤ 2

Domain Meta Index: ADR/API spec/Design Doc 검색

Runtime Index: trace/hot path/coverage 메타

3. Module 2. Retrieval & Context
3-1. Intent Router

Intent Classifier

NAVIGATE / SEARCH / UNDERSTAND / FIX / GENERATE

Query Analyzer

엔티티 추출, 동의어/alias 확장, 언어/프레임워크 감지

Strategy Selector

Intent → index weight 매핑 (lexical/symbol/vector/graph/domain/runtime)

3-2. Multi-Index Fusion & Rerank

병렬 인덱스 조회 (asyncio.gather, per-index timeout)

Score Normalization (z-score, min-max, reciprocal rank 등)

Reciprocal Rank Fusion (RRF) 기반 1차 통합

Cross-Encoder Reranker (code 전용 ranker 모델)

Graph Expansion

top-K 결과 기준 1~2 hop callers/callees/dependencies 확장

3-3. Context Builder (Base)

Budget Allocator

예: 100k 토큰 기준 system/repo_map/retrieved/graph/history/buffer 비율

Priority Scorer

relevance × recency × depth × role (definition vs usage vs tests)

Truncation Engine

signature/summary는 유지, body는 의미 단위로 절단

Multi-turn Carry-over

이전 turn은 summary + delta만 carry

3-4. Advanced Context Layer

Semantic Subgraph

ego-graph, k-hop, edge-type filter 기반 부분 그래프 추출

Change Impact View

변경 심볼 → callers/DFG 기반 영향 파악 → 관련 테스트/파일 뽑기

Runtime Evidence

error trace / hot functions / slow endpoints

Architecture Constraints Overlay

domain/layer rules를 context에 함께 제공

Coverage-aware Selection

영향 받는 코드 중 coverage 낮은 영역 우선 노출

4. Module 3. Agent Orchestration
4-1. Tool Contract & Workspace/Snapshot
4-1-1. ToolRequest / ToolResponse (요약 버전)
interface ToolRequest<T> {
  tool_name: string;
  params: T;
  request_id: string;
  context?: {
    session_id: string;
    workspace_id?: string;
    snapshot_id?: string;
    parent_request_id?: string;
    intent?: string;               // "navigate" | "fix" ...
    priority?: "low" | "normal" | "high";
    budget_tokens?: number;
    freshness?: {
      require_fresh?: boolean;
      max_staleness_ms?: number;
    };
  };
}

interface ToolResponse<T> {
  success: boolean;
  data?: T;
  error?: ToolError;
  metadata: {
    execution_time_ms: number;
    tokens_used?: number;
    truncated: boolean;
    confidence?: number;
    cache_hit: boolean;
    side_effect?: "read" | "write" | "network" | "cpu_heavy";
    read_paths?: string[];
    written_paths?: string[];
    risk_level?: "low" | "medium" | "high";
  };
  suggestions?: SuggestedAction[];
}


모든 Tool은 공통 contract + 개별 params/result 스펙을 가짐

workspace_id + snapshot_id 단위로 일관된 view 제공 (에이전트는 항상 가상 워크스페이스 위에서 작업)

4-1-2. Tool 메타데이터

Tool 정의 시 공통 메타

preconditions[] (예: syntax_ok 필요)

postconditions[] (예: tests_passed 권장)

side_effect (read/write/network/cpu)

cost_estimate (tokens/time)

risk_level (“apply_patch”, “git_commit” 등 high)

4-2. Tool Layer (핵심 툴 + 의존성)
4-2-1. 주요 툴

Discovery/Reading

open_file, code_search, symbol_search, graph_neighbors

Mutation

propose_patch, apply_patch, create_file, delete_file, rename_symbol

Validation

syntax_check, type_check, lint_run, run_tests(scope)

History/Workspace

git_diff, git_blame, git_log, git_commit, git_reset,

create_workspace, commit_workspace, discard_workspace

4-2-2. Tool Dependency 예시

apply_patch

requires: syntax_check.pass

recommends: type_check.pass, lint_run

git_commit

recommends: run_tests(scope="affected").pass

4-3. Plan Schema & Planner

Plan 표현: DAG 기반 JSON

필드

steps[]: id, tool, params, deps, optional 조건

rollback_on_fail[]: 특정 step 실패 시 롤백 포인트

success_criteria: “s6:pass” 같은 조건

Planner 역할

Task → Plan

task 타입(bug_fix/refactor/feature_add)에 따른 템플릿 기반 분해

Plan Validation

cycle 검출, missing precondition, unreachable step 탐지

Replan

Failure / Reflection 피드백 기반 Plan 수정

4-4. LangGraph Orchestration Flow

주요 노드

Planner → Tool Router → Tool Executor → Reviewer → Reflection → (Human Gate)

상태 흐름

Plan 생성 → step 단위 실행 → 각 step 결과 Reviewer 검증 → 실패 시 Reflection → 재시도/재계획/에스컬레이션

5. Module 3 확장: Self-Reflection 3단계
5-1. Pre-flight Checker (실행 전)

입력: Task, Plan, Context

체크 항목

Plan 구조 유효성 (필수 단계, 순서, 툴 파라미터, success_criteria)

Context 충분성 (참조 파일/심볼/콜체인/테스트 존재 여부)

Feasibility (예상 토큰/시간, 잠재적 cycle, 병렬화 가능성)

Risk Assessment (수정 파일 수, Public API 변경, 테스트 커버리지, 복잡도)

결과

approved: boolean, 각 check 점수, blocking_issues[], suggestions[]

행동

approved=false → Planner에게 “Replan with constraints” 요청

5-2. In-flight Monitor (실행 중)

매 스텝 종료 후 StepRecord 기준 상태 업데이트

탐지하는 Anomaly 유형

LOOP_DETECTED (같은 plan/tool+params 반복)

NO_PROGRESS (최근 N 스텝에서 컨텍스트/결과 변화 없음)

EXCESSIVE_TOOL_CALLS (툴별/전체 call 수 초과)

REPEATED_ERRORS (동일 error code 반복)

CONTEXT_EXPLOSION (컨텍스트 토큰 급증/한계 근접)

HALLUCINATION_SUSPECTED (존재하지 않는 파일/심볼 참조, 툴 결과와 결론 불일치)

DRIFT_FROM_PLAN (원래 plan 대비 drift score↑)

MonitorDecision

continue / adjust_strategy / pause_and_reflect / abort

5-3. Post-flight Reviewer (결과 평가)

Dimensions

correctness / completeness / safety / style / efficiency

각 dimension: score(0–1), weight, checks[], summary

검증 항목 예시

correctness: syntax/type/test/semantic-consistency/problem-solved

completeness: plan 단계 수행률, 요구사항 충족, 영향 파일 처리 여부, 테스트 업데이트 여부

safety: breaking changes, unintended changes, 삭제 코드, security issue, rollback 가능성

style: lint, style consistency, naming, complexity

efficiency: token/step/tool-call/time 효율

Decision

approve, approve_with_warnings, request_changes, reject, escalate_to_human

5-4. Strategy Adapter (전략 전환)

입력: ReviewResult, ExecutionHistory

Output: StrategyAdjustment

type: retry / replan / escalate / abort

modifications: constraint 추가, 전략 변경, context reset 등

로직 예시

같은 유형 이슈로 2회 이상 실패 → replan + “이전 접근 피하기” constraint

safety 점수 낮고 blocker 없으면 → escalate_to_human

3회 이상 reject → abort + 상세 로그 기록

6. Module 4. Quality & Intelligence
6-1. Diagnostics & LSP Layer

Syntax/Type/Diagnostics 통합

tree-sitter, pyright/mypy/tsc, ruff, 언어별 LSP

Error Mapper

error code → 카테고리/제안 fix 매핑

Agent는 해당 Diagnostics를 tool로 호출하고 결과를 Reviewer/Reflection에 연결

6-2. Architecture Rule Engine

Rule DSL

layer, domain, module 간 접근 규칙 정의

Violation Detector

import/dependency graph 기반 위반 탐지

Enforcement

warn / block / auto_fix 모드 (예: forbidden dependency 감지 시 patch 제안)

6-3. Proactive Quality Scanner

Anti-pattern / Performance / Security / Coverage gap 탐색

Priority Ranker

severity × frequency × impact 기반 개선 우선순위 제공

Agent는 “Proactive Fix” 시나리오에서 이 스캐너를 사용

6-4. Decision Memory (조직 학습)

Patch VectorStore

patch context + patch diff + outcome(success/reverted/modified) + review comment

Success Pattern Mining

유사 상황/패턴 클러스터링, 템플릿 추출

Similar Case Retrieval

새로운 Task 시 과거 유사 사례 서빙 → Planner/Agent가 전략 선택에 활용

Org Preference Learning

naming, 레이어링, 예외 처리 패턴 등 조직 스타일 모델링

6-5. Explainable Decision Engine + Evidence Store

Evidence Store (공통 타입)

코드 조각, 그래프 이웃, ADR/API spec 조각, 테스트/런타임, 이슈/리뷰 코멘트 등

Explainable Engine

decision, confidence, rationale[], evidence[], alternatives[], tradeoffs, uncertainty_factors[]

사용 지점

Human Gate에서 “왜 이렇게 바꿨는지?”에 대한 답변

Reviewer/Reflection 로그에도 동일 구조를 저장

7. Module 5. Cross-Cutting Systems
7-1. Incremental Execution Engine

Change Detector

git diff, file watcher, hash 기반 변경 탐지

Incremental Parsing/IR/Graph/Index/Chunk

변경된 부분만 재구성

Snapshot Manager

snapshot_id 단위 버전 관리, 오래된 snapshot GC

모든 ToolRequest는 snapshot_id 기반으로 일관된 view 사용

7-2. Context Orchestration (Cross-cutting)

전 모듈 공통 컨텍스트 정책 레이어

budget 할당, truncation 전략, multi-turn carry 정책

Retrieval, Reflection, Explainable Engine이 같은 정책을 참조

주요 정책 파라미터

max_context_tokens, 영역별 비율, overflow 처리 전략(summarize/drop/link)

7-3. Evaluation & Policy Tuning

Evaluation

SWE-Bench / HumanEval / 자체 regression suite 연동

메트릭: pass@1, resolve_rate, avg_tool_calls, avg_reflection_count, context_utilization, latency 지표 등

Policy Tuning / Experiment Manager

실험 단위

retrieval weight, context budget, reflection thresholds, max_tool_calls, tool timeout 등

A/B나 bandit 기반 variant 조정

Telemetry 기반 regression 감지 및 rollback

7-4. Global Knowledge Integration

ADR Ingester, API Spec Loader, Runtime Collector

모두 Evidence Store/Domain Meta Index로 들어감

Pattern Linker

특정 Repo/Task ↔ 조직/플랫폼 지식 연결

Agent는 항상 “코드 + 조직 지식 + 런타임”을 한꺼번에 grounding

8. 최종 요약 (이 아키텍처의 포지셔닝)

CodeGraph Engine

AST→IR→CFG/DFG→Graph→Chunk→RepoMap→Multi-Index까지 깊은 정적 분석

Retrieval & Context

Multi-Index Fusion + Graph Expansion + Budget 기반 Advanced Context

Agent Orchestration

Tool Contract/Workspace/Snapshot + LangGraph 기반 Planner/Executor +
Pre-flight/In-flight/Post-flight/StrategyAdapter로 이어지는 Self-Reflection 파이프라인

Quality & Intelligence

Diagnostics/LSP, Architecture Rule, Proactive Scanner, Decision Memory, Explainable Engine

Cross-Cutting

Incremental Execution, Context Orchestration, Evaluation & Policy Tuning, Evidence 기반 Global Knowledge 통합

이 문서를 “SOTA-Level Coding Agent Architecture v3.0 (최종 상위 스펙)” 기준으로 두고,
실제 구현 문서는 각 모듈별로 specification/* 하위에 쪼개서 내려가면 될 것 같음.