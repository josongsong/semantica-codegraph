# SOTA CodeGraph Engine – Implementation Plan (v1)

본 문서는 아래 작업계획을 **"구현 순서" 관점으로 재구성한 실행 플랜**임.

* 대상: Semantica CodeGraph v4 엔진 전체
* 관점: 단계별(Phase) 구현, 각 Phase 내 세부 Task 분리
* 목표: Parsing → IR → CFG/DFG → Graph → Chunk → RepoMap → Index → Retriever → Incremental 까지

---

## Phase 0. Skeleton & Contracts

### 0-1. 패키지 구조 고정

* 위치: `src/foundation/{parsing,ir,cfg,dfg,graph,chunk}`
* 위치: `src/{repomap,index,retriever}`

### 0-2. 공통 도메인/포트 정의

* `src/foundation/ir/models.py` – IRNode/IRType/IRSignature/IRDocument
* `src/foundation/graph/models.py` – GraphNode/GraphEdge/GraphDocument
* `src/foundation/chunk/models.py` – Chunk, ChunkToGraph, ChunkToIR 등
* 타입/인터페이스만 정의 (구현은 이후 Phase에서)

---

## Phase 1. Parsing Layer (TS 기반 파서)

### 1-1. Tree-sitter Registry

* 파일: `src/foundation/parsing/registry.py`
* 역할:

  * python / ts / js 에 대한 tree-sitter 언어 핸들러 등록
  * `get_parser(language: str) -> TreeSitterParser` 인터페이스 제공

### 1-2. Per-language Parser Adapter

* 파일: `src/foundation/parsing/adapters/{python,typescript,js}.py`
* 역할:

  * SourceFile(path, content) → TS AST
  * AST error node 감지 및 tolerant mode 처리

### 1-3. 위치 매핑

* 파일: `src/foundation/parsing/position.py`
* 기능:

  * byte offset → (line, column)
  * line/column → byte offset

### 1-4. AST Normalization

* 파일: `src/foundation/parsing/normalized_ast.py`
* 기능:

  * 언어별 TS node를 공통 NodeType으로 변환
  * children flatten, noise node 제거(comment, whitespace 등)

### 1-5. AST Traversal API

* 파일: `src/foundation/parsing/traversal.py`
* 기능:

  * pre-order / post-order 순회 유틸
  * 필터 기반 방문 (e.g. FunctionDef, ClassDef, Import)

---

## Phase 2. IR Layer (언어 중립 IR v4)

### 2-1. IRNode 생성기

* 파일: `src/foundation/ir/builder.py`
* 기능:

  * Normalized AST → IRDocument
  * IRNode 종류:

    * File / Class / Function / Method / Variable / Field / Import
    * ExternalFunction / ExternalModule
  * NodeID: `<lang>:<repo>:<kind>:<span_hash>`

### 2-2. FQN 생성기

* 파일: `src/foundation/ir/fqn.py`
* 기능:

  * module/class/function 기반 dotted FQN 생성
  * 예: `backend.search.retriever.Ranker.score`

### 2-3. IR Edge 기본 (BFG: Block Flow Graph 준비 전 단계)

* 파일: `src/foundation/ir/edges_basic.py`
* Edge 종류:

  * CONTAINS(File→Class/Function/Import)
  * IMPORTS(Module→Module)
  * CALLS(Identifier/Attribute/Import-aware)

### 2-4. Type 표현 (IRType)

* 파일: `src/foundation/ir/types.py`
* 타입 종류:

  * raw type ("int", "MyClass")
  * builtin type (list, dict 등)
  * local type (repo 내부 정의)
  * generic type 분해 (List[T], Dict[str,int])
* TypeEntity → GraphNode(Type) 승격 준비

### 2-5. Signature 표현 (IRSignature)

* 파일: `src/foundation/ir/signature.py`
* 필드:

  * parameters(+ default, *args, **kwargs)
  * return type
  * decorators 기반 flag
  * `signature_hash: SHA1`
* SignatureEntity → GraphNode(Signature) 승격 준비

---

## Phase 3. CFG/BFG Layer (Control/Branch Flow Graph)

이 Phase에서는 **BFG(Branch Flow Graph)**와 **CFG(Control Flow Graph)**를 나누어 구현함.

### 3-1. Basic Block 추출 (BFG)

* 파일: `src/foundation/cfg/basic_blocks.py`
* 기능:

  * Function/Method 단위로 statement를 block 단위로 나누기
  * branch split(if/elif/match/ternary)
  * loop(for/while)
  * try/except/finally

### 3-2. Control Flow Graph (CFG)

* 파일: `src/foundation/cfg/cfg_builder.py`
* Edge 종류:

  * fallthrough edge (순차 흐름)
  * branch edge (조건 분기)
  * loop back-edge (loop 끝 → loop 시작)
  * handler edge (try → except/finally)

### 3-3. CFGGraph → GraphDocument 일부로 포함

* GraphNode: CFGBlock
* GraphEdge: CONTROL_FLOW

### 3-4. Hook: Dataflow/taint 분석을 위한 플러그

* CFG 노드마다 읽기/쓰기 정보 연결을 위한 훅 제공

---

## Phase 4. DFG Layer (Data Flow Graph)

이 Phase는 **BFG/CFG 위에 DFG(Data Flow Graph)**를 추가.

### 4-1. Variable Read/Write 분석기

* 파일: `src/foundation/dfg/variable_usage.py`
* 기능:

  * statement 기준 read_var / write_var 추출
  * alias-aware (간단한 수준부터 시작)

### 4-2. DFG Edge 생성

* 파일: `src/foundation/dfg/dfg_builder.py`
* Edge 종류:

  * READS(block → variable)
  * WRITES(block → variable)

### 4-3. SSA/taint 준비 훅

* SSA 변환까지는 하지 않되, 필요 시 확장 가능한 구조로 설계
* taint-mode 분석기(Phase N)에서 재사용

### 4-4. GraphDocument 통합

* GraphNode: Variable, Assignment, UseSite
* GraphEdge: DATA_FLOW(READS/WRITES)

---

## Phase 5. Graph Construction Layer (IR → Graph)

### 5-1. GraphNode 승격

* 파일: `src/foundation/graph/builder_nodes.py`
* IRNode → GraphNode(Symbol)
* IRType → GraphNode(Type)
* IRSignature → GraphNode(Signature)
* External nodes 생성 규칙:

  * `external::<lang>::<symbol>`

### 5-2. GraphEdge 생성

* 파일: `src/foundation/graph/builder_edges.py`
* Edge 종류:

  * CONTAINS
  * IMPORTS
  * CALLS
  * READS / WRITES (DFG 기반)
  * REFERENCES_TYPE
  * (Phase3 확장) INHERITS / IMPLEMENTS / MIXIN
  * (Phase4 확장) REFERENCES_SYMBOL(usage)

### 5-3. Graph Normalization

* 파일: `src/foundation/graph/normalize.py`
* 기능:

  * edge dedupe
  * node dedupe
  * reverse indexes (node → inbound/outbound edges)
  * neighbor map 생성
  * graph consistency check (고아 노드, self-loop 검사)

---

## Phase 6. Chunk Layer (LLM Friendly 구조)

Phase 6은 별도 Chunking 스펙 문서(Chunking Strategy / Implementation Plan)를 따른다.

### 6-1. Chunk 모델 & 계층

* LeafChunk = function/method-level chunk (Symbol 1:1)
* ClassChunk = class-level parent
* FileChunk = file-level parent
* Module / Project / Repo Chunk = 상위 계층 parent

### 6-2. Stable ID

* `chunk_id = f"chunk:{repo_id}:{kind}:{fqn}"`

### 6-3. Chunk ↔ Graph ↔ IR 매핑

* ChunkToGraph, ChunkToIR 매핑 생성
* 상위 Chunk(GraphNode 집계) + 필터링 규칙 적용

### 6-4. Boundary & 증분 처리

* gap/overlap 검증
* git diff 기반 변경 파일만 재청킹

(자세한 내용은 `Semantica_v2_Chunking_Implementation_Plan` 문서 참조)

---

## Phase 7. RepoMap Layer (Project Structural Summary)

### 7-1. RepoMap 트리 생성기

* 파일: `src/repomap/builder.py`
* 입력: Chunk 계층 + GraphDocument + IRDocument
* 출력: RepoMapNode 트리

### 7-2. 중요도 계산

* 파일: `src/repomap/ranker.py`
* PageRank / HybridRank
* 입력 신호:

  * CALLS in-degree/out-degree
  * IMPORTS fan-in/fan-out
  * runtime hotness(optional)

### 7-3. Summary 생성

* 파일: `src/repomap/summarizer.py`
* LLM or template 기반 summary_text 생성

### 7-4. 탐색 API

* 상위/하위/동일 레벨 탐색
* neighbor expansion (같은 모듈/레이어 내 상호 참조)

---

## Phase 8. Index Layer (Lexical / Vector / Symbol / Fuzzy / Domain / Runtime)

### 8-1. Lexical Index

* 모듈: `src/index/lexical/`
* Zoekt or Meilisearch adapter
* 입력: Chunk text, identifiers, path

### 8-2. Vector Index

* 모듈: `src/index/vector/`
* Qdrant adapter
* 입력: Chunk의 `search_text` (summary+code)

### 8-3. Symbol Index

* 모듈: `src/index/symbol/`
* go-to-def / find-refs 지원
* export/import resolution

### 8-4. Fuzzy Index

* 모듈: `src/index/fuzzy/`
* identifier n-gram, partial token 검색 지원

### 8-5. Domain Metadata Index

* 모듈: `src/index/domain_meta/`
* README, ADR, API spec → 코드 매핑

### 8-6. Runtime Index

* 모듈: `src/index/runtime/`
* trace span, hot path, error point
* runtime overlay → Graph 가중치로 사용

---

## Phase 9. Retriever Layer (LLM 최적화 검색기)

### 9-1. Intent Router

* 모듈: `src/retriever/intent/`
* intent 종류:

  * definition / usage / call chain / refactoring
  * DTO/API / E2E pipeline 등

### 9-2. Multi-Index Query

* 모듈: `src/retriever/multi_index/`
* 기능:

  * lexical/vector/symbol/fuzzy/domain/runtime 병렬 조회
  * score list 생성

### 9-3. Graph Expansion

* 모듈: `src/retriever/graph_runtime_expansio
