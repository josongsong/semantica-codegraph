최종 구조 개요

1-1. 스코프

입력

Structural IR

ModuleIR, ClassIR, FunctionIR, StatementIR, VariableIR 등

AST, 심볼 테이블, 언어별 타입 해석 결과(Pyright, TS server 등)

출력

Semantic IR

TypeEntity

SignatureEntity

CFGBlock / ControlFlowEdge

VariableEntity / ReadWriteEvent / DataFlowEdge

SemanticIndex

Structural IR ↔ Semantic IR 매핑 인덱스

역할

정적 분석, Taint, 영향 범위, 리팩토링, CodeRAG에 공통으로 쓰이는 의미 계층을 제공

Graph / Index 레이어에서 바로 활용 가능한 안정된 스키마 제공

1-2. 파이프라인 요약 (실제 실행 순서)

전체 파이프라인

Structural IR Snapshot/Delta 준비

Type System IR 생성

Signature IR 생성

CFG IR 생성

DFG IR 생성

SemanticIndex 생성

Semantic IR Snapshot/Delta 저장

Graph Projection (Semantic IR → GraphNode/GraphEdge)

증분 시나리오

git diff → StructuralIrDelta 생성

DefaultSemanticIrBuilder.apply_delta(delta) 호출

SemanticIrDelta를 IRStore / GraphStore / Index에 적용

디렉터리 / 모듈 구조 구축안

2-1. 상위 구조

core/
  foundation/
    parsing/
    ir/                         # Structural IR
      model.py
      builder.py

    semantic_ir/                # Semantic IR 레이어
      context.py                # 공통 Snapshot/Delta, SemanticIndex
      typing_ir/
        model.py
        resolver.py
        builder.py
      signature_ir/
        model.py
        builder.py
      cfg_ir/
        model.py
        builder.py
      dfg_ir/
        model.py
        builder.py

    graph/
      projection/
        semantic_projection.py  # Semantic IR → Graph 매핑 구현


2-2. 의존 관계

parsing → ir → semantic_ir → graph.projection

semantic_ir 내부 의존성

typing_ir: Structural IR, AST, 심볼 테이블

signature_ir: Structural IR + typing_ir 결과

cfg_ir: Structural IR만으로 생성

dfg_ir: Structural IR + cfg_ir + typing_ir 결과

IR 모델 설계 (최종 스키마)

3-1. 공통 Snapshot / Delta / Index

# core/foundation/semantic_ir/context.py

class StructuralIrSnapshot(BaseModel):
    modules: list[ModuleIR]
    classes: list[ClassIR]
    functions: list[FunctionIR]

class StructuralIrDelta(BaseModel):
    added_functions: list[FunctionIR]
    updated_functions: list[FunctionIR]
    deleted_function_ids: list[str]

class SemanticIrSnapshot(BaseModel):
    types: list[TypeEntity]
    signatures: list[SignatureEntity]
    cfg_blocks: list[CFGBlock]
    cfg_edges: list[ControlFlowEdge]
    variables: list[VariableEntity]
    read_write_events: list[ReadWriteEvent]
    dataflow_edges: list[DataFlowEdge]

class SemanticIrDelta(BaseModel):
    added: SemanticIrSnapshot
    updated: SemanticIrSnapshot
    deleted_ids: dict[str, list[str]]

class SemanticIndex(BaseModel):
    function_to_signature: dict[str, str]                # FunctionIR.symbol_id → SignatureEntity.id
    function_to_param_type_ids: dict[str, list[str]]     # FunctionIR.symbol_id → [TypeEntity.id]
    function_to_return_type_id: dict[str, str | None]
    variable_struct_to_semantic: dict[str, str]          # VariableIR.id → VariableEntity.id


3-2. TypeEntity

# core/foundation/semantic_ir/typing_ir/model.py

class TypeEntity(BaseModel):
    id: str                   # "type:{lang}:{fqn_or_hash}"
    language: str             # "python", "typescript", ...
    kind: str                 # "builtin" | "local" | "external" | "generic" | "unknown"
    raw_text: str             # 소스 그대로 ("List[User]")
    normalized_name: str      # 정규화 이름 ("typing.List[pkg.mod.User]")
    generic_base_id: str | None
    generic_arg_ids: list[str]
    is_union: bool
    is_optional: bool
    source_file: str | None
    span_start_line: int | None
    span_end_line: int | None
    attrs: dict[str, Any] = {}


3-3. SignatureEntity

# core/foundation/semantic_ir/signature_ir/model.py

class ParamSpec(BaseModel):
    name: str
    kind: str                 # "pos", "kw", "var", "kwvar", "pos_only", "kw_only"
    type_id: str | None
    has_default: bool

class SignatureEntity(BaseModel):
    id: str                   # "signature:{fqn}:{sha1}"
    function_symbol_id: str   # Structural FunctionIR.symbol_id
    params: list[ParamSpec]
    return_type_id: str | None
    decorator_flags: dict[str, bool]
    signature_hash: str
    language: str
    attrs: dict[str, Any] = {}


3-4. CFGBlock / ControlFlowEdge

# core/foundation/semantic_ir/cfg_ir/model.py

class CFGBlock(BaseModel):
    id: str                   # "cfg:{function_symbol_id}:{index}"
    function_symbol_id: str
    index: int
    kind: str                 # "entry" | "normal" | "exit" | "handler"
    statement_ids: list[str]  # Structural StatementIR.id
    source_file: str
    span_start_line: int
    span_end_line: int

class ControlFlowEdge(BaseModel):
    id: str                   # "cfge:{from_block_id}:{to_block_id}:{kind}"
    from_block_id: str
    to_block_id: str
    kind: str                 # "fallthrough" | "branch" | "loop_back" | "handler"


3-5. VariableEntity / ReadWriteEvent / DataFlowEdge

# core/foundation/semantic_ir/dfg_ir/model.py

class VariableEntity(BaseModel):
    id: str                           # "var:{function_symbol_id}:{name}:{slot}"
    function_symbol_id: str           # Structural FunctionIR.symbol_id
    structural_node_id: str | None    # VariableIR.id or FieldIR.id
    name: str
    kind: str                         # "local" | "param" | "field" | "global"
    type_id: str | None
    defining_block_id: str | None     # CFGBlock.id

class ReadWriteEvent(BaseModel):
    id: str                           # "rw:{var_id}:{cfg_block_id}:{seq}"
    var_id: str
    cfg_block_id: str
    op_kind: str                      # "read" | "write"
    stmt_id: str                      # StatementIR.id
    structural_expr_id: str | None    # expression IR id (옵션)
    source_file: str
    line: int

class DataFlowEdge(BaseModel):
    id: str                           # "dfg:{from_var_id}:{to_var_id}:{kind}"
    from_var_id: str
    to_var_id: str
    kind: str                         # "alias" | "def_use" | "param_to_arg"


빌더 인터페이스 및 구현 전략

4-1. SemanticIrBuilder

# core/foundation/semantic_ir/context.py

class SemanticIrBuilder(Protocol):
    def build_full(
        self,
        structural: StructuralIrSnapshot,
    ) -> tuple[SemanticIrSnapshot, SemanticIndex]: ...

    def apply_delta(
        self,
        structural_delta: StructuralIrDelta,
        existing_index: SemanticIndex,
    ) -> tuple[SemanticIrDelta, SemanticIndex]: ...


구현체

# core/foundation/semantic_ir/builder.py

class DefaultSemanticIrBuilder:

    def __init__(
        self,
        type_builder: TypeIrBuilder,
        signature_builder: SignatureIrBuilder,
        cfg_builder: CfgIrBuilder,
        dfg_builder: DfgIrBuilder,
    ):
        ...

    def build_full(self, structural: StructuralIrSnapshot) -> tuple[SemanticIrSnapshot, SemanticIndex]:
        types, type_index = self.type_builder.build_full(structural)
        signatures, sig_index = self.signature_builder.build_full(structural, type_index)
        cfg_blocks, cfg_edges = self.cfg_builder.build_full(structural)
        variables, events, dfg_edges, var_index = self.dfg_builder.build_full(
            structural,
            cfg_blocks,
            types,
        )

        semantic_snapshot = SemanticIrSnapshot(
            types=types,
            signatures=signatures,
            cfg_blocks=cfg_blocks,
            cfg_edges=cfg_edges,
            variables=variables,
            read_write_events=events,
            dataflow_edges=dfg_edges,
        )

        semantic_index = SemanticIndex(
            function_to_signature=sig_index.function_to_signature,
            function_to_param_type_ids=type_index.function_to_param_type_ids,
            function_to_return_type_id=type_index.function_to_return_type_id,
            variable_struct_to_semantic=var_index.variable_struct_to_semantic,
        )

        return semantic_snapshot, semantic_index


4-2. TypeIrBuilder 실행안

입력

StructuralIrSnapshot

AST, 심볼 테이블 (내부에서 DI로 받음)

build_full 핵심 로직

모든 FunctionIR, ClassIR, FieldIR 순회

각 파라미터/리턴/필드/변수에 대해 annotation AST 추출

TypeResolver.resolve(annotation, scope) 호출

ResolvedType → TypeEntity 생성 (캐시 재사용)

TypeIndex 구성

function_to_param_type_ids

function_to_return_type_id

결과

types: list[TypeEntity]

type_index: TypeIndex

4-3. SignatureIrBuilder 실행안

입력

StructuralIrSnapshot

TypeIndex

build_full 핵심 로직

각 FunctionIR에 대해

ParamSpec 목록 구성

decorator_flags 계산

canonical signature string 생성

SHA1 signature_hash

SignatureEntity 생성

SignatureIndex 구성

function_to_signature

4-4. CfgIrBuilder 실행안

입력

StructuralIrSnapshot (FunctionIR + StatementIR)

build_full 핵심 로직

함수 단위로 StatementIR 리스트 가져오기

분기 포인트 기준으로 basic block segmentation

각 block → CFGBlock 생성

control 구조 기반 ControlFlowEdge 생성

entry/exit 블록 생성

4-5. DfgIrBuilder 실행안

입력

StructuralIrSnapshot

CFGBlock / ControlFlowEdge

TypeEntity (필요시 변수 타입)

build_full 핵심 로직

함수 파라미터 → VariableEntity(kind="param") 생성

로컬 변수 선언/첫 할당 → VariableEntity(kind="local") 생성

CFGBlock 순회하면서 StatementIR 패턴 분석

READ 변수 → ReadWriteEvent(op_kind="read")

WRITE 변수 → ReadWriteEvent(op_kind="write")

a = b → DataFlowEdge(kind="alias")

VariableIndex 구성

variable_struct_to_semantic

증분 업데이트 전략 구축안

5-1. 공통 정책

단위: Function 단위

StructuralIrDelta 기준

added_functions

Type/Signature/CFG/DFG 전체 새로 생성

updated_functions

동일 함수에 대해 Type/Signature/CFG/DFG 재생성

deleted_function_ids

관련 Semantic IR 엔티티 전부 삭제 대상

5-2. 레이어별

Type

updated 함수의 파라미터/리턴에 사용된 Type만 재검사

TypeEntity GC는 lazy 전략 가능

Signature

updated 함수에 대해 canonical string 재계산

hash 동일하면 기존 Signature 재사용

CFG

함수 단위 full rebuild

DFG

CFG가 바뀌면 DFG도 함수 단위 full rebuild

Graph Projection 구축안

6-1. Node 종류

GraphNode.kind

"Type"

source: TypeEntity

"Signature"

source: SignatureEntity

"CFGBlock"

source: CFGBlock

"Variable"

source: VariableEntity

6-2. Edge 종류

CFGEdge (Control Flow)

source: ControlFlowEdge

from_node: CFGBlock.id

to_node: CFGBlock.id

GraphEdge.kind

"cfg_fallthrough"

"cfg_branch"

"cfg_loop_back"

"cfg_handler"

DFGEdge (Data Flow)

source: DataFlowEdge

from_node: VariableEntity.id

to_node: VariableEntity.id

GraphEdge.kind

"dfg_alias"

"dfg_def_use"

"dfg_param_to_arg"

VarRead / VarWrite (옵션)

source: ReadWriteEvent

GraphEdge.kind

"var_read" (CFGBlock → Variable)

"var_write" (CFGBlock → Variable)

6-3. semantic_projection.py 역할

SemanticIrSnapshot → GraphDocument 변환

각 TypeEntity → GraphNode(Type)

각 SignatureEntity → GraphNode(Signature)

각 CFGBlock → GraphNode(CFGBlock)

각 VariableEntity → GraphNode(Variable)

ControlFlowEdge → GraphEdge(cfg_*)

DataFlowEdge → GraphEdge(dfg_*)

ReadWriteEvent를 Edge 또는 별도 메타로 투영

저장소 스키마 구축안 (러프)

7-1. IRStore (Postgres)

semantic_types

id (PK)

language

kind

raw_text

normalized_name

generic_base_id

generic_arg_ids (JSONB)

is_union

is_optional

source_file

span_start_line

span_end_line

attrs (JSONB)

semantic_signatures

id (PK)

function_symbol_id

params (JSONB)

return_type_id

decorator_flags (JSONB)

signature_hash

language

semantic_cfg_blocks

id (PK)

function_symbol_id

index

kind

statement_ids (JSONB)

source_file

span_start_line

span_end_line

semantic_cfg_edges

id (PK)

from_block_id

to_block_id

kind

semantic_variables

id (PK)

function_symbol_id

structural_node_id

name

kind

type_id

defining_block_id

semantic_read_write_events

id (PK)

var_id

cfg_block_id

op_kind

stmt_id

structural_expr_id

source_file

line

semantic_dataflow_edges

id (PK)

from_var_id

to_var_id

kind

semantic_index

repo_id

function_symbol_id

signature_id

param_type_ids (JSONB)

return_type_id

variable_struct_to_semantic (JSONB or 별도 테이블)

실제 구현 로드맵

8-1. Phase 1: 최소 동작 버전

Structural IR 이미 구현되어 있다는 전제로 진행

typing_ir

TypeEntity, TypeResolver, TypeIrBuilder

builtin/local/generic 처리부터

signature_ir

ParamSpec, SignatureEntity, SignatureIrBuilder

SemanticIrBuilder.build_full의 Type/Signature 부분만 먼저 완성

8-2. Phase 2: CFG IR 추가

CFGBlock, ControlFlowEdge 모델

FunctionIR → basic block segmentation 알고리즘 구현

CfgIrBuilder.build_full 구현

SemanticIrBuilder에 CFG 연결

8-3. Phase 3: DFG IR 추가

VariableEntity, ReadWriteEvent, DataFlowEdge 모델

변수 추출 규칙 정리 (param/local/field)

StatementIR 패턴 매칭으로 READ/WRITE/alias 처리

DfgIrBuilder.build_full 구현

SemanticIndex.variable_struct_to_semantic 구성

8-4. Phase 4: 증분 / GraphProjection

StructuralIrDelta 생성 로직 확정

각 Builder.apply_delta 구현

SemanticIrBuilder.apply_delta 구현

semantic_projection.py에서 Node/Edge 매핑 구현

Kuzu/GraphStore에 실제 인서트/업데이트 경로 연결

이 플랜 그대로 따라가면

Semantic IR Layer는 SOTA 구조와 정합되면서

실제 코드/DB/Graph까지 일관된 형태로 구축 가능함.
