# Semantica Codegraph IR v4.1 기반 전체 구현 계획서

---

## 1. 목표 / 스코프

1-1. 최종 목표

* 코드레포에 대해 다음을 만족하는 CodeRAG 엔진 구현

  * IR v4.1 (Node / Edge / Type / Signature / ControlFlowSummary) 기반 공통 표현
  * foundation / repomap / index / retriever 4 레이어 일관 구조
  * Git + Workspace(로컬 수정) 동시 지원
  * LLM/에이전트가 실시간 코드 검색/편집 가능한 수준의 품질

1-2. 이번 설계서의 범위

* IR v4.1 스키마를 실제 코드/DB/파이프라인으로 내리는 전체 계획
* “지금 당장 구현할 것” vs “나중에 개발할 것” 명시
* 구현 단계는 Phase 0~4로 구분

표기 규칙

* [즉시 구현] 지금 라운드에서 구현할 것
* [나중에 개발] 이후 라운드(성능/고급 기능)에서 붙일 것

---

## 2. 상위 아키텍처 재확인

2-1. 레이어 구조

* foundation

  * Tree-sitter / LSP / (미래의 SCIP) → AST → IR(Node/Edge/Type/Signature)
* repomap

  * IR / Graph / Chunk 기반 프로젝트 구조 트리 + 중요도 + 요약
* index

  * Lexical / Vector / Symbol / Fuzzy / Domain / Runtime 인덱스
* retriever

  * Query 분석 → Multi-index 검색 → Graph/RepoMap 확장 → Fusion → Context Builder

2-2. IR v4.1 핵심 구조

* IRDocument

  * nodes[]: 언어 불문 공통 Node
  * edges[]: 관계(그래프), CONTAINS 포함
  * types[]: 타입 표현 (TypeEntity)
  * signatures[]: 함수/메서드 시그니처
  * control_flow_graphs: [나중에 개발] 온디맨드 CFG
  * meta: index_time, engine_version, index_run_id 등

2-3. 운영 컴포넌트

* IRGenerator: AST → IRDocument 변환기
* IRStore: 메모리 상의 IR 뷰 (Hot/Cold + Lazy Load)
* IRDatabase: DB/Kuzu와의 R/W 어댑터
* Indexers: IR → Lexical/Vector/Symbol 등으로 푸시

---

## 3. Phase 0 – 인프라 / 공통 유틸

3-1. 리포지토리 / 모듈 구조 정리 [즉시 구현]

* semantica/

  * foundation/

    * parsing/
    * ir/
    * graph/ (Edge/Graph 전용 유틸)
  * repomap/
  * index/
  * retriever/
  * storage/

    * ir_store/
    * db/
  * cli/

3-2. 공통 타입 / 로깅 / 설정 [즉시 구현]

* 공통 Pydantic 모델 or dataclass로 IR v4.1 구조 정의
* settings (DB 연결, index backend, snapshot 정책 등)
* 기본 로깅 규칙 정리

3-3. DB 선택 / 마이그레이션 베이스 [즉시 구현]

* 1단계: Postgres + JSONB 기반 Hybrid 스키마
* [나중에 개발] 2단계: Kuzu / 다른 Graph DB 연동

---

## 4. Phase 1 – IR v4.1 Core (Node / Edge / Type / Signature)

### 4-1. IR 데이터 모델 구현 [즉시 구현]

4-1-1. Node/Edge/Type/Signature 모델

* Pydantic 모델 혹은 dataclass로 다음 정의

  * Node

    * id (stable)
    * logical_id (optional)
    * kind, name, fqn, file_path, span, body_span
    * language, module_path, parent_id
    * content_hash, docstring, role, is_test_file
    * signature_id, declared_type_id
    * control_flow_summary (optional)
  * Edge

    * id, kind, source_id, target_id, span, attrs
  * TypeEntity

    * id, raw, resolved_target, flavor, is_nullable, generic_param_ids
    * resolution_level(raw_only/basic/full)
  * SignatureEntity

    * id, owner_node_id, name, raw, parameter_type_ids, return_type_id
    * visibility, is_async, is_static, throws_type_ids, signature_hash

4-1-2. Span / 기타 공통 구조체

* Span, ControlFlowSummary 정의

4-1-3. IRDocument 컨테이너

* IRDocument

  * repo_id, snapshot_id, schema_version
  * nodes, edges, types, signatures, control_flow_graphs(optional), meta

### 4-2. Node ID 전략 구현 [즉시 구현]

4-2-1. stable id 생성 규칙

* 입력 값

  * repo_id
  * file_path
  * kind
  * fqn
  * span (start_line, end_line)
  * content_hash
* stable id = hash(repo_id + kind + fqn + span + content_hash)

4-2-2. logical_id 생성 규칙

* 읽기 쉬운 형식 유지

  * 예: "method:semantica:src/retriever/plan.py:HybridRetriever.plan"

4-2-3. 파일 이동 시 동작

* 동일한 fqn + 유사 span + 동일/유사 content_hash면 이전 stable id 재사용 시도
* 완전히 다른 코드면 새 ID 할당

### 4-3. Tree-sitter 기반 IRGenerator (Python/TS 2언어 우선)

4-3-1. Parsing 레이어 [즉시 구현]

* foundation.parsing

  * ParserRegistry
  * SourceFile
  * AstTree (Tree-sitter AST wrapper)

4-3-2. AST → Node/Edge/Type/Signature 변환 [즉시 구현]

* 최소 커버 범위

  * Node: File, Class, Function/Method, Variable, Field, Import
  * Edge:

    * CONTAINS (File→Class, Class→Method, Method→Variable 등)
    * CALLS (간단한 함수/메서드 호출)
    * IMPORTS
  * TypeEntity:

    * flavor=primitive/user/external 정도만
    * resolution_level=raw_only
  * SignatureEntity:

    * 파라미터 이름/타입(raw), 반환 타입(raw)
    * is_async, is_static 정도만

4-3-3. control_flow_summary 계산 [즉시 구현]

* cyclomatic_complexity, has_loop, has_try 정도만 AST 기반으로 계산
* 풀 CFG 생성은 [나중에 개발]

### 4-4. LSP/SCIP 통합 훅 [나중에 개발]

* LSP/SCIP에서 가져올 수 있는 정보 정리

  * 정교한 타입 정보, cross-file definition, rename 지원 등
* IRGenerator 파이프라인에 “외부 분석기 결과를 merge”하는 훅 추가
* 실제 구현은 이후 Phase에서 처리

---

## 5. Phase 2 – IR 저장소 (DB + IRStore)

### 5-1. DB 스키마 설계/구현 [즉시 구현]

5-1-1. ir_nodes 테이블

* 컬럼 설계

  * id (PK, stable)
  * snapshot_id
  * kind, fqn, file_path, language
  * name, module_path, role, is_test_file
  * attrs JSONB (span/body_span/content_hash/logical_id/control_flow_summary 등)
* 인덱스

  * (snapshot_id, kind)
  * (snapshot_id, file_path)
  * (snapshot_id, fqn)

5-1-2. ir_edges 테이블

* 컬럼 설계

  * id (PK), snapshot_id
  * kind, source_id, target_id
  * span JSONB, attrs JSONB
* 인덱스

  * (snapshot_id, kind)
  * (snapshot_id, source_id, kind)
  * (snapshot_id, target_id, kind)

5-1-3. types / signatures 테이블 [즉시 구현]

* ir_types
* ir_signatures

5-1-4. Kuzu/그래프 DB 매핑 [나중에 개발]

* Node, Edge를 Kuzu 노드/관계로 매핑하는 스키마 설계
* CALLS/CONTAINS 중심 쿼리 최적화

### 5-2. IRDatabase 추상화 [즉시 구현]

* 인터페이스 예시

  * load_node(id)
  * load_nodes_by_file(snapshot_id, file_path)
  * load_edges_by_source(snapshot_id, source_id, kind=None)
  * upsert_nodes(nodes)
  * upsert_edges(edges)
* 구현체

  * PostgresIRDatabase
  * [나중에 개발] KuzuIRDatabase

### 5-3. IRStore (Hot/Cold + Lazy Load) [즉시 구현]

5-3-1. 기본 구조

* in-memory 캐시 + DB lazy loading
* LRU 기반 node/edge 캐시 관리

5-3-2. API

* get_node(node_id)
* get_children(node_id) – CONTAINS Edge 기반
* get_parents(node_id)
* get_calls_from(node_id)
* get_calls_to(node_id)

5-3-3. 파일 단위 프리페치 [즉시 구현]

* 특정 file_path 관련 Node/Edge 한 번에 로딩/캐싱

5-3-4. Hot/Cold 정책 [나중에 개발]

* 자주 조회되는 파일/노드를 hot set으로 유지
* test 디렉토리는 기본 cold 등 정책화

---

## 6. Phase 3 – Snapshot / 증분 인덱싱

### 6-1. Snapshot 정책 구현 [즉시 구현]

6-1-1. snapshot_id 규칙

* workspace: "workspace:<user>@<session>"
* git commit: "commit:<sha>"
* branch main 공식 빌드: "branch:main@<sha>"

6-1-2. snapshot_policy

* workspace → memory_only + DB 비동기 업데이트
* git_commit → IRDocument JSON 스냅샷 생성 + DB 저장
* branch_main → snapshot JSON 영구 보관

### 6-2. 최초 인덱싱 플로우 [즉시 구현]

* 전체 repo 스캔
* AST/IR 생성 → IRDocument (commit:<sha>)
* DB 저장 + IRStore 로딩
* (옵션) JSON 파일로도 떨굼

### 6-3. 실시간 파일 변경 플로우 [즉시 구현]

* 파일 저장 이벤트

  * 변경 파일만 AST → IR 재생성
  * 기존 IR과 diff
  * IRStore 즉시 업데이트 (노드/엣지 upsert/delete)
  * DB 업데이트는 비동기
* snapshot_id는 workspace 기준 하나만 유지

### 6-4. Git 이벤트 (checkout/pull/rebase) [즉시 구현]

* HEAD 변경 감지
* 변경 파일만 재인덱싱 → 새 snapshot_id(commit:<sha>)
* IRStore를 새 snapshot 기준으로 리프레시
* DB 저장 + 필요시 snapshot JSON 생성

### 6-5. 전체 재인덱싱 (CI/CD) [나중에 개발]

* main 브랜치 nightly/빌드 시 전체 재인덱싱
* branch:main@<sha> 스냅샷 생성 및 영구 보관

---

## 7. Phase 4 – Index / Retriever 연동 (MVP 수준)

### 7-1. Index 연동 (Lexical / Vector 최소)

7-1-1. Lexical Index [즉시 구현]

* 대상: Leaf 수준 청크 or Node별 코드 블록
* 백엔드: Meilisearch or Tantivy
* 동작

  * IR 업데이트 시 해당 파일/노드 텍스트 재색인

7-1-2. Vector Index [즉시 구현]

* 대상: Leaf Chunk + 일부 Parent/RepoMap summary (준비되면)
* 백엔드: Qdrant or pgvector
* 동작

  * IR 변경 시 해당 코드 블록 임베딩 재계산 + upsert

7-1-3. Symbol Index [나중에 개발]

* 대상: Node.fqn + kind
* go-to-def / find-refs용 별도 인덱스 or 직접 Postgres 쿼리

### 7-2. Retriever 최소 버전 [즉시 구현]

7-2-1. retriever.intent 간단 버전

* 쿼리 문자열 분석 없이 rule-based 시작

  * "정의"/"어디서 선언" → Symbol/lexical 우선
  * 나머지 → Vector + Lexical 병합

7-2-2. retriever.multi_index

* Lexical + Vector 병렬 조회
* CandidateSet 구성 (node_id/chunk_id + score)

7-2-3. retriever.fusion

* 간단 가중합: lexical_score, vector_score

7-2-4. retriever.context_builder

* Node/파일 단위로 묶어서 코드 블록 반환
* 토큰 budget 내에서 단순 자르기

7-2-5. Graph/RepoMap 확장 [나중에 개발]

* CALLS/CONTAINS Edge 기반 확장
* RepoMap 중요도 기반 재가중치

---

## 8. Phase 5 – 고급 기능 (나중에 개발)

### 8-1. Type 해석 고도화 [나중에 개발]

* Phase 1: raw_only
* Phase 2: basic (primitive + 같은 파일/모듈)
* Phase 3: full (mypy/pyright/TS compiler 연동)

### 8-2. Name Resolution Graph (StackGraphs 스타일) [나중에 개발]

* NameResolutionGraph 레이어 추가
* cross-file name binding 디버깅/탐색

### 8-3. CFG / DFG 온디맨드 생성 [나중에 개발]

* 인기/핫 함수에 대해 CFG 생성 및 캐시
* READS/WRITES Edge + CFG Block def/use로 DFG 구성

### 8-4. RepoMap / PageRank / RAPTOR 요약 [나중에 개발]

* repomap.builder/pagerank/summarizer 구현
* 프로젝트 구조 요약 + 계층 요약 생성

### 8-5. Runtime Index / Hot Path 반영 [나중에 개발]

* tracing/span 로그 → runtime index → Edge/Node에 hotness/에러 score 반영
* retriever.graph_runtime_expansion에서 활용

---

## 9. 지금 라운드에서 실제로 해야 할 것 (Checklist)

[즉시 구현]

1. IR v4.1 데이터 모델 (Node/Edge/Type/Signature/IRDocument) 코드화
2. Tree-sitter 기반 IRGenerator (Python/TS 최소 지원)
3. control_flow_summary 계산 (CFG 없이)
4. Node ID 전략(stable id + logical_id + content_hash) 구현
5. Postgres 기반 ir_nodes / ir_edges / ir_types / ir_signatures 테이블 설계 및 마이그레이션
6. IRDatabase (Postgres) 구현
7. IRStore (LRU + 파일 단위 프리페치) 구현
8. 최초 인덱싱 플로우 (repo → IR → DB → IRStore)
9. 파일 변경 이벤트 증분 인덱싱 플로우
10. git commit 기반 snapshot 생성 플로우
11. Lexical / Vector Index 간단 연동
12. Retriever 최소 버전 (Lexical + Vector + 단순 Context Builder)

[나중에 개발]

* Kuzu 등 그래프 DB 연동
* Symbol Index / Graph 기반 확장
* Type full resolution
* CFG/DFG 온디맨드
* NameResolutionGraph(StackGraphs)
* RepoMap/PageRank/RAPTOR 요약
* Runtime/Tracing 기반 인덱스

---

이 문서는 "IR v4.1 + 전체 파이프라인"을 기준으로 한 구현 계획서 초안임.
실제 구현하면서 Phase별로 세부 테스크/이슈 트래킹은 별도 티켓/ADR로 쪼갤 수 있음.
