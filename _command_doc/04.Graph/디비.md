Thought for 9s

방향 요약

Kuzu에서는 **“하나의 Node 테이블 + 여러 REL 테이블”**로 가는 게 맞음.

배열 컬럼은 최소화하고, 관계는 전부 REL TABLE로 빼는 구조로 설계.

GraphDocument 스펙을 그대로 투영하되, GraphIndex(called_by, routes_by_path 등)는 대부분 쿼리/뷰/머티리얼라이즈드 테이블로 해결.

Core Node / Edge 스키마 (Kuzu용 최소 설계)

2-1. NODE TABLE: graph_node

CREATE NODE TABLE graph_node (
  node_id       STRING,          -- {lang}:{repo_id}:{kind}:{fqn} 등
  repo_id       STRING,
  lang          STRING,
  kind          STRING,          -- File, Class, Function, Route, Service 등
  fqn           STRING,
  name          STRING,
  path          STRING,          -- 파일 경로 (없으면 NULL)
  snapshot_id   STRING,

  span_start_line INT,
  span_end_line   INT,

  attrs         STRING,          -- JSON 직렬화 (decorators, framework, domain_tags 등)

  PRIMARY KEY (node_id)
);


인덱스 추천

CREATE INDEX graph_node_repo_kind_fqn ON graph_node(repo_id, kind, fqn);
CREATE INDEX graph_node_path          ON graph_node(path);


2-2. REL TABLE: 기본 그래프 관계

핵심 아이디어:

종류가 자주 쓰이는 엣지는 전용 REL TABLE

드물거나 실험적인 엣지는 generic REL에 넣어도 됨.

예시 스키마:

-- 구조
CREATE REL TABLE CONTAINS FROM graph_node TO graph_node (
  attrs STRING
);

CREATE REL TABLE IMPORTS FROM graph_node TO graph_node (
  attrs STRING
);

CREATE REL TABLE CALLS FROM graph_node TO graph_node (
  attrs STRING         -- call_site_span, via_alias 등
);

CREATE REL TABLE INHERITS FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE IMPLEMENTS FROM graph_node TO graph_node (attrs STRING);

-- 타입/심볼 참조
CREATE REL TABLE REFERENCES_TYPE FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE REFERENCES_SYMBOL FROM graph_node TO graph_node (attrs STRING);

-- 데이터 흐름
CREATE REL TABLE READS FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE WRITES FROM graph_node TO graph_node (attrs STRING);

-- CFG
CREATE REL TABLE CFG_NEXT    FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE CFG_BRANCH  FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE CFG_LOOP    FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE CFG_HANDLER FROM graph_node TO graph_node (attrs STRING);

-- 프레임워크/아키텍처
CREATE REL TABLE ROUTE_HANDLER   FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE HANDLES_REQUEST FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE USES_REPOSITORY FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE MIDDLEWARE_NEXT FROM graph_node TO graph_node (attrs STRING);

-- 객체 생성/데코레이터
CREATE REL TABLE INSTANTIATES FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE DECORATES   FROM graph_node TO graph_node (attrs STRING);

-- 런타임/요약/의미 (확장)
CREATE REL TABLE EXECUTES          FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE THROWS            FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE AFFECTS           FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE SUMMARIZES        FROM graph_node TO graph_node (attrs STRING);
CREATE REL TABLE SEMANTIC_NEIGHBOR FROM graph_node TO graph_node (attrs STRING);


포인트

CfgBlock, Variable, Type, Summary, RuntimeSpan, ErrorSite 전부 graph_node.kind로 구분

READS/WRITES, CFG_*의 source/target도 node_id 기준으로 연결하면 됨.

GraphIndex는 어떻게? (called_by, routes_by_path 등)

3-1. called_by, imported_by, contains_children

이건 별도 테이블 없이 쿼리로 해결하는 게 낫다.

called_by

-- 어떤 함수를 호출하는 상위들
MATCH (caller:graph_node)-[c:CALLS]->(callee:graph_node)
WHERE callee.node_id = $symbol_id
RETURN caller;


imported_by

MATCH (importer:graph_node)-[i:IMPORTS]->(module:graph_node)
WHERE module.node_id = $module_id
RETURN importer;


contains_children

MATCH (parent:graph_node)-[c:CONTAINS]->(child:graph_node)
WHERE parent.node_id = $parent_id
RETURN child;


3-2. routes_by_path / request_flow_index

여기는 조회가 잦으니까 최소한 인덱스/머티리얼라이즈드 뷰 수준으로.

routes_by_path: path는 Route 노드 attrs에 저장

-- Route 노드 조회용 인덱스
CREATE INDEX route_path_idx ON graph_node(kind, attrs);
-- attrs JSON에서 path 꺼내는 건 애플리케이션 계층에서 처리 or 정규화 컬럼 하나 추가


request_flow_index: 그래프 조인으로 구성

-- Route → Handler → Service → Repository 플로우
MATCH  (route:graph_node {kind: 'Route'})-[:ROUTE_HANDLER]->(h:graph_node)
OPTIONAL MATCH (h)-[:HANDLES_REQUEST]->(s:graph_node)
OPTIONAL MATCH (s)-[:USES_REPOSITORY]->(r:graph_node)
WHERE route.node_id = $route_id
RETURN route, h as handler, collect(s) as services, collect(r) as repositories;


필요하면 위 쿼리 결과를 별도 TABLE request_flow_cache에 덤프해서 캐시용으로 쓰면 됨.

CREATE TABLE request_flow_cache (
  route_id      STRING,
  handler_id    STRING,
  service_ids   STRING,   -- JSON 배열
  repository_ids STRING,  -- JSON 배열
  snapshot_id   STRING
);


확장성 코멘트

Core는 graph_node + 주요 REL TABLE만 있으면 충분함.

Edge 종류를 새로 추가해도, CREATE REL TABLE XXX FROM graph_node TO graph_node 한 줄이면 확장 가능.

Runtime/요약/의미 레이어도 같은 graph_node/REL 스키마에 올라가므로, Kuzu 스키마를 다시 설계할 필요 없음.

GraphIndex류(called_by, routes_by_path, request_flow_index)는

v1: 쿼리로 계산

v2: 자주 쓰는 것만 cache table로 머티리얼라이즈
이런 2단계 전략으로 가면 됨.
