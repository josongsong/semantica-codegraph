Semantica v2: Chunking Layer 실행 계획서 (Execution Plan v2.0 – 최신 맥락 반영본)

본 문서는 기존 Chunking Layer 구현 계획을,
현재까지 구현된 내용(Phase A/B/C, ChunkStore, Index/RepoMap 연동, Kuzu 미사용) 기준으로 재정리한 최신 버전임.

1. 목표 및 역할
1-1. 핵심 목표

Tree-sitter / IR / Graph 결과를 기반으로 Symbol-first 6단계 Chunk 계층 생성

Repo → Project → Module → File → Class → Function(Leaf)

각 Chunk에 대해

안정적인 ID(FQN 기반)

라인 span(start/end)

심볼/그래프 매핑

요약(summary) 및 중요도(importance) hook
를 제공

증분 갱신(Incremental):

파일 추가/삭제/수정

rename / span drift

git diff 기반 partial update

상위 레이어(RepoMap, Index, Retriever)가 사용할 수 있는
“LLM 친화적인 코드 단위(Chunk)”를 안정적으로 공급하는 것이 최종 목적임.

1-2. 아키텍처에서 위치

src/foundation/parsing → AST

src/foundation/ir → IR v4

src/foundation/graph → GraphDocument(Kuzu)

src/foundation/chunk → Chunk Layer (본 문서 대상)

src/repomap → Chunk 계층 위에 프로젝트 지도(트리+중요도+요약)

src/index → Chunk 기반 IndexDocument 생성 (Zoekt/Qdrant 등)

src/retriever → Chunk/RepoMap/Index를 read-only로 소비

2. Chunk 도메인 모델 및 저장소
2-1. Chunk 모델 (Pydantic)
from typing import Any, Literal
from pydantic import BaseModel

class Chunk(BaseModel):
    chunk_id: str
    repo_id: str
    project_id: str | None
    module_path: str | None
    file_path: str | None

    kind: Literal[
        "repo", "project", "module", "file",
        "class", "function",
    ]

    fqn: str                      # dotted name (module.Class.method)

    # 현재 스냅샷 기준 라인 범위
    start_line: int | None
    end_line: int | None

    # 원본 라인 범위 (span drift 추적용)
    original_start_line: int | None
    original_end_line: int | None

    content_hash: str | None      # 청크 코드 해시

    parent_id: str | None
    children: list[str]

    language: str | None          # "python", "typescript" 등
    symbol_visibility: str | None # "public" | "internal" | "private" 등

    symbol_id: str | None         # 이 chunk가 표현하는 symbol
    symbol_owner_id: str | None   # 실제 정의 위치 symbol (재-export/wrapper 등)

    summary: str | None
    importance: float | None
    attrs: dict[str, Any] = {}

2-2. ChunkStore 저장소 (최신 결정)

ChunkStore = Postgres 전용

그래프/관계 데이터(Kuzu)는 사용하지 않음

ChunkStore는 “텍스트 + 메타” 저장 레이어

개념적 스키마(요약):

CREATE TABLE chunks (
  repo_id      TEXT NOT NULL,
  snapshot_id  TEXT NOT NULL,
  chunk_id     TEXT NOT NULL,
  file_path    TEXT,
  kind         TEXT NOT NULL,
  fqn          TEXT NOT NULL,
  parent_id    TEXT,
  start_line   INTEGER,
  end_line     INTEGER,
  original_start_line INTEGER,
  original_end_line   INTEGER,
  content_hash TEXT,
  language     TEXT,
  symbol_visibility TEXT,
  symbol_id    TEXT,
  symbol_owner_id TEXT,
  summary      TEXT,
  importance   DOUBLE PRECISION,
  attrs        JSONB NOT NULL DEFAULT '{}'::jsonb,
  is_deleted   BOOLEAN NOT NULL DEFAULT FALSE,
  version      INTEGER NOT NULL DEFAULT 1,
  last_indexed_commit TEXT,
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (repo_id, snapshot_id, chunk_id)
);


원본 파일(전체 텍스트)은 workspace 파일시스템에 그대로 두고,
ChunkStore에는 “chunk 범위 코드 + 메타”만 저장.

3. 구현 상태 요약 (Phase A/B/C)
3-1. Phase A – Chunk 계층 + 기본 증분 (완료)

모델 & ID Generator

Chunk 모델, ChunkRefreshResult, ChunkDiffType 정의

ChunkIdGenerator 구현 (repo_id + kind + fqn 기반, 필요시 hash suffix)

6단계 계층 빌더

ChunkBuilder

_build_repo_chunk

_build_project_chunks

_build_module_chunks

_build_file_chunks

_build_class_chunks

_build_function_chunks

Boundary Validation

ChunkBoundaryValidator

sibling gap/overlap 검출

invalid range 검출

large class detection (토큰 기준)

IR/Graph 매핑

ChunkMapper.map_ir

라인 범위 기반 IRNode 매핑

ChunkGraphMapper.map_graph

Leaf chunk: symbol 1:1

상위 chunk: 하위 chunk 집계

GraphNodeFilter

function/class/method 등만 포함, local var 등은 제외

증분 업데이트 (기본)

ChunkIncrementalRefresher

added/deleted/modified 파일 각각 처리

content_hash 기반 스킵 최적화

soft delete (is_deleted 플래그)

3-2. Phase B – Span Drift / Rename / Hooks (완료)

Span Drift Tracking

SPAN_DRIFT_THRESHOLD (기본 10라인)

original_start_line/original_end_line 유지

라인 이동량이 threshold 초과 시 drift로 판정

ChunkRefreshResult.drifted_chunks 채움

ChunkUpdateHook.on_chunk_drifted() 호출

Chunk-level Rename Detection

조건:

content_hash 동일

fqn 변경

동일 파일 내 이동

old_id → new_id 매핑 생성 (renamed_chunks)

버전 넘버 증가

ChunkUpdateHook.on_chunk_renamed(old_id, new_chunk) 호출

LLM Summary / Importance Hook

ChunkUpdateHook Protocol:

on_chunk_modified(chunk)

on_chunk_drifted(chunk)

on_chunk_renamed(old_id, chunk)

IncrementalRefresher가 각 이벤트마다 hook 호출 →
상위 레이어(RepoMap/Index)에서 LLM 요약/중요도 업데이트 트리거 가능

3-3. Phase C – Diff 기반 Partial Update (완료)

DiffHunk

unified diff 형식 hunk를 표현하는 데이터클래스

affected_old_range(), affected_new_range() 제공

DiffParser

Git unified diff 파싱

@@ -old_start,old_count +new_start,new_count @@ 헤더 파싱

부분 업데이트 지원

ChunkIncrementalRefresher:

use_partial_updates 플래그

refresh_files(..., file_diffs=...)

_handle_modified_file_partial()

_identify_affected_chunks() (span overlap로 영향 chunk 탐지)

DiffHunk 없거나, 영향 chunk 없으면 full 처리로 Fallback

이로써 큰 파일 일부 변경 시에도 전체 재청킹 없이 필요한 chunk만 재생성 가능.

4. Chunk 계층/ID/Boundary/매핑 – 최신 기준
4-1. FQN & Chunk ID 규칙

FQN 예시:

semantica.indexing.hybrid.HybridRetriever.retrieve

Chunk ID:

기본: chunk:{repo_id}:{kind}:{fqn}

충돌 시: chunk:{repo_id}:{kind}:{fqn}:{content_hash_prefix}

4-2. 계층 구조 (6단계)

repo → project → module → file → class → function

LeafChunk = function/method 단위 (RAG 최소 단위)

ParentChunk = file/module/project/repo

4-3. Boundary 규칙

동일 parent 아래 chunk 간 overlap 금지, gap은 정책에 따라 허용/경고

Large class는 flatten 옵션:

class chunk는 summary-only

method leaf chunk를 실제 RAG 단위로 사용

4-4. IR/Graph 매핑

Chunk → IRNode: span 포함 여부로 결정

Chunk → GraphNode:

leaf: symbol 1:1

class/file/module/project: 하위 chunk 집계 + GraphNodeFilter

5. 증분 정책 (최신 요약)

파일 추가

새 파일에 대해 ChunkBuilder 전체 실행

ChunkStore에 insert

Index/RepoMap hook 호출

파일 삭제

ChunkStore에서 is_deleted = true

Index/RepoMap 측에 delete 이벤트 발생

파일 수정

Git diff 기반 partial update 우선

영향 Chunk만 재생성/갱신

span drift / rename / content change 각각에 대해 hook 호출

rename / 이동 / span drift

rename: fqn 변경 + content 동일

drift: 라인 이동량 threshold 초과

두 경우 모두 Chunk ID, summary, importance 처리 방식을 Hook에서 제어 가능

6. 상위 레이어 연동 포인트
6-1. RepoMap Layer

RepoMap 트리는 Chunk 계층 위에 얹히는 구조

ParentChunk(파일/모듈/프로젝트) ↔ RepoMapNode 1:1 또는 N:1 매핑

Chunk importance → RepoMap importance 집계에 활용 가능

ChunkUpdateHook 이벤트 기반으로:

중요 subtree만 재요약

중요도 재계산 대상만 선택적으로 반영

6-2. Index Layer

Chunk → IndexDocument 변환 시 사용 필드:

chunk.summary

file_path, fqn, language

attrs (e.g. is_test, route, entrypoint 등)

ChunkIncrementalRefresher의 ChunkRefreshResult:

added_chunks / updated_chunks / deleted_chunks / renamed_chunks / drifted_chunks

Lexical/Vector/Symbol/Fuzzy/Domain 인덱스에서 부분 업데이트에 그대로 사용

6-3. Retriever

chunk_id 기반으로 ChunkStore 조회

leaf chunk + 상위 chunk 조합으로 context window 구성

span drift/rename 이벤트를 Retriever가 인지할 수 있도록 stable_symbol_id + chunk_id 매핑 유지

7. 실행 순서 (Chunk Layer 관점 최종)

Chunk 모델 / ChunkStore(Postgres) 스키마 정리

ChunkIdGenerator 및 FQN 규칙 확정

ChunkBuilder(6단계 계층) + BoundaryValidator

ChunkMapper / ChunkGraphMapper(집계 + 필터)

ChunkIncrementalRefresher (basic)

Span Drift / Rename Detection + ChunkUpdateHook

DiffHunk / DiffParser + partial update 완성

RepoMap / Index Layer와 Hook 기반 연동
