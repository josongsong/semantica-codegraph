결론 먼저

지금 플랜 → 내가 준 스키마랑 정합됨.

증분 업데이트 / LLM 쿼리 특화 요구사항은 거의 다 충족하고,

딱 하나만 추가하면 완전 깔끔함: snapshot_id(= commit) 버저닝 컬럼.

아래에 최종 스키마 + 요구사항 매핑 정리함.

최종 DB 스키마 정리 (Chunk Layer 전용, Postgres 기준)

2-1. chunks

플랜의 Chunk Pydantic 모델 그대로 맵핑한 메인 테이블.

CREATE TABLE chunks (
  chunk_id            TEXT PRIMARY KEY,        -- chunk:{repo_id}:{kind}:{fqn}...
  repo_id             TEXT NOT NULL,
  project_id          TEXT,
  module_path         TEXT,
  file_path           TEXT,

  kind                TEXT NOT NULL,          -- repo | project | module | file | class | function
  fqn                 TEXT NOT NULL,

  start_line          INTEGER,
  end_line            INTEGER,
  original_start_line INTEGER,
  original_end_line   INTEGER,

  content_hash        TEXT,

  parent_id           TEXT REFERENCES chunks(chunk_id),
  language            TEXT,
  symbol_visibility   TEXT,                   -- public | internal | private

  symbol_id           TEXT,                   -- GraphNodeId
  symbol_owner_id     TEXT,

  summary             TEXT,
  importance          DOUBLE PRECISION,

  attrs               JSONB DEFAULT '{}'::jsonb,

  -- 증분/버저닝용 (추가 권장)
  snapshot_id         TEXT                    -- git commit hash 등 (옵션: NOT NULL)
);

CREATE INDEX idx_chunks_repo_kind_fqn
  ON chunks(repo_id, kind, fqn);

CREATE INDEX idx_chunks_file_path
  ON chunks(repo_id, file_path);

CREATE INDEX idx_chunks_parent
  ON chunks(parent_id);

CREATE INDEX idx_chunks_snapshot
  ON chunks(repo_id, file_path, snapshot_id);


2-2. chunk_hierarchy

ChunkHierarchy: parent -> children 전개용.

CREATE TABLE chunk_hierarchy (
  parent_chunk_id  TEXT NOT NULL REFERENCES chunks(chunk_id),
  child_chunk_id   TEXT NOT NULL REFERENCES chunks(chunk_id),
  depth            INTEGER NOT NULL,
  position         INTEGER NOT NULL,
  PRIMARY KEY (parent_chunk_id, child_chunk_id)
);

CREATE INDEX idx_chunk_hierarchy_child
  ON chunk_hierarchy(child_chunk_id);


2-3. chunk_ir_map

ChunkToIR 맵.

CREATE TABLE chunk_ir_map (
  chunk_id   TEXT NOT NULL REFERENCES chunks(chunk_id),
  ir_node_id TEXT NOT NULL,
  PRIMARY KEY (chunk_id, ir_node_id)
);

CREATE INDEX idx_chunk_ir_map_ir
  ON chunk_ir_map(ir_node_id);


2-4. chunk_graph_map

ChunkToGraph 맵 (Kuzu graph_node.node_id와 브릿지).

CREATE TABLE chunk_graph_map (
  chunk_id      TEXT NOT NULL REFERENCES chunks(chunk_id),
  graph_node_id TEXT NOT NULL,           -- Kuzu graph_node.node_id
  PRIMARY KEY (chunk_id, graph_node_id)
);

CREATE INDEX idx_chunk_graph_map_graph
  ON chunk_graph_map(graph_node_id);


2-5. LLM 특화 search_text 캐시 (옵션이지만 강추)

ALTER TABLE chunks
  ADD COLUMN search_text TEXT;

CREATE INDEX idx_chunks_search_text_gin
  ON chunks
  USING gin (to_tsvector('simple', search_text));


요구사항 매핑 체크

3-1. 6단계 계층 / Symbol-first

계층: kind + parent_id + chunk_hierarchy.depth/position

repo / project / module / file / class / function 전부 표현 가능

Symbol-first:

symbol_id / symbol_owner_id로 그래프 심볼과 직접 연결

Leaf(function) 청크 = symbol 1:1, 상위는 집계

→ 계획서의 6단계 구조 그대로 충족.

3-2. IR / Graph 매핑

IR: chunk_ir_map(chunk_id, ir_node_id)

Graph: chunk_graph_map(chunk_id, graph_node_id)

→ 플랜의 ChunkToIR, ChunkToGraph 요구사항 그대로.

3-3. 증분 업데이트

플랜:

refresh(repo_id, prev_commit, curr_commit, changed_files)

old_chunks = get_chunks(..., prev_commit)

new_chunks = build(..., curr_commit)

_apply_diff(...)

이걸 DB로 구현하려면:

snapshot_id를 commit hash로 쓰면 됨.

get_chunks(repo_id, file_path, prev_commit) → snapshot_id = prev_commit 필터

diff 기준:

chunk_id (FQN 기반 logical ID)

content_hash / start_line / end_line

전략 두 가지 중 하나 고르면 됨.

단일 스냅샷만 유지 (간단)

DB에는 항상 최신 snapshot_id만 저장

prev 상태는 인덱서 내부 캐시나 별도 스토어에서 가져옴

현재 스키마 그대로 사용 가능

복수 스냅샷 저장 (정석)

PRIMARY KEY(chunk_id, snapshot_id)로 바꾸거나,
별도 chunk_versions 테이블 두고 관리

then prev_commit/curr_commit 모두 DB에서 조회해 diff

MVP 기준으로는 1)로 충분함.
나중에 “옛 커밋 기준 검색”까지 하려면 2)로 확장.

3-4. LLM 쿼리 특화

LLM 쪽 요구사항:

Symbol-first leaf chunk (함수/메서드 단위)

상위 구조 chunk (파일/모듈/프로젝트/레포)로 Parent/Leaf context 구성

summary / importance / search_text / language / visibility

그래프 확장 결과를 chunk로 투영 가능

스키마 대응:

summary, importance, search_text, language, symbol_visibility

chunk_hierarchy + parent_id로 상위/하위 청크 묶기

chunk_graph_map으로 GraphRAG 확장 결과 → 관련 청크 세트로 매핑

chunk_ir_map으로 정적 분석 결과와도 바로 연결

→ LLM/RAG 관점 요구사항 충족.

최종 코멘트

“Chunking Plan 문서” 기준으로 보면

모델 구조, 매핑 구조, 계층 구조, 증분 전략, LLM hook까지 스키마로 다 드러난 상태임.

증분/버저닝을 얼마나 깊게 가져갈지에 따라

snapshot_id를 단순 컬럼로 둘지

PK에 포함하거나 버전 테이블을 나눌지 정도만 결정하면 됨.

정리하면:

MVP + 증분 + LLM 쿼리 특화 관점에서는 지금 스키마로 충분하고,

나중에 “옛 커밋 기준 타임머신 검색”까지 하고 싶으면
snapshot_id 기반 버전 관리만 한 단계 더 확장하면 된다 정도로 보면 됨.
