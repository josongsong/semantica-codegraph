# Agent Mode FSM: 설계 & 구현

**목표**: 22개 모드 간 유기적 전환을 위한 FSM 구현

---

## 🔄 FSM 핵심 설계

### 1. 상태 정의

```python
from enum import Enum
from dataclasses import dataclass, field
from typing import Optional, Callable

class AgentMode(str, Enum):
    """Agent operating modes"""

    # Phase 0: Core
    IDLE = "idle"
    CONTEXT_NAV = "context_navigation"
    IMPLEMENTATION = "implementation"
    DEBUG = "debug"
    TEST = "test"
    DOCUMENTATION = "documentation"

    # Phase 1: Advanced
    DESIGN = "design"
    QA = "qa"
    REFACTOR = "refactor"
    MULTI_FILE = "multi_file_editing"
    GIT = "git_workflow"
    PLANNING = "agent_planning"
    IMPACT = "impact_analysis"

    # Phase 2: Specialization
    MIGRATION = "migration"
    DEPENDENCY = "dependency_intelligence"
    SPEC_COMPLIANCE = "spec_compliance"
    VERIFICATION = "verification"
    PROFILING = "performance_profiling"

    # Phase 3: Advanced Specialization
    OPS = "ops_infra"
    ENV_REPRO = "environment_reproduction"
    BENCHMARK = "benchmark"
    ML_INTEGRATION = "ml_integration"
    RESEARCH = "exploratory_research"
```

---

### 2. 전환 규칙 (Transition Rules)

```python
@dataclass
class Transition:
    """모드 전환 규칙"""

    from_mode: AgentMode
    to_mode: AgentMode
    trigger: str                                        # 전환 트리거 (intent, error, completion 등)
    condition: Optional[Callable[[dict], bool]] = None  # 전환 조건 (optional)
    priority: int = 0                                   # 우선순위 (높을수록 우선)

class ModeTransitionRules:
    """모드 전환 규칙 정의"""

    TRANSITIONS = [
        # IDLE → 작업 시작
        Transition(AgentMode.IDLE, AgentMode.CONTEXT_NAV, trigger="search_intent", priority=10),
        Transition(AgentMode.IDLE, AgentMode.IMPLEMENTATION, trigger="code_intent", priority=10),
        Transition(AgentMode.IDLE, AgentMode.DEBUG, trigger="error_intent", priority=10),
        Transition(AgentMode.IDLE, AgentMode.DESIGN, trigger="design_intent", priority=10),

        # CONTEXT_NAV → 다음 단계
        Transition(AgentMode.CONTEXT_NAV, AgentMode.IMPLEMENTATION, trigger="target_found", priority=9),
        Transition(AgentMode.CONTEXT_NAV, AgentMode.DEBUG, trigger="bug_located", priority=9),
        Transition(AgentMode.CONTEXT_NAV, AgentMode.DESIGN, trigger="architecture_needed", priority=8),

        # DESIGN → 구현
        Transition(AgentMode.DESIGN, AgentMode.IMPLEMENTATION, trigger="design_approved", priority=9),
        Transition(AgentMode.DESIGN, AgentMode.MULTI_FILE, trigger="large_change_planned", priority=9),

        # IMPLEMENTATION → 검증 및 리젝션 처리
        Transition(AgentMode.IMPLEMENTATION, AgentMode.TEST, trigger="code_complete", priority=9),
        Transition(AgentMode.IMPLEMENTATION, AgentMode.DEBUG, trigger="error_occurred", priority=10),
        Transition(AgentMode.IMPLEMENTATION, AgentMode.DOCUMENTATION, trigger="doc_needed", priority=7),
        Transition(AgentMode.IMPLEMENTATION, AgentMode.QA, trigger="review_needed", priority=8),
        Transition(AgentMode.IMPLEMENTATION, AgentMode.CONTEXT_NAV, trigger="rejected", priority=10),  # 승인 거절 시

        # DEBUG → 수정
        Transition(AgentMode.DEBUG, AgentMode.IMPLEMENTATION, trigger="fix_identified", priority=9),
        Transition(AgentMode.DEBUG, AgentMode.TEST, trigger="reproduce_needed", priority=8),
        Transition(AgentMode.DEBUG, AgentMode.IMPACT, trigger="impact_check_needed", priority=8),

        # TEST → 다음 단계
        Transition(AgentMode.TEST, AgentMode.IMPLEMENTATION, trigger="test_failed", priority=10),
        Transition(AgentMode.TEST, AgentMode.QA, trigger="tests_passed", priority=9),

        # QA → 개선/완료
        Transition(AgentMode.QA, AgentMode.REFACTOR, trigger="improvement_needed", priority=8),
        Transition(AgentMode.QA, AgentMode.IMPLEMENTATION, trigger="issues_found", priority=9),
        Transition(AgentMode.QA, AgentMode.GIT, trigger="approved", priority=9),

        # REFACTOR → 검증
        Transition(AgentMode.REFACTOR, AgentMode.TEST, trigger="refactor_complete", priority=9),
        Transition(AgentMode.REFACTOR, AgentMode.MULTI_FILE, trigger="large_refactor", priority=8),

        # MULTI_FILE → 검증/완료
        Transition(AgentMode.MULTI_FILE, AgentMode.IMPACT, trigger="impact_check", priority=9),
        Transition(AgentMode.MULTI_FILE, AgentMode.TEST, trigger="changes_ready", priority=9),
        Transition(AgentMode.MULTI_FILE, AgentMode.GIT, trigger="commit_ready", priority=8),

        # IMPACT → 조치
        Transition(AgentMode.IMPACT, AgentMode.TEST, trigger="affected_tests", priority=9),
        Transition(AgentMode.IMPACT, AgentMode.IMPLEMENTATION, trigger="additional_fixes", priority=8),

        # GIT → 완료
        Transition(AgentMode.GIT, AgentMode.IDLE, trigger="committed", priority=9),

        # PLANNING → 실행 모드
        Transition(AgentMode.PLANNING, AgentMode.IMPLEMENTATION, trigger="plan_ready", priority=9),
        Transition(AgentMode.PLANNING, AgentMode.MULTI_FILE, trigger="complex_plan", priority=9),
        Transition(AgentMode.PLANNING, AgentMode.MIGRATION, trigger="migration_plan", priority=8),
    ]

    @classmethod
    def get_transitions_from(cls, mode: AgentMode) -> list[Transition]:
        """특정 모드에서 가능한 전환들"""
        return [t for t in cls.TRANSITIONS if t.from_mode == mode]

    @classmethod
    def get_best_transition(
        cls,
        current_mode: AgentMode,
        trigger: str,
        context: dict
    ) -> Optional[Transition]:
        """현재 상황에 가장 적합한 전환"""
        candidates = [
            t for t in cls.TRANSITIONS
            if t.from_mode == current_mode and t.trigger == trigger
        ]

        # 조건 검사
        valid = [
            t for t in candidates
            if t.condition is None or t.condition(context)
        ]

        # 우선순위 정렬
        if valid:
            return max(valid, key=lambda t: t.priority)

        return None
```

---

### 3. FSM 엔진

```python
from typing import Protocol

class ModeHandler(Protocol):
    """각 모드의 핸들러 인터페이스"""

    async def enter(self, context: ModeContext) -> None:
        """모드 진입 시 호출"""
        ...

    async def execute(self, task: Task, context: ModeContext) -> Result:
        """모드 실행"""
        ...

    async def exit(self, context: ModeContext) -> None:
        """모드 종료 시 호출"""
        ...

class AgentFSM:
    """Agent Finite State Machine"""

    def __init__(self):
        self.current_mode = AgentMode.IDLE
        self.mode_handlers: dict[AgentMode, ModeHandler] = {}
        self.context = ModeContext()
        self.transition_history: list[tuple[AgentMode, AgentMode, str]] = []

    def register_handler(self, mode: AgentMode, handler: ModeHandler):
        """모드 핸들러 등록"""
        self.mode_handlers[mode] = handler

    async def transition(self, trigger: str, task: Optional[Task] = None) -> bool:
        """모드 전환 시도"""

        # 전환 규칙 확인
        transition = ModeTransitionRules.get_best_transition(
            current_mode=self.current_mode,
            trigger=trigger,
            context=self.context.to_dict()
        )

        if not transition:
            logger.warning(f"No valid transition from {self.current_mode} with trigger '{trigger}'")
            return False

        # 현재 모드 종료
        current_handler = self.mode_handlers.get(self.current_mode)
        if current_handler:
            await current_handler.exit(self.context)

        # 전환 기록
        old_mode = self.current_mode
        self.current_mode = transition.to_mode
        self.transition_history.append((old_mode, self.current_mode, trigger))
        self.context.record_mode(self.current_mode)  # 컨텍스트에 모드 히스토리 기록

        logger.info(f"Mode transition: {old_mode} → {self.current_mode} (trigger: {trigger})")

        # 새 모드 진입
        new_handler = self.mode_handlers.get(self.current_mode)
        if new_handler:
            await new_handler.enter(self.context)

        return True

    async def execute(self, task: Task) -> Result:
        """현재 모드에서 작업 실행"""

        handler = self.mode_handlers.get(self.current_mode)
        if not handler:
            raise ValueError(f"No handler for mode {self.current_mode}")

        # 작업 실행
        result = await handler.execute(task, self.context)

        # 자동 전환 확인 (결과에 따라)
        if result.trigger:
            await self.transition(result.trigger, task)

        return result

    def get_available_transitions(self) -> list[Transition]:
        """현재 모드에서 가능한 전환들"""
        return ModeTransitionRules.get_transitions_from(self.current_mode)

    def suggest_next_mode(self, user_query: str, context: ModeContext) -> AgentMode:
        """다음 모드 제안 (ML 기반)"""
        # TODO: Intent classifier 통합
        # 현재는 규칙 기반
        if "테스트" in user_query:
            return AgentMode.TEST
        elif "리뷰" in user_query:
            return AgentMode.QA
        elif "리팩토링" in user_query:
            return AgentMode.REFACTOR
        # ... more rules

        return AgentMode.IDLE
```

---

### 4. 컨텍스트 관리

```python
@dataclass
class ModeContext:
    """모드 간 공유되는 컨텍스트"""

    # 작업 상태
    current_task: Optional[Task] = None
    current_files: list[str] = field(default_factory=list)
    current_symbols: list[str] = field(default_factory=list)

    # 그래프 컨텍스트 (Semantica 차별화)
    graph_doc: Optional[GraphDocument] = None
    impact_nodes: set[str] = field(default_factory=set)
    dependency_chain: list[str] = field(default_factory=list)

    # 실행 히스토리
    mode_history: list[AgentMode] = field(default_factory=list)
    action_history: list[Action] = field(default_factory=list)

    # 사용자 선호도
    approval_level: ApprovalLevel = ApprovalLevel.MEDIUM
    auto_test: bool = True
    auto_commit: bool = False

    # 대기 중인 변경사항
    pending_changes: list[Change] = field(default_factory=list)
    staged_files: list[str] = field(default_factory=list)

    # 테스트 결과
    last_test_results: Optional[TestResults] = None
    coverage_data: Optional[CoverageData] = None

    # 에러 컨텍스트
    last_error: Optional[Error] = None
    error_stack_trace: Optional[str] = None

    def add_file(self, file_path: str):
        """작업 파일 추가"""
        if file_path not in self.current_files:
            self.current_files.append(file_path)

    def add_change(self, change: Change):
        """변경사항 추가"""
        self.pending_changes.append(change)

    def record_mode(self, mode: AgentMode):
        """모드 전환 기록"""
        self.mode_history.append(mode)

    def to_dict(self) -> dict:
        """컨텍스트를 dict로 변환 (전환 조건 평가용)"""
        return {
            "has_pending_changes": len(self.pending_changes) > 0,
            "has_errors": self.last_error is not None,
            "test_passed": (
                self.last_test_results.all_passed
                if self.last_test_results
                else False
            ),
            "num_files": len(self.current_files),
            "is_large_change": len(self.current_files) > 5,
        }
```

---

## 🎯 Phase 0 Week 1 구현 계획

### **목표**: Context Navigation + Implementation 프로토타입

#### Day 1-2: FSM 기반 구조 구축

```
✅ 파일 구조:
src/agent/
├── __init__.py
├── fsm.py                    # AgentFSM, Transition, ModeContext
├── modes/
│   ├── __init__.py
│   ├── base.py              # ModeHandler protocol
│   ├── context_nav.py       # Context Navigation 모드
│   └── implementation.py    # Implementation 모드
├── intent/
│   ├── __init__.py
│   └── classifier.py        # Intent 분류 (기존 retriever/intent 재사용)
└── orchestrator.py          # 전체 조율

✅ 구현:
1. AgentFSM 엔진 (fsm.py)
2. ModeHandler protocol (modes/base.py)
3. 기본 전환 규칙 (IDLE → CONTEXT_NAV → IMPLEMENTATION)
```

#### Day 3-4: Context Navigation Mode

```python
class ContextNavigationMode(ModeHandler):
    """코드베이스 탐색 모드"""

    def __init__(
        self,
        graph_store,           # Kuzu graph
        search_service,        # 5-way hybrid search
        symbol_index,          # Symbol index
    ):
        self.graph_store = graph_store
        self.search_service = search_service
        self.symbol_index = symbol_index

    async def execute(self, task: Task, context: ModeContext) -> Result:
        """탐색 실행"""

        # 1. Intent 파싱
        intent = self._parse_intent(task.query)

        # 2. 검색 실행
        if intent.type == IntentType.SYMBOL_SEARCH:
            results = await self.symbol_index.search(intent.target)

        elif intent.type == IntentType.CALL_CHAIN:
            # 그래프 기반 call chain 추적
            results = await self._trace_call_chain(intent.target)

        elif intent.type == IntentType.DEPENDENCY:
            # 의존성 추적
            results = await self._trace_dependencies(intent.target)

        else:
            # 일반 코드 검색 (hybrid search)
            results = await self.search_service.search(intent.query)

        # 3. 컨텍스트 업데이트
        for result in results:
            context.add_file(result.file_path)
            if result.symbol_id:
                context.current_symbols.append(result.symbol_id)

        # 4. 다음 모드 제안
        trigger = "target_found" if results else None

        return Result(
            mode=AgentMode.CONTEXT_NAV,
            data=results,
            trigger=trigger,  # target_found → IMPLEMENTATION
            explanation=self._generate_explanation(results),
        )

    async def _trace_call_chain(self, symbol_fqn: str) -> list[ChunkResult]:
        """Call chain 추적 (그래프 기반)"""

        # Kuzu에서 CALLS 엣지 따라가기
        query = """
        MATCH path = (caller)-[:CALLS*1..5]->(callee)
        WHERE callee.fqn = $fqn
        RETURN path
        """
        paths = await self.graph_store.execute(query, {"fqn": symbol_fqn})

        # Path를 chunk로 변환
        chunks = []
        for path in paths:
            for node in path.nodes:
                chunk = await self._node_to_chunk(node)
                chunks.append(chunk)

        return chunks
```

#### Day 5: Implementation Mode

```python
class ImplementationMode(ModeHandler):
    """코드 구현 모드"""

    def __init__(
        self,
        llm_client,
        code_generator,        # Pattern-based generator
        test_generator,
    ):
        self.llm = llm_client
        self.generator = code_generator
        self.test_generator = test_generator

    async def execute(self, task: Task, context: ModeContext) -> Result:
        """코드 생성 실행"""

        # 1. 컨텍스트에서 관련 코드 가져오기
        related_code = await self._get_related_code(context)

        # 2. 코드 생성 (LLM + 패턴)
        generated_code = await self.generator.generate(
            task=task.description,
            context=related_code,
            patterns=self._select_patterns(task),
        )

        # 3. Human-in-the-Loop: 승인 요청
        if context.approval_level >= ApprovalLevel.MEDIUM:
            approved = await self._request_approval(generated_code, context)
            if not approved:
                return Result(mode=AgentMode.IMPLEMENTATION, trigger="rejected")

        # 4. 변경사항 적용
        changes = self._apply_code(generated_code)
        for change in changes:
            context.add_change(change)

        # 5. 다음 모드로 전환 (code_complete → TEST)
        # NOTE: context.auto_test는 TEST 모드 내부에서 테스트 자동 실행 여부로 사용
        return Result(
            mode=AgentMode.IMPLEMENTATION,
            data={"code": generated_code, "changes": changes},
            trigger="code_complete",  # code_complete → TEST (규칙 기반 전환)
            explanation=f"Generated {len(changes)} changes",
        )
```

---

## 📊 Week 1 마일스톤

### 테스트 시나리오

```python
# Scenario 1: "로그인 기능 어디 있어?"
async def test_context_navigation():
    fsm = AgentFSM()
    fsm.register_handler(AgentMode.CONTEXT_NAV, ContextNavigationMode(...))

    task = Task(query="로그인 기능 어디 있어?")

    # IDLE → CONTEXT_NAV
    await fsm.transition("search_intent", task)
    assert fsm.current_mode == AgentMode.CONTEXT_NAV

    # 실행
    result = await fsm.execute(task)

    # 결과 확인
    assert len(result.data) > 0
    assert any("login" in r.file_path.lower() for r in result.data)


# Scenario 2: "User 클래스에 validate_email 메서드 추가해줘"
async def test_implementation_flow():
    fsm = AgentFSM()
    fsm.register_handler(AgentMode.CONTEXT_NAV, ContextNavigationMode(...))
    fsm.register_handler(AgentMode.IMPLEMENTATION, ImplementationMode(...))

    # Step 1: User 클래스 찾기
    task1 = Task(query="User 클래스 찾아줘")
    await fsm.transition("search_intent", task1)
    result1 = await fsm.execute(task1)

    # Automatic transition: CONTEXT_NAV → IMPLEMENTATION
    assert fsm.current_mode == AgentMode.IMPLEMENTATION

    # Step 2: 메서드 추가
    task2 = Task(query="validate_email 메서드 추가해줘")
    result2 = await fsm.execute(task2)

    # 결과 확인
    assert len(result2.data["changes"]) > 0
    assert any("validate_email" in c.content for c in result2.data["changes"])
```

---

## 🚀 다음 단계 (Week 2)

1. **Debug Mode** 구현
2. **Test Mode** 구현
3. **Documentation Mode** 구현
4. **통합 테스트**: 전체 플로우 검증

---

## 📋 설계 검증 노트

### Week 1 스코프

- 본 FSM v0.1은 **Phase 0-1 모드** (IDLE, CONTEXT_NAV, IMPLEMENTATION, DEBUG, TEST, QA, REFACTOR, MULTI_FILE, GIT, PLANNING, IMPACT)만 전환 규칙을 구현
- **Phase 2-3 모드** (MIGRATION, DEPENDENCY, SPEC_COMPLIANCE, VERIFICATION, PROFILING, OPS, ENV_REPRO, BENCHMARK, ML_INTEGRATION, RESEARCH)는 `AgentMode`에만 등록된 상태이며, 전환 규칙은 후속 추가 예정

### 전환 패턴 분류

1. **명시적 전환** (Orchestrator가 호출)
   - 사용자 자연어 인텐트 → 시작 모드 전환
   - 예: `orchestrator.classify_intent()` → `fsm.transition("search_intent")`

2. **자동 전환** (모드 내부에서 발생)
   - 모드 작업 완료 → 다음 모드로 자동 전환
   - 예: `ImplementationMode.execute()` → `Result(trigger="code_complete")` → `AgentFSM`이 자동으로 `transition("code_complete")` 호출

### 최적화 고려사항

- **인덱싱**: 모드 수 증가 시 `ModeTransitionRules._index` 도입 권장 (현재는 선형 탐색)
- **조건 함수**: `Transition.condition`을 활용하면 컨텍스트 기반 동적 전환 가능
  ```python
  Transition(
      from_mode=AgentMode.IMPLEMENTATION,
      to_mode=AgentMode.MULTI_FILE,
      trigger="code_complete",
      condition=lambda ctx: ctx["is_large_change"],
      priority=9
  )
  ```

### Human-in-the-Loop 정책

- **승인 레벨**:
  - `ApprovalLevel.LOW`: 자동 실행
  - `ApprovalLevel.MEDIUM`: 코드 생성 시 승인 필요 (기본값)
  - `ApprovalLevel.HIGH`: 모든 작업에 승인 필요

- **거절 처리**: `trigger="rejected"` → `CONTEXT_NAV`로 돌아가 재탐색

---

**작성일**: 2024-11-25
**업데이트**: 2024-11-25 (코드 레벨 이슈 수정 완료)
**다음 업데이트**: Week 1 완료 시
