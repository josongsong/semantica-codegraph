# Agent Modes: Priority & Implementation Plan

**날짜**: 2024-11-25
**목표**: SOTA급 코드 에이전트를 위한 23개 모드 체계 구축

---

## 📊 모드 우선순위 분류

### Phase 0: Core Foundation (P0) - 5개 모드
**목표**: 기본 코딩 워크플로우 지원

| # | 모드 | 핵심 기능 | 근거 |
|---|------|----------|------|
| 1 | **Context Navigation** | 코드베이스 탐색, 파일 찾기, 플로우 추적 | 모든 작업의 선행 조건 |
| 2 | **Implementation** | 코드 작성, 완성, 통합 | 모든 AI IDE의 핵심 |
| 3 | **Debug** | 에러 분석, 근본 원인 찾기, 수정 제안 | 실무 필수 |
| 4 | **Test** | 테스트 생성, 실행, 커버리지 | 품질 보증 기본 |
| 5 | **Documentation** | 주석, README, API 문서 | 협업 필수 |

---

### Phase 1: Advanced Workflow (P1) - 7개 모드
**목표**: 전문가급 개발 워크플로우

| # | 모드 | 핵심 기능 | 근거 |
|---|------|----------|------|
| 6 | **Design** | 아키텍처 설계, API 설계, 트레이드오프 | 대규모 기능 개발 필수 |
| 7 | **QA** | 코드 리뷰, 보안 감사, 스타일 검사 | 엔터프라이즈 필수 |
| 8 | **Refactor** | 구조 개선, 패턴 적용, 기술 부채 제거 | 코드 유지보수 |
| 9 | **Multi-File Editing** | 대규모 변경, diff 관리, atomic change | 프로젝트 wide 작업 |
| 10 | **Git/Workflow** | Commit, PR, conflict 해결 | 실무 필수 |
| 11 | **Agent Planning** | 멀티스텝 계획, DAG 관리 | 복잡한 작업 분해 |
| 12 | **Impact Analysis** | 변경 영향도, Program slicing | 안전한 변경 |

---

### Phase 2: Specialization (P2) - 5개 모드
**목표**: 특화된 전문 작업 지원

| # | 모드 | 핵심 기능 | 근거 |
|---|------|----------|------|
| 13 | **Migration** | 언어/프레임워크 전환, API 마이그레이션 | 현실적 수요 높음 |
| 14 | **Dependency Intelligence** | 의존성 분석, 취약점, 버전 충돌 | 엔터프라이즈 필수 |
| 15 | **Spec Compliance** | API 규약, 코딩 규칙 준수 검증 | Contract-first 개발 |
| 16 | **Verification** | 형식 검증, 타입/계약 체크 | 고신뢰성 요구 환경 |
| 17 | **Performance Profiling** | CPU/메모리, 병목 분석 | 최적화 작업 |

---

### Phase 3: Advanced Specialization (P3) - 5개 모드
**목표**: 고급 특화 영역

| # | 모드 | 핵심 기능 | 근거 |
|---|------|----------|------|
| 18 | **Ops/Infra** | Dockerfile, K8s, IaC 관리 | DevOps 통합 |
| 19 | **Environment Reproduction** | 환경 재현, 패키지 복구 | 디버깅 효율화 |
| 20 | **Benchmark** | 성능 벤치마크, 회귀 탐지 | 품질 자동화 |
| 21 | **Data/ML Integration** | Feature engineering, 모델 서빙 | ML 프로젝트 |
| 22 | **Exploratory Research** | 알고리즘 실험, 프로토타입 | 연구 개발 |

---

## 🔄 모드 전환 FSM (Finite State Machine)

### 전환 규칙

```mermaid
stateDiagram-v2
    [*] --> Idle

    Idle --> ContextNav: 코드 탐색 요청
    Idle --> Implementation: 코드 작성 요청
    Idle --> Debug: 에러 발생
    Idle --> Design: 설계 요청

    ContextNav --> Implementation: 대상 파일 찾음
    ContextNav --> Debug: 버그 위치 찾음
    ContextNav --> Design: 아키텍처 이해 필요

    Design --> Implementation: 설계 완료
    Design --> MultiFile: 대규모 변경 계획

    Implementation --> Test: 테스트 필요
    Implementation --> Debug: 에러 발생
    Implementation --> Documentation: 문서화 필요
    Implementation --> QA: 리뷰 필요

    Debug --> Implementation: 수정 필요
    Debug --> Test: 재현 테스트 작성
    Debug --> ImpactAnalysis: 영향 범위 확인

    Test --> Implementation: 테스트 실패 수정
    Test --> QA: 리뷰 준비

    QA --> Refactor: 개선 필요
    QA --> Implementation: 수정 필요
    QA --> Git: 승인 완료

    Refactor --> Test: 테스트 검증
    Refactor --> MultiFile: 대규모 리팩토링

    MultiFile --> Git: 변경 커밋
    MultiFile --> ImpactAnalysis: 영향도 확인

    ImpactAnalysis --> Test: 영향받는 테스트 실행
    ImpactAnalysis --> Implementation: 추가 수정 필요

    Documentation --> Git: 문서 커밋

    Git --> [*]: 완료

    note right of ContextNav
        모든 모드의 시작점
        코드 이해가 선행 조건
    end note

    note right of AgentPlanning
        복잡한 작업 시 자동 활성화
        여러 모드를 조율
    end note
```

### 모드 전환 컨텍스트 유지

```python
@dataclass
class ModeContext:
    """모드 전환 시 유지되는 컨텍스트"""

    # 현재 작업 컨텍스트
    current_files: list[str]           # 작업 중인 파일들
    current_symbols: list[str]         # 작업 중인 심볼들
    current_task: str                  # 현재 작업 설명

    # 히스토리
    mode_history: list[str]            # 모드 전환 이력
    action_history: list[dict]         # 수행한 액션들

    # 그래프 컨텍스트 (Semantica 차별화)
    impact_graph: GraphDocument        # 영향 받는 노드/엣지
    dependency_chain: list[str]        # 의존성 체인

    # 사용자 선호도
    approval_level: ApprovalLevel      # 자동승인 레벨
    preferred_patterns: list[str]      # 선호 패턴

    # 실행 상태
    pending_changes: list[Change]      # 대기 중인 변경
    test_results: TestResults          # 최근 테스트 결과
```

---

## 🎯 Phase별 구현 계획

### **Phase 0: Core Foundation** (4주)

#### Week 1-2: Context Navigation + Implementation
```
✅ 구현 항목:
- 코드베이스 탐색 (그래프 기반)
- 파일/심볼 검색 (5-way hybrid)
- Call chain 추적
- 코드 생성 (패턴 기반)
- 코드 완성

🎯 마일스톤: "Hello World" 에이전트
- 사용자: "로그인 기능 어디 있어?"
- 에이전트: Context Nav → 3개 파일 찾음 → 설명
```

#### Week 3: Debug + Test
```
✅ 구현 항목:
- Static analysis 통합
- 에러 근본 원인 분석
- 수정 제안 생성
- 테스트 케이스 생성
- Coverage 분석

🎯 마일스톤: "Fix Bug" 에이전트
- 사용자: "이 에러 고쳐줘"
- 에이전트: Debug → 근본 원인 → 수정안 제시 → 테스트 생성
```

#### Week 4: Documentation
```
✅ 구현 항목:
- 주석 생성 (함수/클래스)
- README 생성
- API 문서 생성
- 변경 요약 (Change Summary)

🎯 마일스톤: "Explain Code" 에이전트
- 사용자: "이 모듈 설명해줘"
- 에이전트: Context Nav → 핵심 파일 → 문서 생성
```

---

### **Phase 1: Advanced Workflow** (6주)

#### Week 5-6: Design + QA
```
✅ 구현 항목:
- 아키텍처 설계 (다중 옵션 생성)
- ADR 생성
- 코드 리뷰 (5단계)
- 보안 감사 (OWASP Top 10)
- 성능 anti-pattern 검출

🎯 마일스톤: "Design & Review" 에이전트
```

#### Week 7-8: Refactor + Multi-File Editing
```
✅ 구현 항목:
- 리팩토링 카탈로그 (Martin Fowler)
- 메트릭 기반 검증
- Multi-file change planning
- Atomic change set 관리
- Diff 생성 & apply

🎯 마일스톤: "Large-scale Refactor" 에이전트
```

#### Week 9-10: Git/Workflow + Agent Planning + Impact Analysis
```
✅ 구현 항목:
- Git 통합 (commit, PR, conflict)
- Commit 메시지 생성
- DAG 기반 task planning
- Program slicing
- Backward/Forward impact 분석

🎯 마일스톤: "Safe Change" 에이전트
- 변경 → 영향 분석 → 테스트 생성 → 커밋
```

---

### **Phase 2: Specialization** (4주)

#### Week 11-12: Migration + Dependency Intelligence
```
✅ 구현 항목:
- 언어/프레임워크 마이그레이션
- API contract 변경 전파
- 의존성 그래프 분석
- 취약점 스캔
- 버전 충돌 해결

🎯 마일스톤: "Safe Migration" 에이전트
```

#### Week 13-14: Spec Compliance + Verification + Performance
```
✅ 구현 항목:
- OpenAPI 규약 검증
- 코딩 규칙 준수 체크
- 타입/계약 형식 검증
- CPU/메모리 프로파일링
- Hot path 분석

🎯 마일스톤: "Quality Assurance" 에이전트
```

---

### **Phase 3: Advanced Specialization** (4주)

#### Week 15-18: Ops + Environment + Benchmark + ML + Research
```
✅ 구현 항목:
- Dockerfile/K8s 최적화
- 환경 재현 스크립트
- 성능 벤치마크 자동화
- Feature engineering 리뷰
- 알고리즘 실험 지원

🎯 마일스톤: "Full-stack AI Developer"
```

---

## 🧩 모드 전환 로직

### 자동 모드 전환 규칙

```python
class ModeSelector:
    """모드 자동 선택 로직"""

    def select_mode(self, user_intent: Intent, context: ModeContext) -> Mode:
        """사용자 의도에 따른 모드 선택"""

        # Rule-based selection (빠른 결정)
        if "찾아" in user_intent.query or "어디" in user_intent.query:
            return Mode.CONTEXT_NAV

        if "고쳐" in user_intent.query or "에러" in user_intent.query:
            return Mode.DEBUG

        if "만들어" in user_intent.query or "구현" in user_intent.query:
            # 대규모 변경인가?
            if self._is_large_change(user_intent):
                return Mode.MULTI_FILE_EDITING
            return Mode.IMPLEMENTATION

        if "테스트" in user_intent.query:
            return Mode.TEST

        if "리뷰" in user_intent.query or "검토" in user_intent.query:
            return Mode.QA

        if "리팩토링" in user_intent.query or "개선" in user_intent.query:
            return Mode.REFACTOR

        if "설계" in user_intent.query or "아키텍처" in user_intent.query:
            return Mode.DESIGN

        # ML-based fallback (복잡한 케이스)
        return self.ml_classifier.predict(user_intent, context)

    def _is_large_change(self, intent: Intent) -> bool:
        """대규모 변경 여부 판단"""
        keywords = ["전체", "모든", "프로젝트", "마이그레이션"]
        return any(kw in intent.query for kw in keywords)
```

### 모드 체인 (연속 전환)

```python
# Example: "로그인 기능 만들고 테스트 작성해줘"
mode_chain = [
    Mode.CONTEXT_NAV,      # 기존 로그인 관련 코드 찾기
    Mode.DESIGN,           # 로그인 설계
    Mode.IMPLEMENTATION,   # 코드 작성
    Mode.TEST,            # 테스트 작성
    Mode.QA,              # 리뷰
    Mode.GIT,             # 커밋
]

# Each mode passes context to next
for mode in mode_chain:
    context = mode.execute(context)
    if mode.requires_approval():
        await user.approve(context.changes)
```

---

## 📈 성공 메트릭

### Phase 0 (Core)
- ✅ Context Navigation 정확도 > 90%
- ✅ Implementation 코드 품질 스코어 > 80
- ✅ Debug 근본 원인 정확도 > 85%
- ✅ Test 커버리지 증가율 > 20%

### Phase 1 (Advanced)
- ✅ Design 옵션 다양성 > 3개
- ✅ QA 이슈 탐지율 > 90%
- ✅ Refactor 안전성 (테스트 통과율) > 95%
- ✅ Multi-file 변경 성공률 > 90%
- ✅ Impact Analysis 정확도 > 85%

### Phase 2 (Specialization)
- ✅ Migration 성공률 > 80%
- ✅ Dependency 이슈 탐지율 > 95%
- ✅ Spec Compliance 정확도 > 90%

### Phase 3 (Advanced)
- ✅ Ops 최적화 효과 측정
- ✅ Benchmark 회귀 탐지율 > 95%

---

## 🎨 Semantica의 차별화 포인트

각 모드에서 **그래프 기반 지능** 활용:

| 모드 | 그래프 활용 |
|------|------------|
| Context Nav | Call chain 추적, 의존성 그래프 탐색 |
| Debug | Backward slicing (에러 원인 추적) |
| Test | Forward slicing (영향받는 코드) |
| Impact Analysis | GraphDocument의 영향 범위 계산 |
| Refactor | 안전한 rename (모든 참조 추적) |
| Migration | API 변경 전파 경로 시각화 |
| Dependency | 의존성 그래프 분석 |

**→ 다른 AI IDE는 AST 레벨, Semantica는 Semantic Graph 레벨!**

---

## 📝 다음 단계

1. **Phase 0 시작**: Context Navigation + Implementation 프로토타입
2. **FSM 구현**: 모드 전환 로직 구현
3. **Human-in-the-Loop**: 각 모드별 승인 단계 통합
4. **테스트**: 실제 사용 시나리오 검증

**시작 파일**: `src/agent/modes/` 디렉토리 생성 후 각 모드별 구현

---

**작성일**: 2024-11-25
**다음 업데이트**: Phase 0 Week 1 완료 시
