
Parallel Planning 완전 설계
왜 Parallel Planning이 필요한가?
현재 문제 (순차적 플래닝):
├── 첫 번째 플랜 실패 → 처음부터 재시작
├── 최적 해결책 놓칠 수 있음
├── 단일 관점으로만 문제 접근
├── 복잡한 문제에서 시간 낭비
└── 확신도 낮은 결정에도 all-in

Parallel Planning 장점:
├── 여러 가설 동시 탐색
├── 빠른 가지치기로 효율성 향상
├── 다양한 관점에서 문제 접근
├── 실패 시 즉시 대안 실행
└── 최적 해결책 선택 확률 증가

1. Parallel Planning 아키텍처
┌─────────────────────────────────────────────────────────────────┐
│                    Parallel Planning System                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                      ┌─────────────┐                            │
│                      │   Task      │                            │
│                      └──────┬──────┘                            │
│                             │                                    │
│                             ▼                                    │
│                   ┌─────────────────┐                           │
│                   │ Hypothesis      │                           │
│                   │ Generator       │                           │
│                   └────────┬────────┘                           │
│                            │                                     │
│           ┌────────────────┼────────────────┐                   │
│           ▼                ▼                ▼                   │
│    ┌────────────┐   ┌────────────┐   ┌────────────┐            │
│    │ Hypothesis │   │ Hypothesis │   │ Hypothesis │            │
│    │     A      │   │     B      │   │     C      │            │
│    └─────┬──────┘   └─────┬──────┘   └─────┬──────┘            │
│          │                │                │                    │
│          ▼                ▼                ▼                    │
│    ┌────────────┐   ┌────────────┐   ┌────────────┐            │
│    │  Planner   │   │  Planner   │   │  Planner   │            │
│    │     A      │   │     B      │   │     C      │            │
│    └─────┬──────┘   └─────┬──────┘   └─────┬──────┘            │
│          │                │                │                    │
│          ▼                ▼                ▼                    │
│    ┌────────────┐   ┌────────────┐   ┌────────────┐            │
│    │  Executor  │   │  Executor  │   │  Executor  │            │
│    │  (Partial) │   │  (Partial) │   │  (Partial) │            │
│    └─────┬──────┘   └─────┬──────┘   └─────┬──────┘            │
│          │                │                │                    │
│          └────────────────┼────────────────┘                    │
│                           ▼                                     │
│                   ┌─────────────────┐                           │
│                   │    Evaluator    │                           │
│                   │   & Selector    │                           │
│                   └────────┬────────┘                           │
│                            │                                     │
│                            ▼                                     │
│                   ┌─────────────────┐                           │
│                   │  Best Branch    │                           │
│                   │  Full Execution │                           │
│                   └─────────────────┘                           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

2. Hypothesis Generator
다양한 접근 방식을 생성한다.
typescriptinterface Hypothesis {
  id: string;
  
  // 기본 정보
  description: string;
  approach_type: ApproachType;
  
  // 가정
  assumptions: Assumption[];
  
  // 예상 경로
  expected_steps: string[];
  expected_tools: string[];
  
  // 평가 지표
  estimated_confidence: number;     // 0-1
  estimated_complexity: number;     // 0-1
  estimated_risk: number;           // 0-1
  estimated_tokens: number;
  
  // 메타데이터
  generation_method: 'llm' | 'pattern' | 'memory' | 'variation';
  parent_hypothesis?: string;       // 변형인 경우 원본
}

enum ApproachType {
  DIRECT_FIX = 'direct_fix',           // 직접 수정
  MINIMAL_CHANGE = 'minimal_change',    // 최소 변경
  COMPREHENSIVE = 'comprehensive',      // 포괄적 리팩토링
  TEST_DRIVEN = 'test_driven',          // 테스트 먼저
  INCREMENTAL = 'incremental',          // 단계적 접근
  WORKAROUND = 'workaround',            // 우회 해결
  ROOT_CAUSE = 'root_cause',            // 근본 원인 해결
}

class HypothesisGenerator {
  private llm: LLMClient;
  private memorySystem: MemoryRetrievalSystem;
  private patternMatcher: PatternMatcher;

  // 2-1. 메인 생성 로직
  async generate(task: Task, context: Context): Promise<Hypothesis[]> {
    const hypotheses: Hypothesis[] = [];
    
    // 병렬로 여러 소스에서 가설 생성
    const [
      llmHypotheses,
      memoryHypotheses,
      patternHypotheses,
    ] = await Promise.all([
      this.generateFromLLM(task, context),
      this.generateFromMemory(task, context),
      this.generateFromPatterns(task, context),
    ]);
    
    hypotheses.push(...llmHypotheses);
    hypotheses.push(...memoryHypotheses);
    hypotheses.push(...patternHypotheses);
    
    // 변형 생성 (기존 가설의 변형)
    const variations = this.generateVariations(hypotheses, task);
    hypotheses.push(...variations);
    
    // 중복 제거 및 다양성 보장
    const diversified = this.ensureDiversity(hypotheses);
    
    // 초기 평가 및 정렬
    const evaluated = await this.initialEvaluation(diversified, task, context);
    
    // 상위 N개 선택
    return this.selectTopHypotheses(evaluated, this.config.maxParallelBranches);
  }

  // 2-2. LLM 기반 가설 생성
  private async generateFromLLM(task: Task, context: Context): Promise<Hypothesis[]> {
    const prompt = `Analyze this coding task and generate 3 different approaches to solve it.

Task: ${task.description}
${task.error ? `Error: ${task.error.message}\nStack: ${task.error.stack_trace}` : ''}

Context:
- Files involved: ${context.files.map(f => f.path).join(', ')}
- Main symbols: ${context.symbols.map(s => s.name).join(', ')}

For each approach, provide:
1. Approach type (direct_fix, minimal_change, comprehensive, test_driven, incremental, workaround, root_cause)
2. Description of the approach
3. Key assumptions being made
4. Expected steps
5. Estimated confidence (0-1)
6. Estimated risk (0-1)

Consider:
- Different root causes the problem might have
- Trade-offs between quick fixes and thorough solutions
- Different starting points for investigation

Respond in JSON format with an array of hypotheses.`;

    const response = await this.llm.complete(prompt);
    const parsed = JSON.parse(response);
    
    return parsed.map((h: any) => ({
      id: generateId(),
      description: h.description,
      approach_type: h.approach_type,
      assumptions: h.assumptions.map((a: string) => ({
        statement: a,
        confidence: 0.7,
        verifiable: true,
      })),
      expected_steps: h.expected_steps,
      expected_tools: this.inferTools(h.expected_steps),
      estimated_confidence: h.estimated_confidence,
      estimated_complexity: this.estimateComplexity(h),
      estimated_risk: h.estimated_risk,
      estimated_tokens: this.estimateTokens(h),
      generation_method: 'llm' as const,
    }));
  }

  // 2-3. Memory 기반 가설 생성
  private async generateFromMemory(task: Task, context: Context): Promise<Hypothesis[]> {
    const hypotheses: Hypothesis[] = [];
    
    // 유사 에피소드 검색
    const similarEpisodes = await this.memorySystem.episodicMemory.findSimilar({
      description: task.description,
      task_type: task.type,
      outcome: 'success',  // 성공한 것만
      limit: 3,
    });
    
    for (const episode of similarEpisodes) {
      hypotheses.push({
        id: generateId(),
        description: `Approach based on similar past task: ${episode.task.description}`,
        approach_type: this.mapToApproachType(episode.execution.plan_summary),
        assumptions: [{
          statement: `Similar problem structure to episode ${episode.id}`,
          confidence: 0.8,
          verifiable: true,
        }],
        expected_steps: this.extractStepsFromEpisode(episode),
        expected_tools: episode.execution.tools_used.map(t => t.name),
        estimated_confidence: episode.metadata.usefulness_score,
        estimated_complexity: episode.task.complexity,
        estimated_risk: 0.3,  // 검증된 방법이므로 낮은 리스크
        estimated_tokens: episode.metadata.tokens_used,
        generation_method: 'memory' as const,
      });
    }
    
    // 버그 패턴 매칭
    if (task.error) {
      const patterns = await this.memorySystem.semanticMemory.matchBugPattern(
        task.error,
        context
      );
      
      for (const match of patterns.slice(0, 2)) {
        hypotheses.push({
          id: generateId(),
          description: `Known bug pattern: ${match.pattern.id}`,
          approach_type: ApproachType.DIRECT_FIX,
          assumptions: [{
            statement: `Error matches known pattern with ${(match.score * 100).toFixed(0)}% confidence`,
            confidence: match.score,
            verifiable: true,
          }],
          expected_steps: match.recommended_solution?.approach?.split('\n') || [],
          expected_tools: ['code_search', 'propose_patch', 'run_tests'],
          estimated_confidence: match.score,
          estimated_complexity: 0.3,
          estimated_risk: 0.2,
          estimated_tokens: 5000,
          generation_method: 'pattern' as const,
        });
      }
    }
    
    return hypotheses;
  }

  // 2-4. 패턴 기반 가설 생성
  private async generateFromPatterns(task: Task, context: Context): Promise<Hypothesis[]> {
    const hypotheses: Hypothesis[] = [];
    
    // 태스크 타입별 표준 접근법
    const standardApproaches = this.getStandardApproaches(task.type);
    
    for (const approach of standardApproaches) {
      hypotheses.push({
        id: generateId(),
        description: approach.description,
        approach_type: approach.type,
        assumptions: approach.assumptions,
        expected_steps: approach.steps,
        expected_tools: approach.tools,
        estimated_confidence: approach.base_confidence,
        estimated_complexity: approach.complexity,
        estimated_risk: approach.risk,
        estimated_tokens: approach.estimated_tokens,
        generation_method: 'pattern' as const,
      });
    }
    
    return hypotheses;
  }

  // 2-5. 변형 생성
  private generateVariations(hypotheses: Hypothesis[], task: Task): Hypothesis[] {
    const variations: Hypothesis[] = [];
    
    for (const hypothesis of hypotheses) {
      // 더 보수적인 변형
      if (hypothesis.estimated_risk > 0.3) {
        variations.push({
          ...hypothesis,
          id: generateId(),
          description: `Conservative variant: ${hypothesis.description}`,
          approach_type: ApproachType.MINIMAL_CHANGE,
          estimated_risk: hypothesis.estimated_risk * 0.5,
          estimated_complexity: hypothesis.estimated_complexity * 0.7,
          parent_hypothesis: hypothesis.id,
          generation_method: 'variation',
        });
      }
      
      // 더 포괄적인 변형
      if (hypothesis.approach_type === ApproachType.DIRECT_FIX) {
        variations.push({
          ...hypothesis,
          id: generateId(),
          description: `Comprehensive variant: ${hypothesis.description}`,
          approach_type: ApproachType.COMPREHENSIVE,
          estimated_risk: hypothesis.estimated_risk * 1.3,
          estimated_complexity: hypothesis.estimated_complexity * 1.5,
          parent_hypothesis: hypothesis.id,
          generation_method: 'variation',
        });
      }
    }
    
    return variations;
  }

  // 2-6. 다양성 보장
  private ensureDiversity(hypotheses: Hypothesis[]): Hypothesis[] {
    const diversified: Hypothesis[] = [];
    const seenApproaches = new Set<ApproachType>();
    
    // 각 접근 타입에서 최소 1개 선택
    for (const hypothesis of hypotheses) {
      if (!seenApproaches.has(hypothesis.approach_type)) {
        diversified.push(hypothesis);
        seenApproaches.add(hypothesis.approach_type);
      }
    }
    
    // 나머지는 점수순으로 채움
    for (const hypothesis of hypotheses) {
      if (!diversified.includes(hypothesis)) {
        diversified.push(hypothesis);
      }
    }
    
    return diversified;
  }

  // 2-7. 초기 평가
  private async initialEvaluation(
    hypotheses: Hypothesis[],
    task: Task,
    context: Context
  ): Promise<Hypothesis[]> {
    return hypotheses.map(h => {
      // 컨텍스트와의 적합성 평가
      const contextFit = this.evaluateContextFit(h, context);
      
      // 태스크 복잡도와의 매칭
      const complexityMatch = this.evaluateComplexityMatch(h, task);
      
      // 종합 점수 조정
      const adjustedConfidence = h.estimated_confidence * contextFit * complexityMatch;
      
      return {
        ...h,
        estimated_confidence: adjustedConfidence,
      };
    }).sort((a, b) => {
      // 점수 = 신뢰도 / (복잡도 + 리스크)
      const scoreA = a.estimated_confidence / (a.estimated_complexity + a.estimated_risk + 0.1);
      const scoreB = b.estimated_confidence / (b.estimated_complexity + b.estimated_risk + 0.1);
      return scoreB - scoreA;
    });
  }
}

3. Parallel Executor
여러 가설을 동시에 부분 실행한다.
typescriptinterface ExecutionBranch {
  id: string;
  hypothesis: Hypothesis;
  
  // 실행 상태
  status: BranchStatus;
  current_step: number;
  
  // 결과
  steps_executed: StepResult[];
  discoveries: Discovery[];
  partial_patches: Patch[];
  
  // 평가
  progress_score: number;
  confidence_score: number;
  quality_score: number;
  
  // 리소스 사용
  tokens_used: number;
  time_ms: number;
  
  // 조기 종료 정보
  terminated_early: boolean;
  termination_reason?: string;
}

enum BranchStatus {
  PENDING = 'pending',
  RUNNING = 'running',
  CHECKPOINT = 'checkpoint',    // 체크포인트 도달
  PROMISING = 'promising',      // 유망함
  STRUGGLING = 'struggling',    // 어려움
  TERMINATED = 'terminated',    // 조기 종료
  COMPLETED = 'completed',      // 완료
}

class ParallelExecutor {
  private config: ParallelExecutionConfig;
  private resourceManager: ResourceManager;
  private evaluator: BranchEvaluator;

  // 3-1. 병렬 실행 메인
  async executeParallel(
    hypotheses: Hypothesis[],
    context: Context
  ): Promise<ParallelExecutionResult> {
    
    // 브랜치 초기화
    const branches: ExecutionBranch[] = hypotheses.map(h => ({
      id: generateId(),
      hypothesis: h,
      status: BranchStatus.PENDING,
      current_step: 0,
      steps_executed: [],
      discoveries: [],
      partial_patches: [],
      progress_score: 0,
      confidence_score: h.estimated_confidence,
      quality_score: 0,
      tokens_used: 0,
      time_ms: 0,
      terminated_early: false,
    }));
    
    // Phase 1: 탐색 단계 (모든 브랜치 부분 실행)
    const explorationResult = await this.explorationPhase(branches, context);
    
    // Phase 2: 평가 및 선택
    const selectedBranches = await this.evaluateAndSelect(explorationResult.branches);
    
    // Phase 3: 선택된 브랜치 심화 실행
    const deepExecutionResult = await this.deepExecutionPhase(selectedBranches, context);
    
    // Phase 4: 최종 선택 및 완료
    const finalResult = await this.finalizeBestBranch(deepExecutionResult);
    
    return finalResult;
  }

  // 3-2. 탐색 단계
  private async explorationPhase(
    branches: ExecutionBranch[],
    context: Context
  ): Promise<{ branches: ExecutionBranch[]; }> {
    const explorationBudget = this.config.explorationBudget;  // 전체 예산의 30%
    const perBranchBudget = explorationBudget / branches.length;
    
    // 병렬 실행
    const results = await Promise.all(
      branches.map(branch => this.executeBranchPartial(branch, context, {
        maxSteps: this.config.explorationSteps,      // 3-5 스텝
        maxTokens: perBranchBudget,
        checkpointAt: [1, 3],                         // 체크포인트 지점
      }))
    );
    
    return { branches: results };
  }

  // 3-3. 브랜치 부분 실행
  private async executeBranchPartial(
    branch: ExecutionBranch,
    context: Context,
    limits: ExecutionLimits
  ): Promise<ExecutionBranch> {
    branch.status = BranchStatus.RUNNING;
    const startTime = Date.now();
    
    // 브랜치용 플랜 생성
    const plan = await this.createBranchPlan(branch.hypothesis, context);
    
    for (let step = 0; step < Math.min(plan.steps.length, limits.maxSteps); step++) {
      // 리소스 체크
      if (branch.tokens_used >= limits.maxTokens) {
        branch.status = BranchStatus.CHECKPOINT;
        break;
      }
      
      // 스텝 실행
      const stepResult = await this.executeStep(plan.steps[step], context, branch);
      branch.steps_executed.push(stepResult);
      branch.tokens_used += stepResult.tokens_used;
      branch.current_step = step + 1;
      
      // 발견 사항 기록
      if (stepResult.discoveries) {
        branch.discoveries.push(...stepResult.discoveries);
      }
      
      // 부분 패치 기록
      if (stepResult.patch) {
        branch.partial_patches.push(stepResult.patch);
      }
      
      // 체크포인트 평가
      if (limits.checkpointAt.includes(step + 1)) {
        const evaluation = await this.evaluator.evaluateCheckpoint(branch);
        branch.progress_score = evaluation.progress;
        branch.confidence_score = evaluation.confidence;
        branch.quality_score = evaluation.quality;
        
        // 조기 종료 판단
        if (evaluation.shouldTerminate) {
          branch.status = BranchStatus.TERMINATED;
          branch.terminated_early = true;
          branch.termination_reason = evaluation.terminationReason;
          break;
        }
        
        // 상태 업데이트
        branch.status = evaluation.promising 
          ? BranchStatus.PROMISING 
          : BranchStatus.STRUGGLING;
      }
    }
    
    branch.time_ms = Date.now() - startTime;
    
    if (branch.status === BranchStatus.RUNNING) {
      branch.status = BranchStatus.CHECKPOINT;
    }
    
    return branch;
  }

  // 3-4. 평가 및 선택
  private async evaluateAndSelect(branches: ExecutionBranch[]): Promise<ExecutionBranch[]> {
    // 종료된 브랜치 제외
    const activeBranches = branches.filter(b => !b.terminated_early);
    
    if (activeBranches.length === 0) {
      // 모두 실패하면 가장 덜 나빴던 것 선택
      return [branches.sort((a, b) => b.progress_score - a.progress_score)[0]];
    }
    
    // 종합 점수 계산
    const scored = activeBranches.map(branch => ({
      branch,
      score: this.calculateBranchScore(branch),
    }));
    
    scored.sort((a, b) => b.score - a.score);
    
    // 상위 브랜치 선택 (동적 결정)
    const topScore = scored[0].score;
    const threshold = topScore * 0.7;  // 최고 점수의 70% 이상만
    
    const selected = scored
      .filter(s => s.score >= threshold)
      .slice(0, this.config.maxDeepBranches)  // 최대 2개
      .map(s => s.branch);
    
    return selected;
  }

  // 3-5. 브랜치 점수 계산
  private calculateBranchScore(branch: ExecutionBranch): number {
    const weights = {
      progress: 0.3,
      confidence: 0.25,
      quality: 0.25,
      efficiency: 0.2,
    };
    
    // 효율성 = 진행도 / 사용 리소스
    const efficiency = branch.progress_score / 
      (branch.tokens_used / this.config.explorationBudget + 0.1);
    
    const score = 
      weights.progress * branch.progress_score +
      weights.confidence * branch.confidence_score +
      weights.quality * branch.quality_score +
      weights.efficiency * Math.min(1, efficiency);
    
    // 보너스/페널티
    let adjusted = score;
    
    // 발견 사항이 많으면 보너스
    if (branch.discoveries.length > 2) {
      adjusted *= 1.1;
    }
    
    // 부분 패치가 있으면 보너스
    if (branch.partial_patches.length > 0) {
      adjusted *= 1.15;
    }
    
    // 에러가 많으면 페널티
    const errorCount = branch.steps_executed.filter(s => s.error).length;
    if (errorCount > 1) {
      adjusted *= 0.9;
    }
    
    return adjusted;
  }

  // 3-6. 심화 실행 단계
  private async deepExecutionPhase(
    branches: ExecutionBranch[],
    context: Context
  ): Promise<ExecutionBranch[]> {
    const remainingBudget = this.config.totalBudget - this.config.explorationBudget;
    const perBranchBudget = remainingBudget / branches.length;
    
    // 선택된 브랜치들 심화 실행 (순차 or 병렬)
    if (branches.length === 1) {
      // 단일 브랜치면 전체 예산 사용
      return [await this.executeBranchFull(branches[0], context, remainingBudget)];
    }
    
    // 복수 브랜치면 경쟁 실행
    const results = await this.competitiveExecution(branches, context, perBranchBudget);
    
    return results;
  }

  // 3-7. 경쟁 실행
  private async competitiveExecution(
    branches: ExecutionBranch[],
    context: Context,
    budgetPerBranch: number
  ): Promise<ExecutionBranch[]> {
    const raceSteps = 3;  // 3스텝씩 번갈아 실행
    
    let activeBranches = [...branches];
    let totalSteps = 0;
    
    while (activeBranches.length > 1 && totalSteps < 10) {
      // 각 브랜치 N스텝 실행
      const stepResults = await Promise.all(
        activeBranches.map(branch => 
          this.executeBranchSteps(branch, context, raceSteps)
        )
      );
      
      totalSteps += raceSteps;
      
      // 평가
      const evaluations = await Promise.all(
        stepResults.map(branch => this.evaluator.evaluateBranch(branch))
      );
      
      // 명확한 승자 확인
      const sorted = evaluations.sort((a, b) => b.score - a.score);
      
      if (sorted[0].score > sorted[1].score * 1.5) {
        // 압도적 우위 - 승자 하나만 계속
        activeBranches = [sorted[0].branch];
      } else if (sorted[sorted.length - 1].score < sorted[0].score * 0.5) {
        // 명확한 패자 제거
        activeBranches = activeBranches.filter(
          b => !sorted.slice(-1).some(s => s.branch.id === b.id)
        );
      }
      
      // 하나라도 완료되면 종료
      const completed = activeBranches.find(b => b.status === BranchStatus.COMPLETED);
      if (completed) {
        return [completed];
      }
    }
    
    return activeBranches;
  }

  // 3-8. 최종 선택
  private async finalizeBestBranch(
    branches: ExecutionBranch[]
  ): Promise<ParallelExecutionResult> {
    if (branches.length === 1) {
      const branch = branches[0];
      
      // 아직 완료 안 됐으면 마저 실행
      if (branch.status !== BranchStatus.COMPLETED) {
        await this.completeBranch(branch);
      }
      
      return {
        selected_branch: branch,
        all_branches: branches,
        selection_reason: 'single_branch',
      };
    }
    
    // 복수면 최종 평가
    const finalEvaluations = await Promise.all(
      branches.map(b => this.evaluator.finalEvaluation(b))
    );
    
    finalEvaluations.sort((a, b) => b.score - a.score);
    const best = finalEvaluations[0].branch;
    
    // 최고 브랜치 완료
    if (best.status !== BranchStatus.COMPLETED) {
      await this.completeBranch(best);
    }
    
    return {
      selected_branch: best,
      all_branches: branches,
      selection_reason: 'best_score',
      comparison: {
        winner: best.id,
        scores: finalEvaluations.map(e => ({
          branch_id: e.branch.id,
          score: e.score,
          breakdown: e.breakdown,
        })),
      },
    };
  }
}

4. Branch Evaluator
브랜치를 평가하고 가지치기 결정을 내린다.
typescriptinterface BranchEvaluation {
  branch: ExecutionBranch;
  score: number;
  
  breakdown: {
    progress: number;           // 목표 달성도
    quality: number;            // 결과 품질
    confidence: number;         // 올바른 방향 확신도
    efficiency: number;         // 리소스 효율
    momentum: number;           // 진행 추세
  };
  
  signals: {
    positive: string[];
    negative: string[];
    neutral: string[];
  };
  
  prediction: {
    estimated_remaining_steps: number;
    estimated_remaining_tokens: number;
    success_probability: number;
  };
  
  recommendation: 'continue' | 'boost' | 'deprioritize' | 'terminate';
}

class BranchEvaluator {

  // 4-1. 체크포인트 평가
  async evaluateCheckpoint(branch: ExecutionBranch): Promise<CheckpointEvaluation> {
    const signals = this.collectSignals(branch);
    const scores = this.calculateScores(branch, signals);
    
    // 조기 종료 조건 체크
    const terminationCheck = this.checkTermination(branch, signals, scores);
    
    return {
      progress: scores.progress,
      confidence: scores.confidence,
      quality: scores.quality,
      promising: scores.overall > 0.5,
      shouldTerminate: terminationCheck.terminate,
      terminationReason: terminationCheck.reason,
    };
  }

  // 4-2. 신호 수집
  private collectSignals(branch: ExecutionBranch): BranchSignals {
    const positive: string[] = [];
    const negative: string[] = [];
    const neutral: string[] = [];
    
    // 스텝 결과 분석
    for (const step of branch.steps_executed) {
      if (step.success) {
        if (step.significant_finding) {
          positive.push(`Found: ${step.significant_finding}`);
        }
        if (step.progress_indicator) {
          positive.push(`Progress: ${step.progress_indicator}`);
        }
      } else {
        if (step.error) {
          negative.push(`Error: ${step.error.message}`);
        }
        if (step.dead_end) {
          negative.push(`Dead end: ${step.dead_end_reason}`);
        }
      }
    }
    
    // 발견 사항 분석
    for (const discovery of branch.discoveries) {
      if (discovery.type === 'root_cause') {
        positive.push(`Root cause identified: ${discovery.description}`);
      } else if (discovery.type === 'constraint') {
        neutral.push(`Constraint found: ${discovery.description}`);
      } else if (discovery.type === 'blocker') {
        negative.push(`Blocker found: ${discovery.description}`);
      }
    }
    
    // 가설 검증 상태
    for (const assumption of branch.hypothesis.assumptions) {
      if (assumption.verified === true) {
        positive.push(`Assumption verified: ${assumption.statement}`);
      } else if (assumption.verified === false) {
        negative.push(`Assumption invalidated: ${assumption.statement}`);
      }
    }
    
    // 진행 패턴 분석
    const recentSteps = branch.steps_executed.slice(-3);
    const successRate = recentSteps.filter(s => s.success).length / recentSteps.length;
    
    if (successRate < 0.3) {
      negative.push('Recent steps mostly failing');
    } else if (successRate > 0.8) {
      positive.push('Strong recent progress');
    }
    
    return { positive, negative, neutral };
  }

  // 4-3. 점수 계산
  private calculateScores(
    branch: ExecutionBranch,
    signals: BranchSignals
  ): BranchScores {
    
    // Progress: 목표 대비 진행도
    const progress = this.calculateProgress(branch);
    
    // Quality: 결과물 품질
    const quality = this.calculateQuality(branch);
    
    // Confidence: 올바른 방향인지
    const confidence = this.calculateConfidence(branch, signals);
    
    // Efficiency: 리소스 대비 진행
    const efficiency = this.calculateEfficiency(branch);
    
    // Momentum: 진행 추세
    const momentum = this.calculateMomentum(branch);
    
    // Overall
    const overall = 
      0.25 * progress +
      0.2 * quality +
      0.25 * confidence +
      0.15 * efficiency +
      0.15 * momentum;
    
    return { progress, quality, confidence, efficiency, momentum, overall };
  }

  // 4-4. Progress 계산
  private calculateProgress(branch: ExecutionBranch): number {
    let progress = 0;
    
    // 예상 스텝 대비 완료 스텝
    const expectedSteps = branch.hypothesis.expected_steps.length;
    const completedSteps = branch.steps_executed.filter(s => s.success).length;
    progress += 0.3 * (completedSteps / expectedSteps);
    
    // 핵심 마일스톤 달성 여부
    const milestones = this.identifyMilestones(branch.hypothesis);
    const achievedMilestones = milestones.filter(m => 
      this.isMilestoneAchieved(m, branch)
    ).length;
    progress += 0.4 * (achievedMilestones / milestones.length);
    
    // 부분 패치 존재 여부
    if (branch.partial_patches.length > 0) {
      progress += 0.2;
    }
    
    // 테스트 통과 여부 (있다면)
    const testResults = branch.steps_executed.find(s => s.type === 'run_tests');
    if (testResults?.result?.passed) {
      progress += 0.1;
    }
    
    return Math.min(1, progress);
  }

  // 4-5. Confidence 계산
  private calculateConfidence(branch: ExecutionBranch, signals: BranchSignals): number {
    let confidence = branch.hypothesis.estimated_confidence;
    
    // 긍정 신호로 상향
    confidence += signals.positive.length * 0.05;
    
    // 부정 신호로 하향
    confidence -= signals.negative.length * 0.1;
    
    // 가설 검증 결과 반영
    const verified = branch.hypothesis.assumptions.filter(a => a.verified === true).length;
    const invalidated = branch.hypothesis.assumptions.filter(a => a.verified === false).length;
    
    confidence += verified * 0.1;
    confidence -= invalidated * 0.2;
    
    // Root cause 발견 시 큰 부스트
    if (branch.discoveries.some(d => d.type === 'root_cause')) {
      confidence += 0.2;
    }
    
    return Math.max(0, Math.min(1, confidence));
  }

  // 4-6. Momentum 계산 (추세)
  private calculateMomentum(branch: ExecutionBranch): number {
    if (branch.steps_executed.length < 2) return 0.5;
    
    const windowSize = Math.min(3, branch.steps_executed.length);
    const recentSteps = branch.steps_executed.slice(-windowSize);
    const olderSteps = branch.steps_executed.slice(0, -windowSize);
    
    const recentSuccessRate = recentSteps.filter(s => s.success).length / recentSteps.length;
    const olderSuccessRate = olderSteps.length > 0 
      ? olderSteps.filter(s => s.success).length / olderSteps.length
      : 0.5;
    
    // 추세 계산
    const trend = recentSuccessRate - olderSuccessRate;
    
    // -1 to 1 → 0 to 1
    return 0.5 + (trend / 2);
  }

  // 4-7. 종료 조건 체크
  private checkTermination(
    branch: ExecutionBranch,
    signals: BranchSignals,
    scores: BranchScores
  ): { terminate: boolean; reason?: string } {
    
    // 1. 핵심 가설 무효화
    const criticalAssumptions = branch.hypothesis.assumptions.filter(a => a.critical);
    const invalidatedCritical = criticalAssumptions.filter(a => a.verified === false);
    
    if (invalidatedCritical.length > 0) {
      return {
        terminate: true,
        reason: `Critical assumption invalidated: ${invalidatedCritical[0].statement}`,
      };
    }
    
    // 2. 연속 실패
    const lastN = branch.steps_executed.slice(-3);
    if (lastN.length >= 3 && lastN.every(s => !s.success)) {
      return {
        terminate: true,
        reason: 'Three consecutive failures',
      };
    }
    
    // 3. 점수가 너무 낮음
    if (scores.overall < 0.2 && branch.current_step >= 2) {
      return {
        terminate: true,
        reason: `Score too low: ${scores.overall.toFixed(2)}`,
      };
    }
    
    // 4. Blocker 발견
    const blocker = branch.discoveries.find(d => d.type === 'blocker' && d.unresolvable);
    if (blocker) {
      return {
        terminate: true,
        reason: `Unresolvable blocker: ${blocker.description}`,
      };
    }
    
    // 5. 루프 감지
    if (this.detectLoop(branch)) {
      return {
        terminate: true,
        reason: 'Execution loop detected',
      };
    }
    
    return { terminate: false };
  }

  // 4-8. 최종 평가
  async finalEvaluation(branch: ExecutionBranch): Promise<BranchEvaluation> {
    const signals = this.collectSignals(branch);
    const scores = this.calculateScores(branch, signals);
    
    // 최종 점수에 추가 요소 반영
    let finalScore = scores.overall;
    
    // 완성도 보너스
    if (branch.partial_patches.length > 0) {
      const patchQuality = await this.evaluatePatchQuality(branch.partial_patches);
      finalScore += patchQuality * 0.2;
    }
    
    // 테스트 결과 반영
    const testStep = branch.steps_executed.find(s => s.type === 'run_tests');
    if (testStep?.result) {
      if (testStep.result.all_passed) {
        finalScore += 0.3;
      } else if (testStep.result.pass_rate > 0.8) {
        finalScore += 0.15;
      }
    }
    
    // 예측
    const prediction = this.predictCompletion(branch, scores);
    
    return {
      branch,
      score: finalScore,
      breakdown: scores,
      signals,
      prediction,
      recommendation: this.makeRecommendation(finalScore, signals),
    };
  }

  // 4-9. 완료 예측
  private predictCompletion(branch: ExecutionBranch, scores: BranchScores): Prediction {
    const remainingProgress = 1 - scores.progress;
    const avgProgressPerStep = scores.progress / (branch.current_step || 1);
    
    const estimatedRemainingSteps = Math.ceil(remainingProgress / (avgProgressPerStep || 0.1));
    const avgTokensPerStep = branch.tokens_used / (branch.current_step || 1);
    const estimatedRemainingTokens = estimatedRemainingSteps * avgTokensPerStep;
    
    // 성공 확률 = confidence * momentum * (1 - 남은 복잡도)
    const successProbability = scores.confidence * scores.momentum * 
      (1 - (remainingProgress * 0.5));
    
    return {
      estimated_remaining_steps: estimatedRemainingSteps,
      estimated_remaining_tokens: estimatedRemainingTokens,
      success_probability: Math.max(0, Math.min(1, successProbability)),
    };
  }
}

5. Resource Manager
병렬 실행의 리소스를 관리한다.
typescriptinterface ResourceBudget {
  total_tokens: number;
  total_time_ms: number;
  max_parallel_branches: number;
  max_tool_calls: number;
}

interface ResourceAllocation {
  branch_id: string;
  allocated_tokens: number;
  allocated_time_ms: number;
  priority: number;
}

class ResourceManager {
  private budget: ResourceBudget;
  private allocations: Map<string, ResourceAllocation> = new Map();
  private usage: Map<string, ResourceUsage> = new Map();

  // 5-1. 초기 할당
  allocateInitial(branches: ExecutionBranch[]): void {
    const perBranch = {
      tokens: this.budget.total_tokens / branches.length,
      time: this.budget.total_time_ms / branches.length,
    };
    
    for (const branch of branches) {
      this.allocations.set(branch.id, {
        branch_id: branch.id,
        allocated_tokens: perBranch.tokens,
        allocated_time_ms: perBranch.time,
        priority: 1.0,
      });
      
      this.usage.set(branch.id, {
        tokens_used: 0,
        time_used_ms: 0,
        tool_calls: 0,
      });
    }
  }

  // 5-2. 동적 재할당
  reallocate(evaluations: BranchEvaluation[]): void {
    // 종료된 브랜치의 리소스 회수
    const terminatedIds = evaluations
      .filter(e => e.recommendation === 'terminate')
      .map(e => e.branch.id);
    
    let reclaimedTokens = 0;
    let reclaimedTime = 0;
    
    for (const id of terminatedIds) {
      const allocation = this.allocations.get(id);
      const usage = this.usage.get(id);
      
      if (allocation && usage) {
        reclaimedTokens += allocation.allocated_tokens - usage.tokens_used;
        reclaimedTime += allocation.allocated_time_ms - usage.time_used_ms;
      }
      
      this.allocations.delete(id);
    }
    
    // 활성 브랜치에 재분배
    const activeEvaluations = evaluations.filter(e => e.recommendation !== 'terminate');
    
    if (activeEvaluations.length === 0) return;
    
    // 점수 기반 가중 분배
    const totalScore = activeEvaluations.reduce((sum, e) => sum + e.score, 0);
    
    for (const evaluation of activeEvaluations) {
      const weight = evaluation.score / totalScore;
      const allocation = this.allocations.get(evaluation.branch.id);
      
      if (allocation) {
        allocation.allocated_tokens += reclaimedTokens * weight;
        allocation.allocated_time_ms += reclaimedTime * weight;
        allocation.priority = evaluation.score;
      }
    }
  }

  // 5-3. 리소스 체크
  checkBudget(branchId: string, request: ResourceRequest): BudgetCheckResult {
    const allocation = this.allocations.get(branchId);
    const usage = this.usage.get(branchId);
    
    if (!allocation || !usage) {
      return { allowed: false, reason: 'Branch not found' };
    }
    
    const remainingTokens = allocation.allocated_tokens - usage.tokens_used;
    const remainingTime = allocation.allocated_time_ms - usage.time_used_ms;
    
    if (request.tokens > remainingTokens) {
      return { 
        allowed: false, 
        reason: 'Token budget exceeded',
        available: remainingTokens,
        requested: request.tokens,
      };
    }
    
    if (request.estimated_time_ms > remainingTime) {
      return { 
        allowed: false, 
        reason: 'Time budget exceeded',
        available: remainingTime,
        requested: request.estimated_time_ms,
      };
    }
    
    return { allowed: true };
  }

  // 5-4. 사용량 기록
  recordUsage(branchId: string, usage: ResourceUsage): void {
    const current = this.usage.get(branchId);
    
    if (current) {
      current.tokens_used += usage.tokens_used;
      current.time_used_ms += usage.time_used_ms;
      current.tool_calls += usage.tool_calls;
    }
  }

  // 5-5. 전체 상태
  getStatus(): ResourceStatus {
    let totalUsedTokens = 0;
    let totalUsedTime = 0;
    
    for (const usage of this.usage.values()) {
      totalUsedTokens += usage.tokens_used;
      totalUsedTime += usage.time_used_ms;
    }
    
    return {
      total_budget: this.budget,
      total_used: {
        tokens: totalUsedTokens,
        time_ms: totalUsedTime,
      },
      remaining: {
        tokens: this.budget.total_tokens - totalUsedTokens,
        time_ms: this.budget.total_time_ms - totalUsedTime,
      },
      utilization: {
        tokens: totalUsedTokens / this.budget.total_tokens,
        time: totalUsedTime / this.budget.total_time_ms,
      },
      active_branches: this.allocations.size,
    };
  }
}

6. Speculative Execution
확신도 낮은 결정에서 여러 경로를 동시에 탐색한다.
typescriptinterface SpeculativePoint {
  decision_id: string;
  description: string;
  options: SpeculativeOption[];
  confidence_threshold: number;  // 이 이하면 speculative 실행
}

interface SpeculativeOption {
  id: string;
  description: string;
  probability: number;
  estimated_cost: number;
}

class SpeculativeExecutor {
  private config: SpeculativeConfig;

  // 6-1. Speculative 포인트 감지
  detectSpeculativePoint(
    decision: Decision,
    context: Context
  ): SpeculativePoint | null {
    // 신뢰도가 낮은 결정인지 확인
    if (decision.confidence >= this.config.confidenceThreshold) {
      return null;  // 확신 있으면 speculative 불필요
    }
    
    // 옵션 생성
    const options = this.generateOptions(decision, context);
    
    if (options.length < 2) {
      return null;  // 대안이 없으면 speculative 불가
    }
    
    return {
      decision_id: decision.id,
      description: decision.description,
      options,
      confidence_threshold: this.config.confidenceThreshold,
    };
  }

  // 6-2. Speculative 실행
  async executeSpeculative(
    point: SpeculativePoint,
    context: Context,
    budget: number
  ): Promise<SpeculativeResult> {
    // 상위 옵션들 선택 (확률 기반)
    const topOptions = point.options
      .sort((a, b) => b.probability - a.probability)
      .slice(0, this.config.maxSpeculativeBranches);
    
    // 예산 분배 (확률 비례)
    const totalProb = topOptions.reduce((sum, o) => sum + o.probability, 0);
    const allocations = topOptions.map(option => ({
      option,
      budget: budget * (option.probability / totalProb),
    }));
    
    // 병렬 실행
    const executions = await Promise.all(
      allocations.map(({ option, budget }) =>
        this.executeOption(option, context, budget)
      )
    );
    
    // 결과 평가
    const evaluated = executions.map(exec => ({
      ...exec,
      score: this.evaluateSpeculativeResult(exec),
    }));
    
    // 최선 선택
    evaluated.sort((a, b) => b.score - a.score);
    const best = evaluated[0];
    
    // Validation
    const validated = await this.validateChoice(best, evaluated.slice(1));
    
    return {
      chosen_option: best.option,
      execution_result: best.result,
      alternatives_explored: evaluated.length,
      confidence_boost: this.calculateConfidenceBoost(evaluated),
      validated,
    };
  }

  // 6-3. 옵션 실행
  private async executeOption(
    option: SpeculativeOption,
    context: Context,
    budget: number
  ): Promise<OptionExecution> {
    const executor = new LimitedExecutor(budget);
    
    // 옵션 기반 부분 실행
    const result = await executor.executePartial({
      hypothesis: this.optionToHypothesis(option),
      context,
      maxSteps: this.config.speculativeSteps,
    });
    
    return {
      option,
      result,
      tokens_used: result.tokens_used,
      success_indicators: this.extractSuccessIndicators(result),
    };
  }

  // 6-4. 결과 평가
  private evaluateSpeculativeResult(execution: OptionExecution): number {
    let score = 0;
    
    // 성공 지표
    score += execution.success_indicators.length * 0.2;
    
    // 에러 없음
    if (!execution.result.error) {
      score += 0.3;
    }
    
    // 진행 있음
    if (execution.result.progress > 0) {
      score += execution.result.progress * 0.3;
    }
    
    // 비용 효율
    const efficiency = execution.result.progress / (execution.tokens_used / 1000);
    score += Math.min(0.2, efficiency * 0.1);
    
    return score;
  }

  // 6-5. 신뢰도 부스트 계산
  private calculateConfidenceBoost(evaluated: EvaluatedExecution[]): number {
    if (evaluated.length < 2) return 0;
    
    const best = evaluated[0].score;
    const second = evaluated[1].score;
    
    // 최선과 차선의 차이가 클수록 신뢰도 증가
    const gap = (best - second) / best;
    
    return Math.min(0.3, gap * 0.5);
  }
}

7. Tree of Thought Integration
Tree of Thought 스타일의 탐색을 통합한다.
typescriptinterface ThoughtNode {
  id: string;
  parent_id: string | null;
  depth: number;
  
  thought: string;
  reasoning: string;
  
  state: ThoughtState;
  evaluation: number;
  
  children: string[];
  
  metadata: {
    tokens_used: number;
    time_ms: number;
    pruned: boolean;
    prune_reason?: string;
  };
}

interface ThoughtState {
  context_summary: string;
  progress: number;
  discoveries: string[];
  open_questions: string[];
}

class TreeOfThoughtPlanner {
  private config: ToTConfig;
  private evaluator: ThoughtEvaluator;

  // 7-1. ToT 기반 플래닝
  async planWithToT(task: Task, context: Context): Promise<ToTPlan> {
    // 루트 노드 생성
    const root: ThoughtNode = {
      id: 'root',
      parent_id: null,
      depth: 0,
      thought: `Analyzing task: ${task.description}`,
      reasoning: 'Initial analysis',
      state: {
        context_summary: this.summarizeContext(context),
        progress: 0,
        discoveries: [],
        open_questions: this.extractQuestions(task),
      },
      evaluation: 0.5,
      children: [],
      metadata: { tokens_used: 0, time_ms: 0, pruned: false },
    };
    
    const tree = new ThoughtTree(root);
    
    // BFS로 트리 확장
    for (let depth = 0; depth < this.config.maxDepth; depth++) {
      const leaves = tree.getLeaves();
      
      // 각 leaf에서 자식 생성
      for (const leaf of leaves) {
        if (leaf.metadata.pruned) continue;
        
        // 자식 thought 생성
        const children = await this.generateChildThoughts(leaf, task, context);
        
        // 평가
        const evaluated = await Promise.all(
          children.map(child => this.evaluateThought(child, task))
        );
        
        // 가지치기
        const kept = this.prune(evaluated);
        
        // 트리에 추가
        for (const child of kept) {
          tree.addNode(child, leaf.id);
        }
      }
      
      // 전체 트리 가지치기
      tree.globalPrune(this.config.maxNodes);
      
      // 완료 체크
      const complete = tree.getLeaves().find(l => l.state.progress >= 0.9);
      if (complete) break;
    }
    
    // 최적 경로 추출
    const bestPath = tree.getBestPath();
    
    return this.pathToPlan(bestPath, task);
  }

  // 7-2. 자식 thought 생성
  private async generateChildThoughts(
    parent: ThoughtNode,
    task: Task,
    context: Context
  ): Promise<ThoughtNode[]> {
    const prompt = `Given the current state of analysis:

Parent thought: ${parent.thought}
Current progress: ${(parent.state.progress * 100).toFixed(0)}%
Discoveries so far: ${parent.state.discoveries.join(', ') || 'None'}
Open questions: ${parent.state.open_questions.join(', ')}

Task: ${task.description}

Generate ${this.config.branchingFactor} different next thoughts/approaches.
Each should be a distinct, meaningful step toward solving the task.

For each thought, provide:
1. The thought itself (what to do/consider next)
2. Reasoning (why this is a good next step)
3. Expected progress increase (0-1)
4. Potential discoveries
5. New questions that might arise

Respond in JSON format.`;

    const response = await this.llm.complete(prompt);
    const parsed = JSON.parse(response);
    
    return parsed.map((t: any, idx: number) => ({
      id: `${parent.id}_${idx}`,
      parent_id: parent.id,
      depth: parent.depth + 1,
      thought: t.thought,
      reasoning: t.reasoning,
      state: {
        context_summary: parent.state.context_summary,
        progress: parent.state.progress + t.expected_progress,
        discoveries: [...parent.state.discoveries, ...t.potential_discoveries],
        open_questions: t.new_questions,
      },
      evaluation: 0,
      children: [],
      metadata: { tokens_used: 0, time_ms: 0, pruned: false },
    }));
  }

  // 7-3. Thought 평가
  private async evaluateThought(thought: ThoughtNode, task: Task): Promise<ThoughtNode> {
    const prompt = `Evaluate this thought for solving the task:

Task: ${task.description}

Thought: ${thought.thought}
Reasoning: ${thought.reasoning}
Current progress: ${(thought.state.progress * 100).toFixed(0)}%

Rate on these criteria (0-1):
1. Relevance: How relevant is this to solving the task?
2. Progress: How much does this advance toward the solution?
3. Feasibility: How achievable is this step?
4. Efficiency: Is this an efficient use of resources?
5. Risk: What's the risk of this being wrong direction? (0=high risk, 1=low risk)

Provide an overall score (0-1) and brief justification.`;

    const response = await this.llm.complete(prompt);
    const evaluation = JSON.parse(response);
    
    thought.evaluation = evaluation.overall_score;
    
    return thought;
  }

  // 7-4. 가지치기
  private prune(thoughts: ThoughtNode[]): ThoughtNode[] {
    // 점수순 정렬
    thoughts.sort((a, b) => b.evaluation - a.evaluation);
    
    // 하위 점수 제거
    const threshold = thoughts[0].evaluation * this.config.pruneThreshold;
    
    return thoughts.filter((t, idx) => {
      if (t.evaluation < threshold && idx > 0) {
        t.metadata.pruned = true;
        t.metadata.prune_reason = `Score ${t.evaluation.toFixed(2)} below threshold ${threshold.toFixed(2)}`;
        return false;
      }
      return true;
    }).slice(0, this.config.maxChildrenPerNode);
  }

  // 7-5. 경로를 플랜으로 변환
  private pathToPlan(path: ThoughtNode[], task: Task): ToTPlan {
    const steps: PlanStep[] = path.map((node, idx) => ({
      step_number: idx + 1,
      description: node.thought,
      reasoning: node.reasoning,
      expected_tools: this.inferToolsFromThought(node.thought),
      expected_outcome: node.state.discoveries[0] || 'Progress toward solution',
    }));
    
    return {
      task_id: task.id,
      steps,
      total_expected_progress: path[path.length - 1].state.progress,
      confidence: path.reduce((sum, n) => sum + n.evaluation, 0) / path.length,
      thought_tree_depth: path.length,
      alternatives_considered: path.reduce((sum, n) => sum + n.children.length, 0),
    };
  }
}

8. 통합 Parallel Planning Controller
모든 병렬 전략을 통합 제어한다.
typescriptclass ParallelPlanningController {
  private hypothesisGenerator: HypothesisGenerator;
  private parallelExecutor: ParallelExecutor;
  private speculativeExecutor: SpeculativeExecutor;
  private totPlanner: TreeOfThoughtPlanner;
  private resourceManager: ResourceManager;
  private config: ParallelPlanningConfig;

  // 8-1. 메인 엔트리
  async plan(task: Task, context: Context): Promise<ParallelPlanningResult> {
    // 태스크 복잡도 분석
    const complexity = await this.analyzeComplexity(task, context);
    
    // 전략 선택
    const strategy = this.selectStrategy(complexity);
    
    switch (strategy) {
      case 'simple':
        // 단순 태스크: 순차 실행
        return this.executeSimple(task, context);
      
      case 'parallel_hypotheses':
        // 중간 복잡도: 가설 병렬 탐색
        return this.executeParallelHypotheses(task, context);
      
      case 'tree_of_thought':
        // 높은 복잡도: ToT 기반
        return this.executeTreeOfThought(task, context);
      
      case 'hybrid':
        // 매우 복잡: 하이브리드 접근
        return this.executeHybrid(task, context);
    }
  }

  // 8-2. 전략 선택
  private selectStrategy(complexity: ComplexityAnalysis): PlanningStrategy {
    if (complexity.score < 0.3) {
      return 'simple';
    }
    
    if (complexity.score < 0.6) {
      return 'parallel_hypotheses';
    }
    
    if (complexity.score < 0.8) {
      return 'tree_of_thought';
    }
    
    return 'hybrid';
  }

  // 8-3. 가설 병렬 실행
  private async executeParallelHypotheses(
    task: Task,
    context: Context
  ): Promise<ParallelPlanningResult> {
    // 가설 생성
    const hypotheses = await this.hypothesisGenerator.generate(task, context);
    
    // 리소스 할당
    this.resourceManager.allocateInitial(
      hypotheses.map(h => ({ id: h.id, hypothesis: h } as ExecutionBranch))
    );
    
    // 병렬 실행
    const result = await this.parallelExecutor.executeParallel(hypotheses, context);
    
    return {
      strategy_used: 'parallel_hypotheses',
      selected_plan: this.branchToPlan(result.selected_branch),
      alternatives: result.all_branches.length - 1,
      exploration_stats: {
        hypotheses_generated: hypotheses.length,
        branches_explored: result.all_branches.length,
        branches_terminated: result.all_branches.filter(b => b.terminated_early).length,
      },
      resource_usage: this.resourceManager.getStatus(),
    };
  }

  // 8-4. ToT 실행
  private async executeTreeOfThought(
    task: Task,
    context: Context
  ): Promise<ParallelPlanningResult> {
    const totPlan = await this.totPlanner.planWithToT(task, context);
    
    return {
      strategy_used: 'tree_of_thought',
      selected_plan: totPlan,
      alternatives: totPlan.alternatives_considered,
      exploration_stats: {
        tree_depth: totPlan.thought_tree_depth,
        thoughts_evaluated: totPlan.alternatives_considered,
      },
      resource_usage: this.resourceManager.getStatus(),
    };
  }

  // 8-5. 하이브리드 실행
  private async executeHybrid(
    task: Task,
    context: Context
  ): Promise<ParallelPlanningResult> {
    // Phase 1: ToT로 고수준 전략 탐색
    const totResult = await this.totPlanner.planWithToT(task, context);
    const topStrategies = this.extractTopStrategies(totResult, 3);
    
    // Phase 2: 각 전략을 가설로 변환하여 병렬 실행
    const hypotheses = topStrategies.map(s => this.strategyToHypothesis(s));
    const parallelResult = await this.parallelExecutor.executeParallel(hypotheses, context);
    
    // Phase 3: Speculative 포인트에서 추가 탐색
    const speculativePoints = this.detectSpeculativePoints(parallelResult.selected_branch);
    
    for (const point of speculativePoints) {
      const specResult = await this.speculativeExecutor.executeSpeculative(
        point,
        context,
        this.config.speculativeBudget
      );
      
      // 결과 병합
      this.mergeSpeculativeResult(parallelResult.selected_branch, specResult);
    }
    
    return {
      strategy_used: 'hybrid',
      selected_plan: this.branchToPlan(parallelResult.selected_branch),
      alternatives: topStrategies.length + speculativePoints.length,
      exploration_stats: {
        tot_depth: totResult.thought_tree_depth,
        parallel_branches: parallelResult.all_branches.length,
        speculative_points: speculativePoints.length,
      },
      resource_usage: this.resourceManager.getStatus(),
    };
  }
}

9. 메트릭 & 모니터링
typescriptinterface ParallelPlanningMetrics {
  // 효율성
  exploration_efficiency: number;       // 탐색 대비 성공률
  resource_utilization: number;         // 리소스 활용률
  pruning_accuracy: number;             // 가지치기 정확도
  
  // 품질
  best_branch_score: number;
  score_gap: number;                    // 최선-차선 차이
  confidence_improvement: number;       // 탐색 후 신뢰도 향상
  
  // 성능
  total_branches_explored: number;
  branches_terminated_early: number;
  avg_branch_depth: number;
  
  // 전략별
  strategy_success_rates: Record<PlanningStrategy, number>;
  hypothesis_source_effectiveness: Record<string, number>;
}