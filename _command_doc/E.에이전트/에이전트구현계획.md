━━━━━━━━━━━━━━━━━━━━━━━━━━

상위 설계 요약 (핵심만)
━━━━━━━━━━━━━━━━━━━━━━━━━━

1-1. 3계층 구조

Layer 1: Tool Layer

코드 이해·수정·검증을 위한 실제 동작 함수들

code_search, symbol_search, graph_neighbors

open_file, get_span

propose_patch, apply_patch

run_tests, run_lint, git_diff

Layer 2: Agent Orchestration Layer (LangGraph)

Intent Router

Workflow Templates (code_fix, refactor, diagnosis)

Nodes: planner → tool_router → tool → reviewer → planner/answer

Layer 3: Context Builder Layer

Semantica Codegraph 기반

버그/심볼/파일/콜체인/테스트 문맥 패키징

핵심 설계 포인트

툴은 도로와 신호등 역할

Agent는 운전자

ContextBuilder는 네비게이션 역할

이 세 개만 안정적으로 있으면 Cursor급 기능은 충분히 커버 가능.

━━━━━━━━━━━━━━━━━━━━━━━━━━
2. 실제 구현 플랜
━━━━━━━━━━━━━━━━━━━━━━━━━━

2-1. Phase 1: Tool Layer 구축 (1주)

최소 제공 툴

open_file(path)

code_search(query, scope)

symbol_search(name)

propose_patch(path, span, new_code)

run_tests(scope)

출력 스키마 고정(JSON contract-first)

→ 이 단계만 끝나면 “LLM에 쓸 수 있는 API 표면” 확보.

2-2. Phase 2: 기본 Agent (1~2주)

LangGraph 기반 StateGraph 정의

state: messages, plan, current_step, tool_results, context, done

공통 노드 구현

planner

tool_router

reviewer

answer

간단한 워크플로우 1개(code_fix)만 먼저 적용
→ 단일 파일·단일 patch 제안까지 가능해짐

2-3. Phase 3: Context Builder (1주)

Semantica Codegraph API로 구현

symbol → file → callers → callees → 관련 테스트

ContextBundle 정의

files, symbols, call_chains, tests

→ Agent가 “어디를 고쳐야 하는지” 정확히 찾을 수 있음

2-4. Phase 4: Multi-step Patch Engine (1~2주)

propose_patch → test → revise → propose_patch 반복

plan 포맷 고정

STEP: analyze

STEP: inspect_callers

STEP: propose_patch

STEP: run_tests

STEP: finalize

Side-effect 툴 제어

apply_patch는 항상 dry-run 이후 reviewer 승인 시 실행

2-5. Phase 5: 안전성 + 엣지 케이스 처리 (지속적)

JSON 깨짐 → 자동 재요청

동일 툴 반복 호출 → max_calls

루프 감지(동일 plan 반복)

patch 실패 시 rollback

→ 프로덕션 등급 에이전트 완성

━━━━━━━━━━━━━━━━━━━━━━━━━━
3. 커버해야 하는 “핵심 시나리오” (실제 제품 수준)
━━━━━━━━━━━━━━━━━━━━━━━━━━

3-1. 단일 파일 버그 수정
입력: “이 함수 버그 고쳐줘”
동작:

symbol_search

open_file + context 확장

propose_patch

run_tests

answer/diff 제공
→ Cursor급 기본 기능

3-2. 다중 파일 수정 (모듈 단위 리팩토링)
입력: “이 모듈 구조 너무 복잡해, 함수들 정리하고 API 깔끔하게 만들어줘”
동작:

디렉토리 스캔

public API 분석

호출 그래프 분석

2~5개의 단계적 patch 제안

테스트 후 merge
→ Cursor의 “리팩토링 시나리오” 대응

3-3. 에러 로그 기반 문제 해결
입력: “이 stack trace 기준으로 문제 찾아서 고쳐줘”
동작:

stack → symbol 매핑

graph traversal로 영향 범위 탐색

patch 제안

테스트
→ Cursor에서 잘 안 되는 영역 (Semantica Graph 강점)

3-4. 새 기능 추가
입력: “discount 기능 하나 새로 넣어서 API에 연결해줘”
동작:

관련 파일 검색

패턴 분석

신규 코드 skeleton 생성

수정 사항 multi-patch
→ 실제 개발 요구 대응

3-5. 설명·요약

파일 요약

함수 의미 해석

call chain 시각 요약
→ Developer assistant 기능

━━━━━━━━━━━━━━━━━━━━━━━━━━
4. 꼭 처리해야 하는 엣지 케이스 시나리오
━━━━━━━━━━━━━━━━━━━━━━━━━━

4-1. JSON 형식 오류

툴 라우팅 입력 깨짐
해결: JSON Schema Validation → replan 요청

4-2. 동일 툴 반복 호출

code_search → code_search → code_search…
해결:

max_calls_per_tool 정책

Loop detection(plan hash 동일)

4-3. 잘못된 파일 선택

context builder가 오답 파일 포함
해결:

심볼 정확도 기준 검색

graph_neighbors 확장

reviewer에서 “파일 불일치” 감지 후 수정 요청

4-4. patch 적용 실패

syntax error

파일 충돌
해결:

propose_patch는 always dry-run

reviewer가 파일 파싱 검증

실패 시 재계획

4-5. 테스트 실패
해결:

실패 로그 → planner로 컨텍스트 확장 힌트

“다른 전략 시도” 플래그 추가

4-6. 거대한 파일(>1000 lines)
해결:

span 단위 chunking

필요 영역만 open_file(partial) 지원

4-7. 애매한 요청
입력: “이거 대충 고쳐줘”
해결:

Intent Router가 clarifying question 생성

Planner가 최소 context 수집 규칙 수행

4-8. LLM hallucination
해결:

툴 결과를 reviewer에서 cross-check

Proposal에서 변경되지 않은 라인 탐지

context builder의 ground truth 기반 재계획

━━━━━━━━━━━━━━━━━━━━━━━━━━
5. 최종 결론
━━━━━━━━━━━━━━━━━━━━━━━━━━

Cursor/SOTA급 코드 에이전트를 만들려면 필요한 핵심 요소는 딱 3개다.

툴 레이어 (강력한 API 표면)

code_search, propose_patch, run_tests

모든 기능은 툴로 모듈화

LangGraph 기반 상태 머신 워크플로우

planner → tool_router → tool → reviewer → planner

“툴은 LLM이 쓰고, 제어는 시스템이 한다”를 보장

Semantica Codegraph 기반 context builder

codegraph가 있어서 Cursor보다 훨씬 정교한 분석 가능

이 조합이면 Cursor 수준은 물론이고,
Semantica 특유의 Graph 기반 분석 덕분에 Cursor보다 더 센 코드 에이전트를 만들 수 있음.
