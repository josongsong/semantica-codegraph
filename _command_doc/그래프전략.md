# Semantica v2: Graph Construction Spec (Unified)

AST/심볼 테이블에서 호출·참조·정의 그래프를 생성해 GraphNodeRecord / GraphEdgeRecord / GraphDelta로 변환하는 규칙을 정의함. 이 스펙은 Graph Construction Layer 전용이며, Indexing Layer에는 결과 객체와 Delta만 전달됨.

Graph는 아래 유즈케이스들을 모두 지원할 수 있는 최소·일관된 구조를 목표로 설계함.

**코드 이해**: 함수 콜트리/역콜트리, 엔드투엔드 요청 플로우, 타입 구조, 객체 생성/데코레이터 경로

**리팩토링**: rename/시그니처 변경 영향, dead code 탐지, 모듈 분리, enum/상수 사용 경로

**테스트/품질**: Test Impact Analysis, 미커버 코드, mock 지점, 커버리지 구멍 탐지

**안정성/보안**: 취약점 전파, 비동기/스레드 흐름, 예외 전파, 외부 API 경로

**구조 분석**: 시스템 아키텍처 역추출, 도메인/팀 경계, 계층 규칙 위반 탐지

**AI/자동화**: GraphRAG 검색, 리팩토링 경로 추천, 자동 다이어그램, agent reasoning 강화

**코드 진단/정책**: 복잡도·핫스팟·중복, 레거시/버전/오너십, 에러 트레이스 분석

---

# 1. Scope & Responsibilities

## 1-1. Scope

**입력**
- Parser/Chunking 단계에서 생성된 AST, Symbol 정보, CodeNode/Chunk 메타데이터

**출력**
- GraphNodeRecord 목록 (전체 스냅샷)
- GraphEdgeRecord 목록 (전체 스냅샷)
- GraphDelta 목록 (이전 세대 그래프와 비교한 증분)

**대상 언어**
- v1: Python, TypeScript/JavaScript
- v2+: Go 등 확장 가능

## 1-2. Responsibilities (해야 하는 것)

- AST/심볼로부터 정규화된 Node/Edge 그래프를 구성
- 최소·표준 Edge Type 세트를 일관되게 생성
- 이름 해석(Name Resolution) 결과를 반영한 FQN 기반 연결 보장
- 이전 세대 그래프와 비교하여 GraphDelta(INSERT/UPDATE/DELETE) 생성
- 상위 유즈케이스(콜트리, 라우트→핸들러, 타입 구조, import graph 등)에 필요한 관계를 모두 표현

## 1-3. Non-Responsibilities (하지 않는 것)

- 그래프를 물리 DB(Kùzu 등)에 저장하는 작업
- 그래프 탐색·쿼리·분석 (경로 탐색, 영향 범위 분석 등)
- Chunk/요약 생성, 인덱싱, 검색, 에이전트 동작

---

# 2. 입력/출력 계약 (Contracts)

## 2-1. 입력 모델

**AST**
- 언어별 tree-sitter AST (또는 동등한 구조)
- 파일 단위로 제공

**Symbol Table** (선택이지만 v1에서는 사실상 필수로 간주)
- 파일/모듈별로 심볼 정의 및 참조 정보
- 예: symbol_name, kind(function/class/method/var), defining_scope, file_path, span, resolved_target(FQN 또는 node_id)

**Code Metadata**
- repo_id, namespace, file_path, language
- CodeNode/Chunk ID, Parent/Leaf 관계

## 2-2. 출력 모델 (GraphRecord)

### GraphNodeRecord

| Field | Type | Description |
|-------|------|-------------|
| id | string | Node ID (FQN 또는 chunk_id 기반) |
| repo_id | string | 저장소 ID |
| namespace | string | 네임스페이스 (브랜치 등) |
| kind | string | file/class/function/method/chunk 등 |
| attrs | dict | 언어/타입별 부가 정보 (JSON 직렬화 가능 구조) |

### GraphEdgeRecord

| Field | Type | Description |
|-------|------|-------------|
| id | string | Edge ID (src_id+dst_id+edge_type 기반) |
| repo_id | string | 저장소 ID |
| namespace | string | 네임스페이스 |
| src_id | string | 소스 Node ID |
| dst_id | string | 대상 Node ID (unresolved 시 synthetic ID) |
| edge_type | string | 관계 타입 (아래 4장 참조) |
| attrs | dict | 부가 정보 (callsite, unresolved flag 등) |

### GraphDeltaItem (flat 형태)

```python
class GraphDeltaOp(str, Enum):
    INSERT = "insert"
    UPDATE = "update"
    DELETE = "delete"

class GraphDeltaItem(BaseModel):
    op: GraphDeltaOp                  # insert/update/delete
    kind: Literal["node", "edge"]     # 노드/엣지
    record: GraphNodeRecord | GraphEdgeRecord

# Graph Construction → Indexing 으로 건네는 단위는 list[GraphDeltaItem]
```

Graph Construction Layer는 새 스냅샷 전체(nodes, edges)와 함께 Delta 목록(list[GraphDeltaItem])도 생성할 수 있음.

---

# 3. Node 생성 스펙 (AST → GraphNodeRecord)

## 3-1. Node Kind 정의

**file**
- 하나의 소스 파일마다 1개 생성
- id: `file://{repo_id}/{namespace}/{file_path}`

**class**
- ClassDef (Python), ClassDeclaration (TS/JS)
- id: FQN 기반 (예: `py://pkg.module.ClassName`)

**function**
- 최상위 함수 (모듈 레벨)
- id: `py://pkg.module.func_name`

**method**
- 클래스 내부 함수
- id: `py://pkg.module.ClassName.method_name`

**chunk** (선택)
- ParentChunk/LeafChunk와 연결하고 싶은 경우 사용
- id: `chunk://{repo_id}/{chunk_id}`

## 3-2. Node attrs 공통 필드

각 Node는 attrs에 최소한 다음 정보 포함해야 함.

### file 노드
- `file_path`: string
- `language`: string
- `span`: { start_line, end_line }
- `hash`: source_file_hash

### class/function/method 노드
- `name`: string
- `fqn`: string (Fully Qualified Name)
- `file_path`: string
- `span`: { start_line, end_line }
- `visibility`: public | protected | private (언어 지원 시)
- `is_async`: bool (지원 언어에 한함)

### chunk 노드
- `chunk_id`: string
- `chunk_kind`: parent | leaf
- `file_path`: string
- `span`: { start_line, end_line }

추가로, 고급 유즈케이스를 위한 메타데이터는 필요 시 attrs에 확장함.

**복잡도/품질**: complexity, fan_in, fan_out, churn, hotspot_score

**오너십/정책**: owner_team, owner_user, is_legacy, version_tag

---

# 4. Edge 타입 및 생성 규칙

## 4-1. Edge Type 표준 세트 (코어)

**코어 그래프 타입 (v1 MUST)**:

- **contains** – 물리/논리 계층 포함 관계 (file→symbol, class→method 등)
- **defines** – 심볼 정의 관계 (file→class/function, class→method)
- **calls** – 함수/메서드/함수형 값 호출 관계
- **imports** – 모듈/심볼 import 관계
- **inherits** – 클래스 상속 관계
- **implements** – 인터페이스 구현 (TS 등)
- **overrides** – 메서드 오버라이드
- **references** – 변수/필드/심볼 참조
- **instantiates** – 객체 생성(new/생성자/팩토리)
- **decorates** – 데코레이터/어노테이션이 적용된 대상
- **route_handler** – HTTP/CLI/이벤트 라우트 → 핸들러 매핑
- **external_call** – 외부 서비스/API 호출 (HTTP/gRPC 등)
- **throws** – 예외/에러를 발생시키는 위치 → 예외 타입
- **catches** – 예외 핸들러 → 예외 타입/소스
- **spawns** – 비동기 작업/스레드/goroutine 생성 관계
- **test_targets** – 테스트 함수/케이스 → 대상 코드 (테스트 영향 분석용)
- **module_depends** – 모듈/패키지 간 의존 관계 (import 압축)

**파생/역방향 그래프는 쿼리 시 계산이 기본 원칙**임.

- `called_by` = calls의 역방향 뷰
- `imported_by` = imports의 역방향 뷰

필요하다면 Indexing/Retriever 레벨에서 물리적으로 역방향 인덱스를 생성할 수 있으나, Graph Construction Spec에서는 정방향 Edge만 생성하는 것을 기본으로 함.

## 4-2. contains Edge 생성 규칙

**file → class/function/method**
- 조건: 심볼의 file_path가 해당 file 노드와 동일
- src: file node
- dst: class/function/method node

**class → method**
- 조건: method의 parent class가 해당 class
- src: class node
- dst: method node

**parent_chunk → leaf_chunk** (선택)
- src: parent chunk node
- dst: leaf chunk node

## 4-3. defines Edge 생성 규칙

**file → class/function 정의**
- src: file node
- dst: 정의된 class/function node
- attrs.symbol_name: 심볼 이름

**class → method 정의**
- src: class node
- dst: method node

`contains` 와 `defines` 는 겹칠 수 있음. 둘 다 유지해서 "계층 구조"와 "정의 행위"를 분리함.

## 4-4. imports / module_depends Edge 생성 규칙

**Python Import / ImportFrom**

예: `from a import b as c`

- src: 현재 파일 file node
- dst: 대상 모듈/심볼 노드 (해결된 경우)
- attrs:
  - `import_kind`: module | symbol
  - `name`: 실제 import 이름 (b)
  - `alias`: 별칭 (c 또는 null)
  - `raw`: 원본 문자열

**TS/JS ESModule/CJS**

예: `import x from 'lib/x'`, `const y = require('lib/y')`

FQN 해석 실패 시에도 edge는 생성하고, `attrs.unresolved = true` 플래그 세팅.

`module_depends`는 파일 단위 imports를 모듈/패키지 단위로 집계한 압축 그래프이며, Graph Construction Layer에서는 옵션으로 생성 가능 (RepoMap/분석 용도).

## 4-5. calls / instantiates / external_call Edge 생성 규칙

**AST의 CallExpression 기반**
- Python: ast.Call
- TS/JS: CallExpression, NewExpression

**대상 심볼 찾기 순서**
1. 심볼 테이블에서 callee 이름으로 조회 (로컬 스코프 → 상위 스코프 → import 순)
2. 이름 해석 성공 시 resolved_target.fqn 사용
3. 실패 시 unresolved 플래그

**Edge 필드 (함수 호출)**
- edge_type = "calls"
- src: 호출하는 함수/메서드 node_id
- dst: 피호출 함수/메서드 node_id (또는 unresolved_placeholder)
- attrs:
  - `callee_name`: 문자열 (raw)
  - `call_site`: { file_path, line, column }
  - `is_method_call`: bool
  - `is_constructor_call`: bool (TS/JS new)
  - `unresolved`: bool

**객체 생성 / instantiates**

`new ClassName(...)`, `ClassName(...)` 패턴, 팩토리 함수 등에서 생성 대상이 class/타입으로 해석되면

- edge_type = "instantiates"
- src: 호출하는 함수/메서드 node_id
- dst: 생성되는 class/타입 node_id

**외부 서비스 호출 / external_call**

HTTP/gRPC 클라이언트 wrapper를 통과하는 함수 호출로 식별 (예: `http_client.get()`, `grpc_client.Search()`)

- edge_type = "external_call"
- src: 호출하는 함수/메서드 node_id
- dst: synthetic 노드 혹은 서비스 엔드포인트 노드 (예: `svc://search-service.Search`)
- attrs:
  - `protocol`: http | grpc | kafka | other
  - `endpoint`: URL or method name
  - `unresolved`: bool

## 4-6. inherits / implements / overrides Edge 생성 규칙

**클래스 상속 (inherits)**
- Python: ClassDef.bases
- TS/JS: HeritageClause (extends)
- src: child class node
- dst: parent class node (해석 성공 시)
- attrs:
  - `base_expr`: 원본 문자열
  - `unresolved`: bool

**인터페이스 구현 (implements)**
- TS/JS 등
- edge_type = "implements"
- src: 구현 클래스 node
- dst: 인터페이스 node

**메서드 오버라이드 (overrides)**

전제: inherits 그래프 구축 완료

각 method 노드에 대해:
1. 자신의 클래스가 상속하는 모든 부모 클래스(MRO 순회)를 탐색
2. 동일 메서드 이름을 가진 부모 메서드가 존재하면
   - src: child method node
   - dst: parent method node
   - attrs:
     - `method_name`
     - `via_class`: child class fqn

## 4-7. references Edge 생성 규칙

Identifier/Attribute 사용 위치 기반 (변수, 필드, 모듈 심볼 등)

**해석 규칙**
- 심볼 테이블에서 identifier → 정의 노드 매핑 시도

**Edge 필드**
- edge_type = "references"
- src: 참조가 발생한 함수/메서드/파일 node
- dst: 참조 대상 node (없으면 unresolved synthetic)
- attrs:
  - `name`: 식별자 이름
  - `ref_site`: { file_path, line, column }
  - `kind`: local | field | global | param
  - `unresolved`: bool

## 4-8. route_handler Edge 생성 규칙

HTTP/CLI/이벤트 라우팅 → 실제 핸들러 매핑을 표현.

**HTTP 라우트 (FastAPI/Express 등)**

예: `router.post("/hybrid/search", handler)`

- edge_type = "route_handler"
- src: route 노드 (optional, 없으면 synthetic route node)
- dst: handler 함수 node (function 또는 method)
- attrs:
  - `http_method`: GET | POST | ...
  - `path`: /hybrid/search
  - `framework`: fastapi | express | ...

**CLI/배치/스케줄러**

CLI command, cron job, scheduler entry → 해당 handler 함수에 route_handler edge 생성

## 4-9. throws / catches / spawns / test_targets Edge 생성 규칙

**예외 발생 (throws)**
- raise, throw 구문을 통해 특정 예외 타입이 발생하는 위치
- edge_type = "throws"
- src: 예외를 던지는 함수/메서드 node
- dst: 예외 타입 node (혹은 synthetic)

**예외 처리 (catches)**
- try/except, try/catch 블록
- src: 예외 핸들러 블록/함수 node
- dst: 처리 대상 예외 타입 node

**비동기/스레드 생성 (spawns)**
- goroutine, thread, async task 생성
- edge_type = "spawns"
- src: 생성 호출이 있는 함수/메서드
- dst: 실행될 함수/루틴 node

**테스트 → 대상 코드 (test_targets)**
- 테스트 함수/케이스에서 호출되는 주요 엔트리포인트 함수에 대해 test_targets edge 추가 (옵션)

---

# 5. 이름 해석(Name Resolution) 및 FQN 규칙

## 5-1. FQN 규칙 (Python)

- 모듈: `py://{package}.{module}`
- 클래스: `py://{package}.{module}.{ClassName}`
- 함수: `py://{package}.{module}.{func_name}`
- 메서드: `py://{package}.{module}.{ClassName}.{method_name}`

## 5-2. FQN 규칙 (TypeScript/JS)

- 파일 스코프: `ts://{path_without_ext}`
- 이름 있는 export: `ts://{path}.{exportedName}`
- 클래스/메서드: `.ClassName`, `.methodName` 계층 추가

**ID 안정성 원칙**

- Node의 ID는 FQN 기반이어야 함.
- 파일 내 라인 번호가 변경되어도 FQN이 동일하면 Node ID는 유지되어야 함.
- Delta 연산의 안정성을 위해, FQN이 바뀌는 경우에만 Node ID가 변경되도록 설계.

## 5-3. 이름 해석 알고리즘 개요

1. **로컬 스코프**: 함수 파라미터, 로컬 변수, comprehension 변수 등
2. **클래스/인스턴스 스코프**: self/this 속성, 클래스 속성
3. **모듈 스코프**: 파일 상단 정의, import로 유입된 심볼
4. **패키지/외부 모듈**: import 경로 기반 후보 탐색

## 5-4. Unresolved ID 표준화

해결 결과가 없으면:

- `attrs.unresolved = true`
- `dst_id`는 `unresolved://{repo_id}/{namespace}/{file_path}/{identifier_hash}` 형태 synthetic Node ID 사용 (null 금지)

---

# 6. GraphBuildResult & Delta 생성 스펙

## 6-1. GraphBuildResult

```python
class GraphBuildResult(BaseModel):
    repo_id: str
    file_path: str | None = None   # 파일 단위 빌드 시

    nodes: list[GraphNodeRecord] = []
    edges: list[GraphEdgeRecord] = []
    deltas: list[GraphDeltaItem] = []  # optional

    node_count: int = 0
    edge_count: int = 0
    processing_time_ms: float | None = None

    success: bool = True
    errors: list[str] = []
```

Repo 단위 Full Build의 경우 file_path=None, 여러 파일 결과를 합산해서 사용.

## 6-2. Delta 생성 기준

**Delta Type 정의**:

- **INSERT**: 새 Node/Edge 추가
- **UPDATE**: 동일 id의 Node/Edge가 존재하지만 attrs가 변경
- **DELETE**: 이전 세대에는 존재했으나, 새 그래프에는 없음

**비교 기준**:

**Node**
- key: (repo_id, namespace, id)
- 비교 필드: kind, attrs (결정론적 hash 기반)

**Edge**
- key: (repo_id, namespace, id)
- 비교 필드: src_id, dst_id, edge_type, attrs

## 6-3. Delta 생성 의사코드 (개선 버전)

```python
import hashlib, json


def calculate_attrs_hash(attrs: dict) -> str:
    serialized = json.dumps(attrs or {}, sort_keys=True)
    return hashlib.sha256(serialized.encode("utf-8")).hexdigest()


def build_graph_deltas(
    old_nodes: list[GraphNodeRecord],
    old_edges: list[GraphEdgeRecord],
    new_nodes: list[GraphNodeRecord],
    new_edges: list[GraphEdgeRecord],
) -> list[GraphDeltaItem]:
    deltas: list[GraphDeltaItem] = []

    # 1. Node Delta
    old_node_map = {n.id: n for n in old_nodes}
    new_node_map = {n.id: n for n in new_nodes}

    for nid, new_node in new_node_map.items():
        old_node = old_node_map.get(nid)
        if old_node is None:
            deltas.append(GraphDeltaItem(op="insert", kind="node", record=new_node))
        elif calculate_attrs_hash(old_node.attrs) != calculate_attrs_hash(new_node.attrs):
            deltas.append(GraphDeltaItem(op="update", kind="node", record=new_node))

    for nid, old_node in old_node_map.items():
        if nid not in new_node_map:
            deltas.append(GraphDeltaItem(op="delete", kind="node", record=old_node))

    # 2. Edge Delta
    old_edge_map = {e.id: e for e in old_edges}
    new_edge_map = {e.id: e for e in new_edges}

    for eid, new_edge in new_edge_map.items():
        old_edge = old_edge_map.get(eid)
        if old_edge is None:
            deltas.append(GraphDeltaItem(op="insert", kind="edge", record=new_edge))
        else:
            if (
                old_edge.src_id != new_edge.src_id
                or old_edge.dst_id != new_edge.dst_id
                or old_edge.edge_type != new_edge.edge_type
                or calculate_attrs_hash(old_edge.attrs) != calculate_attrs_hash(new_edge.attrs)
            ):
                deltas.append(GraphDeltaItem(op="update", kind="edge", record=new_edge))

    for eid, old_edge in old_edge_map.items():
        if eid not in new_edge_map:
            deltas.append(GraphDeltaItem(op="delete", kind="edge", record=old_edge))

    return deltas
```

## 6-4. Delta 생성 시 주의사항

- 같은 파일 내 변경은 하나의 Graph 빌드 패스로 처리 (파일 단위 재생성)
- Node/Edge id는 언어/파일 변경에 강건해야 함
  - 라인 번호가 바뀌어도 FQN이 같으면 동일 id 유지
- attrs 비교는 전체 dict에 대한 결정론적 해시 사용
- Edge의 id는 (src_id, dst_id, edge_type) 기반이므로, 이 중 하나라도 바뀌면 삭제+삽입 시맨틱으로 처리됨

---

# 7. 유즈케이스 매핑 (Coverage Map)

아래 표는 주요 유즈케이스를 이 Graph 스펙에서 어떤 Node/Edge 조합으로 해결하는지 요약함.

## 7-1. 코드 이해 / 리팩토링

**함수 콜트리(forward)**
- 사용 Edge: calls
- 설명: 함수/메서드 node에서 calls 를 따라 DFS/BFS → forward call tree 구성

**함수 called-by 트리(backward)**
- 사용 Edge: calls (역방향 조회)
- 설명: 특정 함수 node를 dst_id로 가지는 calls edge 역탐색

**엔드투엔드 요청 플로우** (route → handler → service → repo → DB)
- 사용 Edge: route_handler, calls, external_call, instantiates
- 설명: route node에서 시작해 handler → service → store → DB client까지 call chain 탐색

**계층 간 흐름**(UI/CLI → 도메인 → DB)
- 사용 Edge: contains, calls, external_call

**타입 구조 분석**
- 사용 Edge: inherits, implements, overrides

**객체 생성 경로**
- 사용 Edge: instantiates

**데코레이터/어노테이션 연결**
- 사용 Edge: decorates (필요 시 확장)

**rename/시그니처 변경 영향**
- 사용 Edge: calls, implements, overrides, references

## 7-2. 테스트/품질 / 구조 분석

**Test Impact Analysis**
- 사용 Edge: test_targets, calls, contains

**테스트 미도달 코드 / dead code**
- 사용 Edge: calls, route_handler, test_targets
- 테스트/엔트리포인트에서 도달 불가능한 node 탐색

**모듈 분리/MSA 전환, 의존도 분석**
- 사용 Edge: imports, module_depends
- 모듈/패키지 그래프에서 in-degree/out-degree, cycle 분석

**enum/constant 사용 경로**
- 사용 Edge: references

## 7-3. 안정성/보안 / 정책

**취약점 전파 경로**
- 사용 Edge: calls, external_call, 필요 시 dataflow edge (v2+)

**예외 전파/핸들링 흐름**
- 사용 Edge: throws, catches, calls

**외부 API 호출 경로**
- 사용 Edge: external_call, calls, route_handler

**계층 규칙 위반 탐지**
- 사용 Edge: contains, imports, calls
- 예: Controller → Repo 직접 호출 패턴 규칙화 가능

## 7-4. AI/자동화 / GraphRAG

**GraphRAG 기반 검색**
- 사용 Node: function, class, chunk
- 사용 Edge: contains, defines, calls, imports, inherits

**자동 문서/다이어그램 생성**
- 사용 Edge: route_handler, calls, contains, external_call

**자동 리팩토링 경로 계획, agent reasoning 강화**
- 동일 Edge를 사용해 영향 범위/경로를 LLM에게 구조적으로 제공

---

# 8. Indexing Layer와의 계약 요약

Graph Construction Layer는 다음을 보장해야 함.

- Node/Edge ID는 (repo_id, namespace) 내에서 유일
- Edge type은 본 스펙에 정의된 문자열 집합 내에서만 사용
- unresolved 상태도 모두 edge로 표현하고 attrs.unresolved 플래그를 세팅
- GraphDeltaItem 리스트에는 INSERT/UPDATE/DELETE만 포함 (NOOP 없음)
- 동일 run 내에서 Node/Edge 전체 스냅샷과 Delta의 기준이 일치
- GraphNodeRecord/GraphEdgeRecord는 그대로 Kùzu 등에 upsert 가능한 형태

Indexing Layer는 이 스펙을 전제로:

- GraphRecord → Kùzu Node/Edge 매핑
- GraphDeltaItem → upsert/delete 연산 변환
- 역방향 인덱스(called_by, imported_by)나 고급 쿼리 인덱스는 물리 계층에서 자유롭게 최적화

---

# 9. 구현 우선순위 (v1 vs v2+)

## v1 MUST (코어 기능):

- Node 모델: file / class / function / method / chunk
- Edge 모델: contains / defines / calls / imports / inherits / implements / overrides / references / route_handler
- Python/TS 기본 Name Resolution + FQN ID 규칙
- GraphBuildResult + Delta 생성 (파일 단위)
- 엔드투엔드 콜트리 / 라우트→핸들러 / 타입 구조 / import graph 유즈케이스 만족

## v2+ SHOULD (확장 기능):

- instantiates / external_call / throws / catches / spawns / test_targets
- module_depends 압축 그래프 및 패키지 복잡도 분석
- 복잡도/핫스팟/오너십 메타데이터 계산 및 attrs 통합
- Test Impact Analysis / dead code / 보안 규칙 위반 자동 탐지

---

**이 스펙을 만족하면, Graph Construction Layer는 언어별 구현 차이를 내부에 숨긴 채, Indexing/Retriever/Agent 레이어가 요구하는 고급 유즈케이스를 모두 지원할 수 있는 일관된 코드 그래프 계약을 제공하게 됨.**
