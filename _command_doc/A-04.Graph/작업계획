# Semantica CodeGraph v2 – SOTA CodeGraph 설계·구현 플랜 (Rev. 2.2)

> 목표: **IR v4 → SOTA CodeGraph → Chunk → RepoMap → Index → Retriever**까지 일관된 계약 기반으로 설계/구현하고, 이후 프레임워크·런타임·요약(Graph 확장 레이어)을 무리 없이 붙일 수 있는 구조를 확보하는 것임.

---

## 1. 전체 아키텍처 개요

1. IR Layer (v4)
2. Core CodeGraph Layer (구조·호출·타입·데이터/제어 흐름)
3. Extended CodeGraph Layer (Framework / Runtime / Semantic Summary)
4. Chunk Layer (LLM-Friendly 계층)
5. RepoMap Layer (구조 요약 + 중요도)
6. Index Layer (Lexical / Vector / Symbol / Fuzzy / Domain / Runtime)
7. Retriever Layer (Intent → Multi-Index → Graph Expansion → Fusion → Context)

모든 상위 레이어(Chunk, RepoMap, Index, Retriever)는 **GraphDocument 계약만 보고 동작**하도록 설계함.

확장성은 다음 축을 기준으로 고려함.

* 언어 확장: Python → TypeScript/JavaScript → 이후 언어 추가 가능
* 도메인 확장: 코드 → 프레임워크 관계 → 런타임(trace, error) → 도메인(이커머스, 법률 등)
* 기능 확장: 정적 분석 → 프레임워크 해석 → 런타임 오버레이 → 의미 그래프

---

## 2. Core CodeGraph 설계 (청킹 이전의 최종 그래프 계약)

### 2-1. 입력/출력 계약

* 입력

  * IRDocument 리스트 (IR v4 스키마)

    * ir_nodes: File, Class, Function, Method, Variable, Field, Import, Route, Service, Repo 등 CodeSymbol
    * ir_edges: CONTAINS, CALLS, IMPORTS, READS, WRITES 등
    * ir_types: IRTypeEntity
    * ir_signatures: IRSignatureEntity
    * cfg_graphs: IRCFGBlock, IRCFGEdge

* 출력

  * GraphDocument

    * graph_nodes: dict[GraphNodeId, GraphNode]
    * graph_edges: list[GraphEdge]
    * cfg_graphs: list[CFGGraph] (IR에서 그대로 포함)
    * indexes: GraphIndex (reverse index, adjacency 등)

### 2-2. GraphNode 스키마

* kind

  * File, Class, Function, Method, Variable, Field, Import, Module,
  * ExternalModule, ExternalFunction,
  * Type, Signature,
  * CfgBlock,
  * Route, Service, Repository, Config, Job, Middleware,
  * Summary,
  * RuntimeSpan, ErrorSite (확장 레이어용)

* 주요 필드

  * id: str (GraphNodeId, FQN 기반 안정 ID)
  * kind: Literal
  * repo_id: str
  * snapshot_id: Optional[str]
  * fqn: str
  * name: str
  * path: Optional[str]
  * span_start_line, span_end_line: Optional[int]
  * attrs: dict (언어/프레임워크/도메인 메타데이터)

* Module Node 생성 규칙

  * IR에서 직접 주지 않고, Graph Construction Layer가 File.path로 생성
  * 예: src/search/retriever/query.py → module:src.search.retriever

### 2-3. GraphEdge 스키마

* 필드

  * id: str (kind + source + target + unique_signature 해시)
  * kind: Literal
  * source_id, target_id: GraphNodeId
  * attrs: dict

* Edge Kind

  * 구조·타입·흐름 기본

    * CONTAINS, CALLS, IMPORTS,
    * INHERITS, IMPLEMENTS,
    * REFERENCES_TYPE, REFERENCES_SYMBOL,
    * READS, WRITES,
    * CFG_NEXT, CFG_BRANCH, CFG_LOOP, CFG_HANDLER
  * 프레임워크/아키텍처 확장

    * ROUTE_HANDLER (Route → Handler Function/Method)
    * HANDLES_REQUEST (Handler → Service)
    * USES_REPOSITORY (Service → Repository)
    * MIDDLEWARE_NEXT (Middleware 체인)
  * 객체 생성/데코레이터

    * INSTANTIATES (Function/CfgBlock → Class)
    * DECORATES (Decorator → Decorated symbol)
  * 런타임/요약/의미 확장 (후속 Phase)

    * EXECUTES (RuntimeSpan → CfgBlock/Function)
    * THROWS (CodeSymbol/Block → ErrorSite)
    * AFFECTS (ErrorSite → Downstream Symbol)
    * SUMMARIZES (Summary → 대상 GraphNode)
    * SEMANTIC_NEIGHBOR (의미 기반 인접 심볼)

### 2-4. GraphDelta

* 필드

  * target: GraphNodeRecord or GraphEdgeRecord
  * op: "INSERT" | "UPDATE" | "DELETE"
* 단위

  * snapshot_id(커밋) 기준으로 delta 묶음 생성

### 2-5. ID 규칙

* GraphNodeId

  * 내부 심볼: `{lang}:{repo_id}:{kind}:{fqn}`
  * 외부 모듈: `external:{lang}:module:{module_name}`
  * 외부 함수: `external:{lang}:function:{fqn}`
  * 타입: `{lang}:{repo_id}:type:{type_fqn}`
  * 시그니처: `{lang}:{repo_id}:sig:{symbol_fqn}`
  * CFGBlock: `{lang}:{repo_id}:cfg:{func_fqn}:block:{block_id}`
  * Placeholder: `unresolved://{repo_id}/{namespace}/{file_path}/{identifier_hash}`

* GraphEdgeId

  * `hash("{kind}:{source}->{target}:{unique_signature}")`

### 2-6. GraphIndex 스키마

* Reverse Index

  * called_by: target_id → [source_ids] (CALLS)
  * imported_by: module_id → [importer_ids]
  * contains_children: parent_id → [child_ids]
  * type_users: type_id → [symbol_ids] (REFERENCES_TYPE)
  * reads_by: variable_id → [cfg_block_ids]
  * writes_by: variable_id → [cfg_block_ids]
  * error_by_symbol: symbol_id → [error_site_ids] (확장)

* Adjacency Index

  * outgoing: node_id → [edge_ids]
  * incoming: node_id → [edge_ids]

* 도메인/프레임워크/런타임 인덱스 (SOTA 확장용)

  * routes_by_path: path → [route_ids]
  * services_by_domain: domain_tag → [service_ids]
  * request_flow_index: route_id → [handler_id, service_ids, repository_ids]
  * runtime_hot_by_symbol: symbol_id → hot_score

### 2-7. GraphDocument 최종 정의

* GraphDocument

  * repo_id: str
  * graph_nodes: dict[GraphNodeId, GraphNode]
  * graph_edges: list[GraphEdge]
  * cfg_graphs: list[CFGGraph]
  * indexes: GraphIndex

---

## 3. Graph Construction 구현 플랜 (IR → Graph, Pre-Chunk)

### 3-1. Phase G1: Node 생성

* G1-1. CodeSymbol → GraphNode

  * 대상: File, Class, Function, Method, Variable, Field, Import, Route, Service, Repo 등
  * IRNode.kind → GraphNode.kind 매핑 테이블 기반 생성

* G1-2. IRType → Type Node

  * id: `{lang}:{repo_id}:type:{type_fqn}`
  * attrs: raw_type, generic_params, is_builtin, is_local 등

* G1-3. IRSignature → Signature Node

  * id: `{lang}:{repo_id}:sig:{symbol_fqn}`
  * attrs: parameters, return_type, is_async, decorators 정보 등

* G1-4. CFGBlock → CfgBlock Node

  * id: `{lang}:{repo_id}:cfg:{func_fqn}:block:{block_id}`

* G1-5. Module Node 생성

  * File.path 기반으로 module fqn 계산 후 Module Node 생성

* G1-6. External Node 생성 (Lazy)

  * CALL/IMPORT 해석 시 로컬 심볼 없으면 ExternalModule/ExternalFunction 생성

### 3-2. Phase G2: Edge 생성

* 구조적 Edge

  * CONTAINS: IR CONTAINS를 그대로 변환 (파일→클래스, 클래스→함수 등)
  * IMPORTS: 로컬이면 대상 Node, 없으면 ExternalModule로 연결
  * INHERITS / IMPLEMENTS: Class.bases FQN 해석 후 연결

* 호출/참조 Edge

  * CALLS: IR CALLS Edge를 변환, identifier/attribute/alias call 처리
  * REFERENCES_TYPE: declared_type, return_type, parameter_type → Type Node
  * REFERENCES_SYMBOL: 변수/함수 심볼 사용처 → 정의로 연결 (정적 해석 가능한 것만)

* 데이터/제어 흐름 Edge

  * READS / WRITES: DFG/IR READS/WRITES Edge 기반, source=CfgBlock, target=Variable/Field
  * CFG_NEXT / CFG_BRANCH / CFG_LOOP / CFG_HANDLER: CFGGraph에서 변환

* 프레임워크 Edge (확장 레이어, v2.2에서 최소 세트 구현)

  * ROUTE_HANDLER: Route → Handler Function/Method (FastAPI/Express 등 라우터 메타 기반)
  * HANDLES_REQUEST: Handler → Service (DI/레이어 규칙 기반)
  * USES_REPOSITORY: Service → Repository (명명 규칙 혹은 어노테이션 기반)
  * MIDDLEWARE_NEXT: Middleware 체인 순서 연결

* 객체/데코레이터 Edge

  * INSTANTIATES: new, **init**, constructor 패턴으로 Class 인스턴스화 위치 연결
  * DECORATES: decorator → decorated symbol (FastAPI route, Django view, pytest fixture 등)

### 3-3. Phase G3: Normalization 및 Index 생성

* Edge 중복 제거

  * (kind, source_id, target_id, unique_signature) 기준으로 dedupe

* GraphIndex 생성

  * Reverse Index, Adjacency Index 전부 GraphDocument 내부에서 생성
  * request_flow_index는 ROUTE_HANDLER, HANDLES_REQUEST, USES_REPOSITORY를 조합해 파생 인덱스로 생성

* Consistency Check

  * dangling edge, 잘못된 external repo_id, FileNode 다중 부모 CONTAINS 등 제거/로그

---

## 4. Chunk / RepoMap / Index / Retriever 연계 설계

### 4-1. Chunk Layer (Graph 기반 Chunking)

* LeafChunk = Function/Method GraphNode 기준 1:1 생성
* Class/File/Module/Project/Repo Chunk는 **GraphNode 집계 결과**로 구성
* ChunkToGraph, ChunkToIR 맵을 생성해 GraphDocument 기준으로만 추적
* git diff/증분 인덱싱 시, GraphDelta → 영향받은 Chunk만 재생성

### 4-2. RepoMap Layer

* 입력: GraphDocument + Chunk 계층 + IRDocument 메타
* RepoMapNode = Chunk + Graph 중요도 신호 (CALLS, IMPORTS, INDEGREE 등)
* PageRank/HybridRank에서 GraphIndex만 사용 (GraphDocument가 단일 진실원천)

### 4-3. Index Layer

* Lexical / Vector / Symbol / Fuzzy / Domain / Runtime 인덱스는 전부

  * GraphDocument + Chunk 메타를 기반으로 생성
* Symbol Index는 GraphNode(심볼) + GraphEdge(CALLS, REFERENCES_SYMBOL) 기반
* Runtime Index는 RuntimeSpan/ErrorSite Node와 EXECUTES/THROWS Edge를 오버레이

### 4-4. Retriever Layer

* Intent Router

  * definition / usage / call chain / route flow / error 분석 등
* Multi-Index Query

  * GraphIndex + 일반 인덱스 병행 사용
* Graph Expansion

  * called_by, contains_children, request_flow_index를 이용해 k-hop 확장
* Fusion + Context Builder

  * LeafChunk + ParentChunk를 Graph 기반으로 묶어 LLM context 패키지 생성

---

## 5. 구현 Phase 플랜 (실행 순서)

### Phase 0. Skeleton & Contracts

* src/foundation/{parsing,ir,cfg,dfg,graph,chunk}
* src/{repomap,index,retriever}
* IR/Graph/Chunk 공통 모델 파일 생성

### Phase 1. IR v4 정리

* IRNode/IRType/IRSignature/IRDocument 확정
* CFG/DFG 최소 스펙 정리 (block, edge)

### Phase 2. Core CodeGraph (v2.1)

* Node: CodeSymbol, Type, Signature, CfgBlock, Module, External
* Edge: CONTAINS, CALLS, IMPORTS, READS, WRITES, REFERENCES_TYPE, CFG_*
* GraphIndex: 기본 reverse/adjacency
* GraphDelta: snapshot 단위 diff

### Phase 3. Extended CodeGraph (v2.2 SOTA 최소 확장)

* Node: Route, Service, Repository, Summary
* Edge: ROUTE_HANDLER, HANDLES_REQUEST, USES_REPOSITORY, INSTANTIATES, DECORATES
* GraphIndex: routes_by_path, request_flow_index, services_by_domain
* attrs: layer, framework, domain_tags, weight, confidence, source_kind

### Phase 4. Chunk Layer

* Leaf/Parent Chunk 계층 구현
* ChunkToGraph, ChunkToIR 매핑 구현
* GraphDelta 기반 증분 청킹

### Phase 5. RepoMap Layer

* RepoMap 트리 생성기
* PageRank/HybridRank 기반 중요도 계산
* Repo/Project/Module/File 수준 Summary 생성 (Summary Node + SUMMARIZES Edge는 Phase 6에서 연결)

### Phase 6. Index Layer

* Lexical / Vector / Symbol / Fuzzy / Domain 인덱스 구현
* Runtime 인덱스 틀만 마련

### Phase 7. Retriever Layer

* Intent Router
* Multi-Index Query
* Graph Expansion (GraphIndex 활용)
* Fusion Reranker
* Context Builder

### Phase 8. Runtime·Semantic 확장 (v2.3+)

* RuntimeSpan, ErrorSite Node + EXECUTES/THROWS/AFFECTS Edge
* Summary Node + SUMMARIZES/SEMANTIC_NEIGHBOR Edge
* runtime_hot_by_symbol, error_by_symbol 인덱스 확장

---

## 6. 확장성 관점 코멘트

1. 그래프를 **Core Code Graph + Extended Graph(L2 Framework, L3 Runtime, L4 Semantic)**로 나누어 설계했기 때문에, 코드 해석 엔진은 Core만으로 완결되고, 프레임워크/런타임/요약 기능은 별도의 Phase로 천천히 붙여도 전체 계약이 깨지지 않도록 설계했음.

2. GraphDocument가 상위 레이어의 단일 진실원천(Single Source of Truth)이 되도록 했기 때문에, Chunk/RepoMap/Index/Retriever 구현체를 교체하거나 백엔드를 바꿔도 Graph 스펙만 유지하면 나머지 레이어는 재사용 가능함.

3. Node.kind와 Edge.kind를 충분히 일반화하면서도 최소한의 필수 집합으로 정의했기 때문에, 이후 다른 언어/프레임워크(예: Django, NestJS, Spring 등)를 추가할 때도 기존 Graph 계약을 확장하는 방식으로 대응 가능함.

4. Runtime/에러/요약(Summary) 관련 노드는 초기 버전에서는 선택적으로 비워둘 수 있고, 나중에 Phase 8에서 오버레이 형태로 붙이면 되도록 설계했음. 따라서 현재 단계에서는 정적 분석 기반 CodeGraph만으로도 안정적인 엔진을 완성할 수 있음.

5. 전체 플랜은 "먼저 IR → Core Graph → Chunk → RepoMap → Index → Retriever"까지를 최소 마일스톤으로 잡고, SOTA 확장 요소(Runtime, Semantic Summary, Framework Deep Integration)는 이후 버전에서 점진적으로 추가하는 전략을 전제로 함.
