1. 요약(High-level Summary)

Index Layer 목적은 Chunk/Graph 기반 구조를 검색 가능한 형태로 정규화하는 것임.

Lexical(Zoekt) / Vector(Qdrant) / Symbol(Kuzu) / Fuzzy(pg_trgm) / Domain / Runtime 인덱스를 모두 생산하고,

Retriever Layer가 weighted fusion으로 소비할 수 있도록 공통 Hit 스키마와 Port/DI 기반 계약을 제공함.

Zoekt를 Lexical Index의 단일 백엔드로 고정하며, snapshot 기반의 인덱스 일관성을 도입함.

ChunkIncrementalRefresher와 IR diff 정책(Span Drift, StableSymbolID 등)과 Index Layer 간의 연결을 정식 명시함.

2. 목적(Design Goals)

Chunk/IR/Graph 기반의 정규화된 IndexDocument 생성

Zoekt / Qdrant / Kuzu 기반의 6개 인덱스 만들기

모든 인덱스가 공통 SearchHit 스키마 제공

증분 인덱싱(Incremental Indexing) 지원

repo_id + snapshot_id 기반 완전한 인덱스 일관성

3. 전체 구조(Project Structure Alignment)
3-1. Foundation Layer (이미 존재)

src/foundation/chunk/* – Chunk builder, incremental, models

src/foundation/ir/* – IR v4

src/foundation/graph/* – GraphNodes, GraphEdges, GraphDelta

src/foundation/semantic_ir/* – CFG/Signature/Typing/DFG 등

3-2. Index Layer (신규 정리)
src/index/
  common/
    documents.py          # IndexDocument, SearchHit (공통 스키마)
    transformer.py        # Chunk→IndexDocument 변환기
  lexical/
    adapter_zoekt.py      # LexicalIndexPort 구현체
  vector/
    adapter_qdrant.py     # VectorIndexPort 구현체
  symbol/
    adapter_kuzu.py       # SymbolIndexPort 구현체 (Graph wrapper)
  fuzzy/
    adapter_pgtrgm.py     # FuzzyIndexPort 구현체
  domain/
    adapter_meta.py       # DomainMetaIndexPort 구현체
  runtime/
    adapter_runtime.py    # RuntimeIndexPort 구현체(Phase 2~3)
  service/
    indexing_service.py   # 전체 인덱싱 orchestrator

3-3. Ports (공식 계약)

src/ports.py

LexicalIndexPort

VectorIndexPort

SymbolIndexPort

FuzzyIndexPort

DomainMetaIndexPort

RuntimeIndexPort

IndexingServicePort

3-4. Infra Layer

src/infra/search/zoekt.py – Zoekt 통신/CLI wrapper

src/infra/vector/qdrant.py – Qdrant wrapper

src/infra/graph/kuzu.py – Kuzu wrapper

src/infra/storage/postgres.py – pg_trgm 및 metadata 저장

4. 핵심 스키마 정의
4-1. IndexDocument 스키마 (Zoekt 포함 모든 인덱스 공통)
class IndexDocument(BaseModel):
    id: str                         # = chunk_id (stable)
    repo_id: str
    snapshot_id: str                # 인덱스 단위 세대 (중요)
    file_path: str
    language: str

    symbol_id: str | None = None
    symbol_name: str | None = None

    content: str                    # summary + code + metadata
    identifiers: list[str] = []     # 함수명/클래스명 등
    tags: dict[str, str] = {}       # repomap_score, parent_chunk_id 등

4-2. SearchHit 스키마 (Retriever 소비용)
class SearchHit(BaseModel):
    chunk_id: str
    file_path: str
    symbol_id: str | None
    score: float
    source: Literal["lexical", "vector", "symbol", "fuzzy", "domain", "runtime"]
    metadata: dict[str, Any] = {}

5. Index Layer – 세부 구현 계획
5-1. Chunk → IndexDocument 변환기

위치: src/index/common/transformer.py

역할:

Chunk.summary + Chunk.code + attrs → content

identifiers 추출 (IR/Graph의 symbol table 활용)

RepoMap의 score/parent-child 정보 포함

snapshot_id 반영(필수)

출력: [IndexDocument]

5-2. Lexical Index (Zoekt Only)
5-2-1. Zoekt 사용 이유

초대규모 코드 검색 최적화

regex 기반 고정밀도

delta indexing 지원

코드 전용 ranking model

실제 SOTA 편집기(Serena/Sourcegraph/Cursor)들도 Zoekt 사용

5-2-2. Port 계약
class LexicalIndexPort(Protocol):
    def index(self, repo_id: str, snapshot_id: str, docs: list[IndexDocument]) -> None: ...
    def delete(self, repo_id: str, snapshot_id: str, doc_ids: list[str]) -> None: ...
    def search(self, repo_id: str, snapshot_id: str, query: str, limit: int) -> list[SearchHit]: ...

5-2-3. Zoekt Adapter

Zoekt 인덱스 디렉토리 규칙:
zoekt_index/{repo_id}/{snapshot_id}/

IndexDocument.content → Zoekt file body

tags/identifiers → Zoekt metadata(JSON)

결과 매핑 → SearchHit(source="lexical")

5-3. Vector Index (Qdrant)
저장 필드

chunk_id

embeddings

payload: file_path, symbol_name, identifiers

repomap_score (optional)

검색

semantic query → embedding → Qdrant.search → SearchHit(source="vector")

5-4. Symbol Index (Kuzu Graph)
포지션

Symbol Index는 별도 인덱스가 아니라 Kuzu Graph Store 자체

검색 기능

go-to-definition

find-references

import/use relations

multi-hop call graph

Port 계약

SymbolIndexPort는 Kuzu 쿼리를 래핑하는 thin layer

5-5. Fuzzy Index (pg_trgm)

역할:

오타, incomplete query 대응

단어 기반 후보군 생성

데이터:

identifiers, symbol_name, file_path

PostgreSQL trigram 기반

5-6. Domain Metadata Index (Qdrant)

대상:

README, ADR, API Spec, 문서 chunk

요약 후 embedding 저장 → Qdrant 별도 컬렉션

검색:

자연어 질문 → domain 문서 hit

Retriever에서 코드 hit과 fusion

5-7. Runtime Index (Phase 2~3)

데이터:

OpenTelemetry trace → symbol_id 매핑

실행빈도 기반 runtime_weight

검색:

“실제로 많이 호출되는 코드 우선순위” 기능 제공

6. 증분 인덱싱(Incremental Indexing)
6-1. 입력: ChunkRefreshResult

ChunkIncrementalRefresher의 출력 사용:

added_chunks

updated_chunks

deleted_chunks

renamed_chunks

drifted_chunks

6-2. 공통 규칙

stable_symbol_id + content_hash로 동일성 판단

동일 chunk_id 단위로 Zoekt/Qdrant/Kuzu 업데이트

rename/drift → old_id 삭제 + new_id 생성

6-3. 인덱스별 처리
Zoekt

updated/add → index

deleted → delete

rename/drift → delete + index

Qdrant

upsert(chunk_id)

delete(chunk_id)

Symbol(Kuzu)

GraphDelta 기반 그래프 update

stable_symbol_id 기준 merge

pg_trgm

identifiers, symbol_name 변경된 chunk만 업데이트

Domain/Runtime

필요 시 부분 업데이트

7. IndexingService 통합 전략

위치: src/index/service/indexing_service.py

주요 메서드

index_repo(repo_id, snapshot_id)

index_repo_incremental(repo_id, snapshot_id, changes)

search_repo(repo_id, snapshot_id, query)

내부 흐름 (순차)

ChunkBuilder

Chunk→IndexDocument 변환

Zoekt/Qdrant/Kuzu/pg_trgm/domain 각각 index 호출

Symbol graph projection 캐싱(optional)

최종 SearchHit[] 반환

8. 최종 구현 순서(Phase 기준)
Phase 1 (MVP)

IndexDocument 스키마

transformer.py

Zoekt Adapter

Vector Adapter

IndexingService (MVP)

Phase 2

Symbol(Kuzu) Index Adapter

Fuzzy(pg_trgm)

Weighted Fusion 기반 search_repo 완성

Phase 3

Domain Metadata Index

Runtime Index

9. 누락 없이 반영된 사항 리스트

Zoekt로 Lexical Index 통일

IndexDocument에 snapshot_id 추가

RepoMap score + parent-child tag 전달

ChunkIncrementalRefresher 연결

Symbol Index는 Kuzu Graph 자체

Index Layer 디렉토리 구조 정식화

Port/DI wiring 명시

SearchHit 공통 스키마 확정

index_repo / index_repo_incremental 절차 정식 문서화
